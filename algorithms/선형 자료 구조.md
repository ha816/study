# Overview

선형 자료 구조는 일렬로 늘어선 가장 기초적인 자료구조이다. 대표적으론 배열이 있다. 이번 장에서는 배열과 같이 일렬로 늘어선 자료들을 저장하기 위한 자료 구조인 **동적 배열**과 **연결 리스트**에 이야기 한다.

# 동적 배열

배열의 가장 큰 문제는 처음에 배열 선언시 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없는 점이다. 이와 같은 문제를 해결하기 위해 고안된 배열이 바로 **자료 개수에 따라 크기가 동적으로 변경되는 동적 배열이다.**  

동적 배열은 대게 언어의 표준 라이브러리에 포함되어 있고 내부적으로 배열을 사용하기 때문에 동적 배열은 배열의 특성을 그대로 가진다. 

* 원소들은 메모리의 연속된 위치에 저장된다.
* 주어진 위치의 원소를 반환하거나 변경하는 동작은 수행시간은 $O(1)$이다.

동적 배열은 위의 특성에 추가로 아래 특성을 가진다. 

* 배열의 크기를 변경하는 resize()기능이 있다. 이 동작을 수행하는데 배열 크기 N에 비례하는 시간이 걸린다.
* 주어진 원소를 맨끝에 추가함으로 크기를 1 늘리는 append()연산을 지원한다. 이 동작은 상수 시간만에 처리된다. 

위 기능을 구현하기 위해 동적 배열은 동적으로 할당받은 배여을 사용한다. resize()의 경우, 단순히 새 배열을 동적으로 할당 받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꾼다. 새 배열을 할당받고 기존 원소들을 복사하는데 배열의 크기 $O(N)$이 걸린다. 

문제는 append() 기능을 어떻게 상수 시간만에 구현하느냐가 어렵다. 비결은 바로 메모리를 할당 받을때 배열의 크기가 커질 것을 대비하여 여유분의 메모리를 미리 많이 할당받는 것이다.

배열에서 capacity(용량)는 이미 할당 받은 메모리의 크기를 말한다. 그리고 실제 배열의 원소 수를 배열의 크기(size)라 한다. 용량은 언제나 배열크기보다 같거나 크다. 어느 순간에 배열의 크기가 용량과 같아지면 그때 서야 더 큰 용량의 동적 배열 할당받고 기존 배열을 복사하여 포인터를 바꿔치기 한다. 

```
private void append(Object obj) {
	if(size == capacity){
		int newCapacity = capacity + M;
		int newArray = new int[newCapacity];
		for(int i =0; i < size; ++i){
			newArray[i] = array[i];
		}
		array = newArray;
		capacity = newCapacity;
	}
	array[size++] = obj;
}
```

배열이 가득 찼을때 미리 정해놓은 M이라는 크기만큼 추가 용량을 할당받는 다고 하자. 그러면 이 재할당과정에서 드는 시간은 $O(N+M)$이다. 그렇다면 위와 같은 코드로 구현을 해도 상수시간만에 구현을 못하는게 아닐까?

## 동적 배열 재할당 전략

다행이 append()를 호출할때마다 항상 선형시간의 시간이 걸리는게 아닌다. 선형 시간이 걸리는 것은 아주 가끔 일어나는 경우다. 이렇게 **호출할때 마다 수행 시간이 달라지는 함수의 시간 복잡도를 계산하는 한 가지 방법은 연산을 아주 여러번 반복해서 수행한뒤에 각 수행시간의 평균을 내는것이다.** 

재할당 코드에는 배열의 용량을 M씩 늘렸다. 그러면 M번의 append 후에는 반드시 재할당이 발생한다. 텅빈 배열로 시작해서 N번의 append 연산을 할때 재할당 빈도수 $K = O(\frac{N}{M})$이다. 재할당이 발생할때 마다 복사하는 원소의 수는 $M, 2M, \cdots, KM$이 된다. 이를 정리하면 아래 식이 된다.

$$M + 2M + \cdots + KM = \cfrac{(K+1)*K}{2} * M = O(K^2) = O(N^2)$$

즉 N번의 append() 연산을 하는데 복잡도가 $O(N^2)$이 된다. 따라서 한번 append() 연산에 드는 평균 시간은 $\cfrac{O(N^2)}{N} = O(N)$이 된다. 따라서 이 전략으로 상수시간만에 append를 구할 수는 없다. 

상수 시간에 append()를 구현하는 비결은 **재할당을 할때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다.** 

처음 배열의 용량을 1로 시작해서, 꽉차면 2로 늘리고, 그 다음에는 4로 늘리고 이런 방법을 이용한다고 해보자. 

| |  |||||||
|--|--|--|--|--|--|--|--|
| 재할당시점 | 1 |2|4|8|16|32|...|2048|
| 새로운 배열크기  | 2|4|8|16|32|64|...|4096

이런 전략을 쓰면 항상 복사의 수가 배열의 크기에 선형으로 비례함을 보일 수 있다. $i$ 번째 재할당 시에 복사하는 원소의 수는 $2^{i-1}$이다. 그리고 $i$번째 재할당까지 복사하는 원소의 수를 전부 더한 수행시간은 아래와 같다.

$$1 + 2 + 4 + 8 + \cdots +2^{i-1}= \cfrac{2^{i-1} - 1}{2-1}= O(2^i)$$

그리고 입력크기 $N$은 $2^i > N >= 2^{i-1} + 1$을 만족하기 때문에 
간단히 $i = logN$로 나타낼 수 있다. 
결과적으로 $O(2^i) = O(2^{logN}) = O(N)$이 된다. 전체 복사의 양은 $O(N)$이고 append() 연산을 N번 실행하기 때문에 append() 연산의 복잡도는 평균적으로 O(1)이 된다. 

위 내용을 바탕으로 대부분의 언어들은 이미 동적 배열을 라이브러리로 제공하고 있다. C++의 vector, 자바의 ArrayList등이 그 예이다. 이들은 내부적으로 배열을 사용하기 때문에 배열과 거의 다를것 없는 속도로 기능을 제공한다. 

동적 배열을 사용할때 팁은 append() 연산을 여러번 수행할때 **배열의 최종 크기가 얼마일지 미리 짐작할 수 있다면, 배열의 용량을 미리 충분히 늘려둠으로써 재할당에 드는 비용을 없앨 수 있다.** 

# 연결 리스트

배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 임의의 위치에서 원소를 삭제하는 것은 시간이 오래 걸리는 작업이다. 해당 위치 뒤에 있는 원소들을 하나씩 앞칸 또는 뒤칸으로 옮겨야하는 작업이 필요하기 때문이다. 정확한 수행시간 삽입이나 삭제에 따라 다르지만 일반적으로 이 작업들은 원소 개수에 비례하는 선형 시간이 걸린다. 

이것을 해결하기 위해 고안된 자료구조가 바로 연결 리스트(LinkedList)이다. 연결 리스트를 쓰면 특정 위치에서의 삽입과 삭제를 상수시간만에 처리할 수 있다. 연결리스트는 배열과는 완전히 다른 형태를 가지고 있다. 연결 리스트의 각 원소들은 메모리 여기저기에 흩어져있고 각 원소들이 다음 원소를 가르키는 포인터를 가진다.
연결 리스트 원소와 포인터의 잡합을 리스트의 노드라고 한다. 연결 리스트는 첫 번째 노드와 마지막 노드에 대한 포인터를 가지는데 이를 각각 머리와 꼬리(head & tail)이라 부른다. 대게 연결리스트는 머리와 꼬리 포인터를 가진 클래스로 구현된다.


## 연결 리스트 다루기

배열과는 달리 연결 리스트에서는 메모리 여기저기에 노드들이 흩어져 있어 특정 위치의 값을 찾기가 어렵다. 연결 리스트에서 i번째 노드를 찾으려면 머리에서부터 시작해 다음 노드를 찾을 수 밖에 없다. 결과적으로 i번째 노드를 찾는데 걸리는 시간은 리스트 길이에 비례한다. 

반면 다른 노드들의 순서를 유지하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 아주 간단하다. 왜냐하면 노드들의 순서가 포인터에 의해 정의되기 때문이다. 다른 노드들은 그대로 두고, 삽입/삭제할 노드의 이전/이후 노드의 포인터만 변경하면 된다. 

이와 같이 포인터만 변경하면 되기 때문에 연결 리스트에서의 삽입과 삭제는 각각 상수 시간만에 처리가 된다. 

참고로 연결 리스트를 구현할때 머리와 꼬리를 포인터가 아니라 값이 정의되지 않은 텅 빈 노드로 두는 것도 괜찮다. 이렇게 하면 리스트에 포함된 노드들을 다룰때는 항상 이전 노드와 이후 노드가 존재한다고 가정할 수 있기 때문에 구현이 간단해진다. 

## 표준 라이브러리의 연결 리스트 구현

동적배열과 같이, 대부분의 프로그래밍 언어에서는 연결 리스트의 구현을 표준 라이브러리로 제공한다.  자바에선 LinkedList가 이 자료구조이다. 

## 연결 리스트 응용 연산들

아래 연산들은 연결 리스트를 가지고 할 수 있는 트릭들이지만, 그 사용범위가 제한적이기 때문에 표준 라이브러리에선 잘 지원하지 않는다. 실제로 필요한 경우도 많지 않으니 이런것이 존재한다 정보만 알아두자.

### 잘라 붙이기 연산(splicing)

splice는 새끼줄을 꼬아 이을때 혹은 제목등을 이어 맞출때 쓰는 말이다. 

연결 리스트에서 노드들간의 포인터만 변경해서 원소의 삭제와 삽입을 상수시간만에 할 수 있었던 것을 응용하면 다른 리스트를 통째로 삽입하는 것도 상수시간만에 가능하다. 

잘라 붙이기 연산을 쓰면 두 연결 리스트를 상수 시간만에 합칠수 있어 아주 유용하지만, 잘라 붙이기 연산을 구현하면 **연결 리스트의 크기를 $O(1)$에 알기가 불가능해진다.** 연결 리스트에선 크기를 쉽게 알 수 있는 방법이 없어서 원소가 추가되거나 삭제될때마다 갱신해줘야 하는데, 잘라 붙이기를 할때는 추가된 리스트가 몇개의 원소를 가지는지 알 방법이 없기 때문이다. 

### 삭제했던 원소 돌려놓기

양방향 연결 리스트의 잘 알려지지 않은 장점으로, **한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다는 것이다.** 

이것은 삭제되어야 하는 node에 들어있는 prev, next 정보는 그대로 남아 있기 때문이다. 이를 이용하면 원래 리스트에 쉽게 다시 삽입할 수 있다. 물론 이 방법은 이전 노드와 이후 노드가 삭제된 상태에서 수행하려면 리스트를 망가뜨리기 때문에, 항상 삭제한 순서의 반대로 복구가 이루어질때만 사용 가능하다. 

이 연산은 프로그램에서 되돌리기(undo)연산을 지원하는데 유용하게 쓸 수 있다. 그리고 또 조합 탐색에서도 유용하다. 조합 탐색에서 부분 답을 만들고, 현재 상태를 갱신한뒤 나머지를 재귀적으로 호출한다. 그리고 문제의 상태는 다시 복구 되어야 하는데 이를 되돌리기 연산으로 할 수 있다. 이 기법을 활용하는 기법으로, 커누스(Donald Knuth)가 이름 붙인 춤추는 링크들(Dancing Links)이 있다. 

# 동적 배열과 연결 리스트 비교

두 구조의 가장 큰 차이점은 삽입과 삭제 , 그리고 임의의 원소에 접근하는데 드는 시간이다. 삽입과 삭제를 할일이 없거나 배열의 끝에서만 삽입과 삭제가 일어날 경우, 동적배열이 거의 항상 좋은 선택이다. 그리고 임의의 원소에 빠르게 접근할 수 있을 뿐더러, 원소들이 메모리에 연속해 배치되어 있어 CPU 캐시 효율도 더 좋기 때문이다. 

만약 임의의 원소를 접근하는 것이 아니라 모든 원소들을 순회하며 삽입과 삭제를 한다면 연결 리스트가 좋은 선택이다. 

# 조세푸스 문제(JOSEPHUS)

포위 당한 N명의 병사들이 
 



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTk0OTg4OTgzNSwtODkzMjQ1OTM3LC0yMj
Y4MzkxMzcsLTEzMTYzNzA2NDUsLTE0MzYyODAxOTYsMTI5MzI4
MzQ4NiwtNDgyMjI5OTYxLDIxNjY1MTE4NCwtMjE0NTEwNTc4OS
wtODk5NDE4NjU5LC0zMjY0MTc0MjEsMzExMjAxMzk3LC0xNjY5
MTU4NTEyLC02NjA2MTgwMjksLTEzMzgyNjM4NTUsMjk5NzM5Nj
ExLDUwNzgzMzg5OSwxMTg1ODI3MTksLTE2MDY5Njc4LDMwNjg2
MzQ3N119
-->