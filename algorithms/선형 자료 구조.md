# Overview

선형 자료 구조는 일렬로 늘어선 가장 기초적인 자료구조이다. 대표적으론 배열이 있다. 이번 장에서는 배열과 같이 일렬로 늘어선 자료들을 저장하기 위한 자료 구조인 **동적 배열**과 **연결 리스트**에 이야기 한다.

# 동적 배열

배열의 가장 큰 문제는 처음에 배열 선언시 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없는 점이다. 이와 같은 문제를 해결하기 위해 고안된 배열이 바로 **자료 개수에 따라 크기가 동적으로 변경되는 동적 배열이다.**  

동적 배열은 대게 언어의 표준 라이브러리에 포함되어 있고 내부적으로 배열을 사용하기 때문에 동적 배열은 배열의 특성을 그대로 가진다. 

* 원소들은 메모리의 연속된 위치에 저장된다.
* 주어진 위치의 원소를 반환하거나 변경하는 동작은 수행시간은 $O(1)$이다.

동적 배열은 위의 특성에 추가로 아래 특성을 가진다. 

* 배열의 크기를 변경하는 resize()기능이 있다. 이 동작을 수행하는데 배열 크기 N에 비례하는 시간이 걸린다.
* 주어진 원소를 맨끝에 추가함으로 크기를 1 늘리는 append()연산을 지원한다. 이 동작은 상수 시간만에 처리된다. 

위 기능을 구현하기 위해 동적 배열은 동적으로 할당받은 배여을 사용한다. resize()의 경우, 단순히 새 배열을 동적으로 할당 받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꾼다. 새 배열을 할당받고 기존 원소들을 복사하는데 배열의 크기 $O(N)$이 걸린다. 

문제는 append() 기능을 어떻게 상수 시간만에 구현하느냐가 어렵다. 비결은 바로 메모리를 할당 받을때 배열의 크기가 커질 것을 대비하여 여유분의 메모리를 미리 많이 할당받는 것이다.

배열에서 capacity(용량)는 이미 할당 받은 메모리의 크기를 말한다. 그리고 실제 배열의 원소 수를 배열의 크기(size)라 한다. 용량은 언제나 배열크기보다 같거나 크다. 어느 순간에 배열의 크기가 용량과 같아지면 그때 서야 더 큰 용량의 동적 배열 할당받고 기존 배열을 복사하여 포인터를 바꿔치기 한다. 

```
private void append(Object obj) {
	if(size == capacity){
		int newCapacity = capacity + M;
		int newArray = new int[newCapacity];
		for(int i =0; i < size; ++i){
			newArray[i] = array[i];
		}
		array = newArray;
		capacity = newCapacity;
	}
	array[size++] = obj;
}
```

배열이 가득 찼을때 미리 정해놓은 M이라는 크기만큼 추가 용량을 할당받는 다고 하자. 그러면 이 재할당과정에서 드는 시간은 $O(N+M)$이다. 그렇다면 위와 같은 코드로 구현을 해도 상수시간만에 구현을 못하는게 아닐까?

## 동적 배열 재할당 전략

다행이 append()를 호출할때마다 항상 선형시간의 시간이 걸리는게 아닌다. 선형 시간이 걸리는 것은 아주 가끔 일어나는 경우다. 이렇게 **호출할때 마다 수행 시간이 달라지는 함수의 시간 복잡도를 계산하는 한 가지 방법은 연산을 아주 여러번 반복해서 수행한뒤에 각 수행시간의 평균을 내는것이다.** 

재할당 코드에는 배열의 용량을 M씩 늘렸다. 그러면 M번의 append 후에는 반드시 재할당이 발생한다. 텅빈 배열로 시작해서 N번의 append 연산을 할때 재할당 빈도수 $K = O(\frac{N}{M})$이다. 재할당이 발생할때 마다 복사하는 원소의 수는 $M, 2M, \cdots, KM$이 된다. 이를 정리하면 아래 식이 된다.

$$M + 2M + \cdots + KM = \cfrac{(K+1)*K}{2} * M = O(K^2) = O(N^2)$$

즉 N번의 append() 연산을 하는데 복잡도가 $O(N^2)$이 된다. 따라서 한번 append() 연산에 드는 평균 시간은 $\cfrac{O(N^2)}{N} = O(N)$이 된다. 따라서 이 전략으로 상수시간만에 append를 구할 수는 없다. 

상수 시간에 append()를 구현하는 비결은 **재할당을 할때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다.** 

처음 배열의 용량을 1로 시작해서, 꽉차면 2로 늘리고, 그 다음에는 4로 늘리고 이런 방법을 이용한다고 해보자. 

| |  |||||||
|--|--|--|--|--|--|--|--|
| 재할당시점 | 1 |2|4|8|16|32|...|2048|
| 새로운 배열크기  | 2|4|8|16|32|64|...|4096

이런 전략을 쓰면 항상 복사의 수가 배열의 크기에 선형으로 비례함을 보일 수 있다. $i$ 번째 재할당 시에 복사하는 원소의 수는 $2^{i-1}$이다. 그리고 $i$번째 재할당까지 복사하는 원소의 수를 전부 더한 수행시간은 아래와 같다.

$$1 + 2 + 4 + 8 + \cdots +2^{i-1}= \cfrac{2^{i-1} - 1}{2-1}= O(2^i)$$

그리고 입력크기 N은 $2^i > N >= 2^{i-1} + 1$

 $i = logN$이기 때문에 $O(2^i) = O(N)$이 된다. 전체 복사의 양은 $O(N)$이고 append() 연산을 N번 실행하기 때문에 append()연산의 복잡도는 평균적으로 O(1)이 된다. 

위 내용을 바탕으로 대부분의 언어들은 이미 동적 배열을 라이브러리로 제공하고 있다. C++의 vector, 자바의 ArrayList등이 그 예이다. 이들은 내부적으로 배열을 사용하기 때문에 배열과 거의 다를것 없는 속도로 기능을 제공한다. 

동적 배열을 사용할때 팁은 append() 연산을 여러번 수행할때 **배열의 최종 크기가 얼마일지 미리 짐작할 수 있다면, 배열의 용량을 미리 충분히 늘려둠으로써 재할당에 드는 비용을 없앨 수 있다.** 

# 연결 리스트



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTk4MTQzNzQwNiwxMTg1ODI3MTksLTE2MD
Y5Njc4LDMwNjg2MzQ3NywtMjAzNTk3NTc0LDE0NTAyNzI1NDIs
LTEzMzM3Nzg2OTAsNjA0ODU1MzQsLTEwNzI1NzIxNzYsMTcwMj
MyOTQ5OSwtOTk0NTg2NjUsMjAzNzEwOTMxOCwtNTMxMTIzMjU2
LDkwNjc3ODY5MiwxODgzMjI3MTAxLDE5NzA4ODAzMzEsLTkzMj
c5ODk0MCwyMDQwMjQ1NTUsMTUxMTUwODg3NF19
-->