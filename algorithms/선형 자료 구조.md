# Overview

선형 자료 구조는 일렬로 늘어선 가장 기초적인 자료구조이다. 대표적으론 배열이 있다. 이번 장에서는 배열과 같이 일렬로 늘어선 자료들을 저장하기 위한 자료 구조인 **동적 배열**과 **연결 리스트**에 이야기 한다.

# 동적 배열

배열의 가장 큰 문제는 처음에 배열 선언시 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없는 점이다. 이와 같은 문제를 해결하기 위해 고안된 배열이 바로 **자료 개수에 따라 크기가 동적으로 변경되는 동적 배열이다.**  

동적 배열은 대게 언어의 표준 라이브러리에 포함되어 있고 내부적으로 배열을 사용하기 때문에 동적 배열은 배열의 특성을 그대로 가진다. 

* 원소들은 메모리의 연속된 위치에 저장된다.
* 주어진 위치의 원소를 반환하거나 변경하는 동작은 수행시간은 $O(1)$이다.

동적 배열은 위의 특성에 추가로 아래 특성을 가진다. 

* 배열의 크기를 변경하는 resize()기능이 있다. 이 동작을 수행하는데 배열 크기 N에 비례하는 시간이 걸린다.
* 주어진 원소를 맨끝에 추가함으로 크기를 1 늘리는 append()연산을 지원한다. 이 동작은 상수 시간만에 처리된다. 

위 기능을 구현하기 위해 동적 배열은 동적으로 할당받은 배여을 사용한다. resize()의 경우, 단순히 새 배열을 동적으로 할당 받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꾼다. 새 배열을 할당받고 기존 원소들을 복사하는데 배열의 크기 $O(N)$이 걸린다. 

문제는 append() 기능을 어떻게 상수 시간만에 구현하느냐가 어렵다. 비결은 바로 메모리를 할당 받을때 배열의 크기가 커질 것을 대비하여 여유분의 메모리를 미리 많이 할당받는 것이다.

배열에서 capacity(용량)는 이미 할당 받은 메모리의 크기를 말한다. 그리고 실제 배열의 원소 수를 배열의 크기(size)라 한다. 용량은 언제나 배열크기보다 같거나 크다. 어느 순간에 배열의 크기가 용량과 같아지면 그때 서야 더 큰 용량의 동적 배열 할당받고 기존 배열을 복사하여 포인터를 바꿔치기 한다. 

```
private void append(Object obj) {
	if(size == capacity){
		int newCapacity = capacity + M;
		int newArray = new int[newCapacity];
		for(int i =0; i < size; ++i){
			newArray[i] = array[i];
		}
		array = newArray;
		capacity = newCapacity;
	}
	array[size++] = obj;
}
```

배열이 가득 찼을때 미리 정해놓은 M이라는 크기만큼 추가 용량을 할당받는 다고 하자. 그러면 이 재할당과정에서 드는 시간은 $O(N+M)$이다. 그렇다면 위와 같은 코드로 구현을 해도 상수시간만에 구현을 못하는게 아닐까?

## 동적 배열 재할당 전략

다행이 append()를 호출할때마다 항상 선형시간의 시간이 걸리는게 아닌다. 선형 시간이 걸리는 것은 아주 가끔 일어나는 경우다. 이렇게 **호출할때 마다 수행 시간이 달라지는 함수의 시간 복잡도를 계산하는 한 가지 방법은 연산을 아주 여러번 반복해서 수행한뒤에 각 수행시간의 평균을 내는것이다.** 

재할당 코드에는 배열의 용량을 M씩 늘렸다. 그러면 M번의 append 후에는 반드시 재할당이 발생한다. 텅빈 배열로 시작해서 N번의 append 연산을 할때 재할당 수 $K = O(\frac{N}{M})$이다. 이때 재할당마다 복사하는 원소의 수가 M개, 2M개 ..., K*M 증가함으로 전체 복사하는 원소의 수는 아래와 같다. 

$$\cfrac{(K+1)*K}{2} * M = O(K^2) = O(N^2)$$

N번의 append() 연산을 하는데 총 드는 시간이 $O(N^2)$이면 한번 append() 연산에 드는 평균 시간은 $\cfrac{O(N^2)}{N} = O(N)$이 된다. 따라서 이 전략으로 상수시간에 append를 구할 수는 없다. 

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTA2Nzc4NjkyLDE4ODMyMjcxMDEsMTk3MD
g4MDMzMSwtOTMyNzk4OTQwLDIwNDAyNDU1NSwxNTExNTA4ODc0
XX0=
-->