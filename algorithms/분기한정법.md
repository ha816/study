# 분기한정법(branch-and-bound)

분기한정법은 여러가지의 최적화 문제, 특히 조합최적화 (combinatorial optimization) 에서 최적 해를 찾기위한 일반적인 방법이다. `최소한 특정 영역 내에 있어야 최적의 답을 찾을 가능성이 있다.`라는 한정 범위(가능영역;feasible region)를 정해두고 범위를 벗어나는 경우는 계산과정에서 제외하여 속도 향상을 꾀한다. 

분기한정 과정은 분기(branching)와 한정(bounding)이라는 두 가지 과정을 거친다. 

분기(branching)
: 분기는 가능영역(feasible region)에서 여러 개의 작은 하위영역(feasible subregion)을 구성한다. 이 작은 하위 영역은 재귀 반복 과정을 통해 만들어지고 자연스럽게 branch-and-bound-tree 라고 불리는 tree 구조를 형성한다. 이 구조의 각 노드들이 바로 하위영역이다.

한정(bounding)
: 한정은 하위영역 내에서 최적해를 찾기위한 최소 또는 최대의 범위(upper and lower bound )를 를 빠르게 찾는다.

분기한정법의 핵심은, (작업을  최소화  하기 위해) 탐색트리에서 하위영역 A 의 lower bound 가 이미 검사된 다른 하위영역 B 의 upper bound 보다 크다면 A 를 탐색에서 제외하는 간단한 방법이다. 이러한 단계를 절단 (pruning) 이라고 부른다. 절단은 검사된 모든 하위영역 중에서 볼수있는 minimum upper bound 를 기록하는 전역변수를 하나 유지함으로써 구현 할 수 있다. 즉 임의의 한 하위영역의 lower bound 가 m 보다 크면 바로 그 하위영역은 계산에서 제외를 한다. 
 이상적으로는 분기한정법은 탐색트리의 모든 노드가 절단 (pruned) 되거나 해결 (solved) 되면 끝난다. 그러한 관점에서 모든 non-pruned subregions 은 함수의 전역 최소값과 같은 upper and lower bounds 를 가질것이다. 
  분기한정법의 효율은 사용되는 branching and bounding algorithm 에 전적으로 의존한다. 즉 잘못된 알고리즘을 사용하하면 하위영역이 매우 작아질 때 까지 어떤 pruning 도 없이 반복된 branching 만 할수도 있다. 그러한 경우에 분기한정법은 비현실적으로 큰 소모적인 열거 (exhaustive enumeration of the domain) 로 환원될 것이다. 모든 문제 해결을 위한 범용 bounding algorithm 은 존재하지 않으며 누군가 발견할 것이라고 희망할수도 없다. 그러므로 일반적인 패러다임은 각각의 응용을 위해 따로 구현될 필요가 있으며 branching and bounding algorithm 은 그 경우에 특별히 설계된다. 분기한정법은 bounding method 와 탐색트리 노드를 생성하고 검사하는 방법에 따라 분류될수 있다.**


대표적인 알고리즘으로는 외판원문제(Traveling Salesman Problem), 배낭문제(Knapsack Problem)이 있다. 


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0MDY5OTI5MDYsNjI1NDQzNTk3LDE3MD
E5NDc4NTIsLTU3NDE4MTExOSwtMTAyNTUwMDk1M119
-->