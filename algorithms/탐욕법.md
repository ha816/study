# 탐욕법(Greedy Method)

탐욕법(Greedy Method)은 가장 직관적인 알고리즘 설계 패러다임 중 하나다. 탐욕법을 이용한 알고리즘, 혹은 탐욕적인 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 조각으로 쪼개고, 각 단계마다 답의 결과를 만들어 간다는 점에서 동적계획법, 완전탐색과 비슷하다. 하지만 탐욕법은 두 방법과 달리, 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다. 

예를 들어, 외판원 문제는 모든 도시들을 하나씩 검사하여 필요한 거리를 최소화하는 경로를 찾는다. 탐욕법은 지금의 선택이 앞으로 남은 선택에 어떤 영향을 미칠지 고려하지 않고 당장 눈앞에 최소 경로를 가지는 도시를 선택한다. 

당연히 이런 간단한 방법으로는 우리가 원하는 정답이 나올리 없다. 탐욕적 알고리즘은 대체로 최적해를 찾지 못한다. 따라서 탐욕법이 사용되는 경우는 크게 두가지로 제한된다. 

1. 탐욕법을 사용해도 최적해를 구할 수 있는 문제인 경우, 탐욕법은 동적계획법보다 수행시간이 훨씬 빠르기 때문에 유용하다.
2. 시간이나 공간적 제약으로 다른 방법으로 최적해를 찾기 너무 어려운 경우, 최적해 대신 적당한 답을 찾는 것으로 타협이 가능하다. 이럴때 탐욕법이 유용하게 사용된다.

탐욕법의 개념은 간단하지만 굉장히 어려운 주제다. 한 문제를 해결하는데 탐욕적으로 해결하는 방법이 한가지만이 아닌 경우도 많고, 어느 방법을 선택해야 최적해를 구하는지 알기가 어렵기 때문이다. 실제로 최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많다. 그러니 탐욕적 알고리즘을 풀때는 정당성 증명과정을 정확히 하는게 좋다. 


## 회의실 예약(ActivitySelectionProblem)

회사에 회의실이 하나밖에 없는데 여러 팀이 하루동안 회의실을 사용한다고 하자. 회의실 사용시간은 08:00에서 18:00까지, 최소 한 시간 단위의 사용이 가능하다. 우리는 다수 팀으로부터 회의실 사용시간표를 받았고 이 중 시간이 서로 겹치지 않는 회의들을 잡아야 한다. 최대 몇개나 선택할 수 있을까?

천천히 생각해보면 서로 시간이 겹치지 않는 회의들의 집합이 모두 이 문제의 답이다. 그리고 이 중에서 가장 좋은 답, 곧 최적해는 집합의 크기가 가장 큰 부분 집합이다.  

가장 간단히 접근법은 $n$개의 팀에 대한 가능한 모든 부분집합을 만들고 그 중 시간이 겹치치 않는 팀 조합을 만들어보고 크기가 가장 큰 부분집합을 찾는것이다. 그러나 확인해야할 부분집합의 수는 $2^n$이기 때문에 복잡도가 너무 높다. 

탐욕적 방법으로 이 문제를 푸는 방법은 다양하다. 먼저 길이가 짧은 회의부터 하나하나 순회하면서 앞의 것들과 겹치지 않는 것들을 추가하는 방법을 생각해보자. 이 방법은 회의실을 사용하는 시간을 최대화 하려고 노력하기 때문에 그럴싸해보인다. 하지만 긴 회의를 두개를 연달아 개최하는 경우 최적값을 찾지 못한다. 이렇듯 탐욕법에서는 그럴듯하다고 해서 정답을 찾는 것이 아니다. 그래서 어렵다. 

정답을 말하자면 **회의 시간 길이와 상관없이 가장 먼저 끝나는 회의를 선택하는 것이다.** 가장 먼저 끝나는 회의를 선택하고, 이 회의와 겹치는 것들을 모두 지운뒤 다시 이중에서 가장 먼저 끝나는 회의를 선택하는 것을 반복하는 것이다. 

1. 주어진 목록 $S$에 남은 회의 중 가장 일찍 끝나는 회의 $S_{min}$을 선택한다.
2. $S_{min}$과 겹치는 회의를 $S$에서 모두 지운다.
3. $S$가 텅빌때 까지 반복한다. 

[테스트 데이터](https://ratsgo.github.io/data%20structure&algorithm/2017/11/22/greedy/)


## 정당성 증명: 탐욕적 선택속성(greedy choice property)

알고리즘의 정당성 증명은 대다수가 일정한 패턴을 가진다. 이 증명패턴은 탐욕적 알고리즘이 항상 최적해를 찾는다는 것을 두 가지 속성을 증명함으로써 밝힌다. 이 두가지 속성은 탐욕적 선택속성(greedy choice property)과 최적부분구조(optimal substructure)이다.

탐욕법에서 탐욕적 선택속성(greedy choice property)은 매우 중요하기 한데 동적계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로 선택하더라도 최적해를 구할 수 있기 때문이다. 즉 어떤 알고리즘이 이 속성을 만족할 경우, 우리는 각 단계에서 탐욕적인 선택을 해서 손해를 볼일이 없다는 것을 알 수 있다. 

앞서 회의 시간 길이와 상관없이 가장 먼저 끝나는 회의를 선택하는 것은 사실 탐욕적 선택속성이 성립하고 다르게 표현하자면 아래와 같이 이야기 할 수 있다. 

> 가장 종료시간이 빠른 회의($S_{min}$)를 포함하는 최적해가 반드시 존재한다. 

만약 $S$의 최적해 중에서 $S_{min}$을 포함하지 않는 답이 있다고 하자. 이 답은 서로 겹치치 않는 회의의 목록이라는 가정하에 있는데, 이 목록에서 첫 번째로 개최되는 회의를 지우고 $S_{min}$을 대신 추가해서 새로운 목록을 만들자. $S_{min}$은 $S$에서 가장 일찍 끝나는 회의이기 때문에 지워진 회의는 $S_{min}$보다 일찍 끝날 수가 없다. 따라서 두번째 회의와 $S_{min}$이 겹치는 일은 없으며, 새로 만든 목록도 최적해중 하나가 된다. 따라서 항상 $S_{min}$을 포함하는 최적해는 존재한다. 

우리는 위 증명을 통해서 가장 일찍 끝나는 회의를 선택하면 언제나 최적해를 얻는 것을 밝혔다. 하지만 탐욕적 방법이 답을 줄 수 있다고 해서 증명이 끝난 것이 아니다. 항상 탐욕적 선택해도 전체 문제의 최적해를 얻을 수 있음을 보여야 한다. 다행이 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 많다.

## [출전순서 정하기](https://algospot.com/judge/problem/read/MATCHORDER)

알고스팟 컵의 결승전이 다가왔다. 각 팀은 n명씩의 프로 코더들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전해 1:1 경기를 벌여 더 많은 승리를 가져가는 팀이 최종적으로 우승하게 된다. 

한국팀의 유감독은 첩보를 통해 상대 러시아팀의 출전 순서를 알아냈다. 이 대회에서는 각 선수의 실력을 레이팅(rating)으로 표현한다. 문제를 간단히 하기 위해 1:1 승부에서는 항상 레이팅이 더 높은 선수가 승리하고, 레이팅이 같을 경우 우리 선수가 승리한다고 가정하자.

|경기|1|2|3|4|5|6|
|--|--|--|--|--|--|--|
|러시아팀|3000|2700|2800|2200|2500|1900|
|한국팀|2800|2750|2995|1800|2600|2000|

표와 같이 출전 순서를 정했다고 하면 한국팀은 2번, 3번, 5번, 6번 경기에서 승리해 전체 네 경기를 이기게 된다. 그러나 대신 4번 경기와 1번 경기에 나갈 선수를 바꾸면 1번 경기만을 제외하고 모든 경기에 승리할 수 있다. 상대방 팀 선수들의 순서를 알고 있을 때, 어느 순서대로 선수들을 내보내야 승수를 최대화할 수 있을까? 최대승수를 계산하는 프로그램을 짜보자.

가장 간단한 방법은 모든 가능한 순서에 대해서 승수를 계산해서 그중에 가장 큰 승수를 반환하면 된다. 그러나 따져보아야 하는 순서가 모두 $n!$개 이기 때문에 복잡도가 너무 높다. 

상대의 선수들의 레이팅 점수를 알고 있기 때문에, 상대 선수들의 레이팅 점수를 내림차순으로 정렬하고 정렬된 리스트를 $A$라 하자. 마찬가지로 우리팀 선수들의 레이팅 점수로 정렬된 리스트를 $B$라고 하자.

상대팀 선수 중 레이팅 점수가 $x$번째로 높은 선수에 대해서, 그 선수의 레이팅 점수인 $a_x$와 같거나 큰 점수를 가지는 우리팀 선수가 존재하면 그 선수를 이길 수 있다. 이렇게 $a_x$를 이길 수 있는 $B$의 부분집합을 $B_{a_x}$라 하자. 그러면 정의에 따라서 $\forall b \in B_{a_x}, b >= a_x$가 언제나 만족한다. 

정리를 하자면 상대팀 $x$번째 선수에 대해서, 이 선수를 무조건 이기는 것이 최대승수를 얻을수 있을까 아니면 전략적으로 일부러 지는 것이 최대 승수를 얻을 수 있을까? 정답은 무조건 이기는 것이 최대승수를 얻을 수 있다. 그리고 사실 우리가 구할 수 있는 최대 승수는 정해져있다. 바로 상대팀 가장 마지막 선수에 대한 $B_{a_n}$의 크기가 가능한 최대 승수($|B_{a_n}|$)가 된다. 

전략적으로 이번 $x$번째 선수에게 일부러 진다는 것은 $B-B_{a_x}$의 한 선수를 출전시키는 것이다. $B-B_{a_x}$에서 가장 약한 선수를 출전시킨다고 해도 만약 그 선수가 이길 수 있는 상대팀 선수가 존재했다면 이길수 있는 승수를 하나 버리게 되는 꼴이 된다. 따라서 전략적인 패배는 도움이 되지 않는 전략이다. 

이제 우리는 가능한 반드시 이기는 전략을 구사할 것이다. 상대팀의 $x$번째 선수에 대해서, 이길 수 있는 $B_{a_x}$를 구하는데 $x$ 번째에 앞서 이미 출전한 선수들은 제외한다. ($|E_{x-1}| = x-1$)

만약 $B_{a_x}-E_{x-1}$에 해당하는 선수가 존재하면 이번 $x$번째 선수는 이길 수 있다는 이야기이다. 그리고 아무 선수를 출전시킨다. 아무 선수를 출전시키는 것이 아니라 가장 작은 레이팅 점수를 가지는 선수를 출전 시켜야 할것 같지만 정의에 따라서 $B_{a_x}-E_{x-1}$에서 가장 작은 레이팅의 선수도 상대팀의 다음 선수보다 레이팅 점수가 높기 때문에 상관이 없다. ($\min B_{a_x}-D_{x-1} >= \max B_{a_x+1}-D_{x}$)

만약 $B_{a_x}-D_{x-1}$에 선수가 없다면, 상대의 $x$번째 선수를 이길 수 있는 우리팀 선수가 없다는 이야기이다. 따라서 $(B-B_{a_x})-D_{x-1}$에 해당하는 선수중에 가장 작은레이팅 점수를 가지는 선수를 출전 시킨다. 그 이유는 레이팅 점수가 작은 선수가 상대팀 선수를 이기는 경우가 가장 작기 때문이다. 

## [도시락 데우기](https://algospot.com/judge/problem/read/LUNCHBOX)

$N$명의 참가자을 위해 $N$개 점심도시락을 준비했다. 많은 양의 주문때문에, 모두 같은 메뉴를 준비할 수 가 없었다. 대신에, 각기 다른 종류의 $N$개의 점심 도시락을 준비했다. 그런데 점심시간에 보니 전자레인지가 딱 하나밖에 없다. 모든 점심도시락의 종류가 같지 않기 때문에, 다른 종류의 전자레인지가 필요하다. i번째 점심 도시락은 데우는데 Mi 시간이 걸리고 먹는데 Ei 초가 걸린다.

점심 시간을 최소화하기위해서 전자레인지 사용 전략을 생각해야 한다. 
점심 시간은 아무 한 점심 도시락이 데워질때 부터 모든 참가자가 도시락을 다 먹었을때 까지이다. 최소 점심시간을 계산해주는 프로그램을 짜자. 

Ainu7 needs to schedule microwave usage order to minimize lunch time. Lunch time is defined as the duration from the beginning of microwaving of any lunch box to the end of eating for all participants. Write a computer program that finds minimum lunch time to help Ainu7. Note that substituting lunch while microwave is turned on is totally unnecessary, because the lunch will be cooled down.


## [문자열 합치기](https://algospot.com/judge/problem/read/STRJOIN)







> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI0MTMxMTk2Niw2NzI3NTI0OCwxNjQ3Nj
U4MDQ1LDEzNTMwOTc3MzYsMTcwODc5Nzc5MywxMDU1ODkxMTY2
LC0xOTkxNjIwNDYxLDE0NzY2OTg5MDAsMjkzMjAxMzA5LDEwMT
IxMzQ4MjQsMjA3Njk0MzI2LC01NTk3MTE5MDAsNzYwODcxOTMs
LTExMTM5Mzg1NTgsLTY4NzE3MjcxNywtMTg1ODY1MTQ1MCwxMz
cxMjIwOTQwLDIwODk1MzY4NzIsLTE4Nzg5OTYzNzcsLTE3ODYy
MjIzMl19
-->