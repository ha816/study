# 탐욕법(Greedy Method)

탐욕법(Greedy Method)은 가장 직관적인 알고리즘 설계 패러다임 중 하나다. 탐욕법을 이용한 알고리즘, 혹은 탐욕적인 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 조각으로 쪼개고, 각 단계마다 답의 결과를 만들어 간다는 점에서 동적계획법, 완전탐색과 비슷하다. 하지만 탐욕법은 두 방법과 달리, 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다. 

예를 들어, 외판원 문제는 모든 도시들을 하나씩 검사하여 필요한 거리를 최소화하는 경로를 찾는다. 탐욕법은 지금의 선택이 앞으로 남은 선택에 어떤 영향을 미칠지 고려하지 않고 당장 눈앞에 최소 경로를 가지는 도시를 선택한다. 

당연히 이런 간단한 방법으로는 우리가 원하는 정답이 나올리 없다. 탐욕적 알고리즘은 대체로 최적해를 찾지 못한다. 따라서 탐욕법이 사용되는 경우는 크게 두가지로 제한된다. 

1. 탐욕법을 사용해도 최적해를 구할 수 있는 문제인 경우, 탐욕법은 동적계획법보다 수행시간이 훨씬 빠르기 때문에 유용하다.
2. 시간이나 공간적 제약으로 다른 방법으로 최적해를 찾기 너무 어려운 경우, 최적해 대신 적당한 답을 찾는 것으로 타협이 가능하다. 이럴때 탐욕법이 유용하게 사용된다.

탐욕법의 개념은 간단하지만 굉장히 어려운 주제다. 한 문제를 해결하는데 탐욕적으로 해결하는 방법이 한가지만이 아닌 경우도 많고, 어느 방법을 선택해야 최적해를 구하는지 알기가 어렵기 때문이다. 실제로 최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많다. 그러니 탐욕적 알고리즘을 풀때는 정당성 증명과정을 정확히 하는게 좋다. 


## 회의실 예약(ActivitySelectionProblem)

회사에 회의실이 하나밖에 없는데 여러 팀이 하루동안 회의실을 사용한다고 하자. 회의실 사용시간은 08:00에서 18:00까지, 최소 한 시간 단위의 사용이 가능하다. 우리는 다수 팀으로부터 회의실 사용시간표를 받았고 이 중 시간이 서로 겹치지 않는 회의들을 잡아야 한다. 최대 몇개나 선택할 수 있을까?

천천히 생각해보면 서로 시간이 겹치지 않는 회의들의 집합이 모두 이 문제의 답이다. 그리고 이 중에서 가장 좋은 답, 곧 최적해는 집합의 크기가 가장 큰 부분 집합이다.  

가장 간단히 접근법은 $n$개의 팀에 대한 가능한 모든 부분집합을 만들고 그 중 시간이 겹치치 않는 팀 조합을 만들어보고 크기가 가장 큰 부분집합을 찾는것이다. 그러나 확인해야할 부분집합의 수는 $2^n$이기 때문에 복잡도가 너무 높다. 

탐욕적 방법으로 이 문제를 푸는 방법은 다양하다. 먼저 길이가 짧은 회의부터 하나하나 순회하면서 앞의 것들과 겹치지 않는 것들을 추가하는 방법을 생각해보자. 이 방법은 회의실을 사용하는 시간을 최대화 하려고 노력하기 때문에 그럴싸해보인다. 하지만 긴 회의를 두개를 연달아 개최하는 경우 최적값을 찾지 못한다. 이렇듯 탐욕법에서는 그럴듯하다고 해서 정답을 찾는 것이 아니다. 그래서 어렵다. 

정답을 말하자면 **회의 시간 길이와 상관없이 가장 먼저 끝나는 회의를 선택하는 것이다.** 가장 먼저 끝나는 회의를 선택하고, 이 회의와 겹치는 것들을 모두 지운뒤 다시 이중에서 가장 먼저 끝나는 회의를 선택하는 것을 반복하는 것이다. 

1. 주어진 목록 $S$에 남은 회의 중 가장 일찍 끝나는 회의 $S_{min}$을 선택한다.
2. $S_{min}$과 겹치는 회의를 $S$에서 모두 지운다.
3. $S$가 텅빌때 까지 반복한다. 

[테스트 데이터](https://ratsgo.github.io/data%20structure&algorithm/2017/11/22/greedy/)


## 정당성 증명: 탐욕적 선택속성(greedy choice property)

알고리즘의 정당성 증명은 대다수가 일정한 패턴을 가진다. 이 증명패턴은 탐욕적 알고리즘이 항상 최적해를 찾는다는 것을 두 가지 속성을 증명함으로써 밝힌다. 이 두가지 속성은 탐욕적 선택속성(greedy choice property)과 최적부분구조(optimal substructure)이다.

탐욕법에서 탐욕적 선택속성(greedy choice property)은 매우 중요하기 한데 동적계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로 선택하더라도 최적해를 구할 수 있기 때문이다. 즉 어떤 알고리즘이 이 속성을 만족할 경우, 우리는 각 단계에서 탐욕적인 선택을 해서 손해를 볼일이 없다는 것을 알 수 있다. 

앞서 회의 시간 길이와 상관없이 가장 먼저 끝나는 회의를 선택하는 것은 사실 탐욕적 선택속성이 성립하고 다르게 표현하자면 아래와 같이 이야기 할 수 있다. 

> 가장 종료시간이 빠른 회의($S_{min}$)를 포함하는 최적해가 반드시 존재한다. 

만약 $S$의 최적해 중에서 $S_{min}$을 포함하지 않는 답이 있다고 하자. 이 답은 서로 겹치치 않는 회의의 목록이라는 가정하에 있는데, 이 목록에서 첫 번째로 개최되는 회의를 지우고 $S_{min}$을 대신 추가해서 새로운 목록을 만들자. $S_{min}$은 $S$에서 가장 일찍 끝나는 회의이기 때문에 지워진 회의는 $S_{min}$보다 일찍 끝날 수가 없다. 따라서 두번째 회의와 $S_{min}$이 겹치는 일은 없으며, 새로 만든 목록도 최적해중 하나가 된다. 따라서 항상 $S_{min}$을 포함하는 최적해는 존재한다. 

우리는 위 증명을 통해서 가장 일찍 끝나는 회의를 선택하면 언제나 최적해를 얻는 것을 밝혔다. 하지만 탐욕적 방법이 답을 줄 수 있다고 해서 증명이 끝난 것이 아니다. 항상 탐욕적 선택해도 전체 문제의 최적해를 얻을 수 있음을 보여야 한다. 다행이 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 많다.

## [출전순서 정하기](https://algospot.com/judge/problem/read/MATCHORDER)

알고스팟 컵의 결승전이 다가왔다. 각 팀은 n명씩의 프로 코더들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전해 1:1 경기를 벌여 더 많은 승리를 가져가는 팀이 최종적으로 우승하게 된다. 

한국팀의 유감독은 첩보를 통해 상대 러시아팀의 출전 순서를 알아냈다. 이 대회에서는 각 선수의 실력을 레이팅(rating)으로 표현한다. 문제를 간단히 하기 위해 1:1 승부에서는 항상 레이팅이 더 높은 선수가 승리하고, 레이팅이 같을 경우 우리 선수가 승리한다고 가정하자.

|경기|1|2|3|4|5|6|
|--|--|--|--|--|--|--|
|러시아팀|3000|2700|2800|2200|2500|1900|
|한국팀|2800|2750|2995|1800|2600|2000|

표와 같이 출전 순서를 정했다고 하면 한국팀은 2번, 3번, 5번, 6번 경기에서 승리해 전체 네 경기를 이기게 된다. 그러나 대신 4번 경기와 1번 경기에 나갈 선수를 바꾸면 1번 경기만을 제외하고 모든 경기에 승리할 수 있다. 상대방 팀 선수들의 순서를 알고 있을 때, 어느 순서대로 선수들을 내보내야 승수를 최대화할 수 있을까? 최대승수를 계산하는 프로그램을 짜보자.

가장 간단한 방법은 모든 가능한 순서에 대해서 승수를 계산해서 그중에 가장 큰 승수를 반환하면 된다. 그러나 따져보아야 하는 순서가 모두 $n!$개 이기 때문에 복잡도가 너무 높다. 

상대의 선수들의 레이팅 점수를 알고 있기 때문에, 상대 선수들의 레이팅 점수를 내림차순으로 정렬하고 정렬된 리스트를 $A$라 하자. 마찬가지로 우리팀 선수들의 레이팅 점수로 정렬된 리스트를 $B$라고 하자.

상대팀 선수 중 레이팅 점수가 $x$번째로 높은 선수에 대해서, 그 선수의 레이팅 점수인 $a_x$와 같거나 큰 점수를 가지는 우리팀 선수가 존재하면 그 선수를 이길 수 있다. 이렇게 $a_x$를 이길 수 있는 $B$의 부분집합을 $B_{a_x}$라 하자. 그러면 정의에 따라서 $\forall b \in B_{a_x}, b >= a_x$가 언제나 만족한다. 

정리를 하자면 상대팀 $x$번째 선수에 대해서, 이 선수를 무조건 이기는 것이 최대승수를 얻을수 있을까 아니면 전략적으로 일부러 지는 것이 최대 승수를 얻을 수 있을까? 정답은 무조건 이기는 것이 최대승수를 얻을 수 있다. 그리고 사실 우리가 구할 수 있는 최대 승수는 정해져있다. 바로 상대팀 가장 마지막 선수에 대한 $B_{a_n}$의 크기가 가능한 최대 승수($|B_{a_n}|$)가 된다. 

전략적으로 이번 $x$번째 선수에게 일부러 진다는 것은 $B-B_{a_x}$의 한 선수를 출전시키는 것이다. $B-B_{a_x}$에서 가장 약한 선수를 출전시킨다고 해도 만약 그 선수가 이길 수 있는 상대팀 선수가 존재했다면 이길수 있는 승수를 하나 버리게 되는 꼴이 된다. 따라서 전략적인 패배는 도움이 되지 않는 전략이다. 

이제 우리는 가능한 반드시 이기는 전략을 구사할 것이다. 상대팀의 $x$번째 선수에 대해서, 이길 수 있는 $B_{a_x}$를 구하는데 $x$ 번째에 앞서 이미 출전한 선수들은 제외한다. ($|E_{x-1}| = x-1$)

만약 $B_{a_x}-E_{x-1}$에 해당하는 선수가 존재하면 이번 $x$번째 선수는 이길 수 있다는 이야기이다. 그리고 아무 선수를 출전시킨다. 아무 선수를 출전시키는 것이 아니라 가장 작은 레이팅 점수를 가지는 선수를 출전 시켜야 할것 같지만 정의에 따라서 $B_{a_x}-E_{x-1}$에서 가장 작은 레이팅의 선수도 상대팀의 다음 선수보다 레이팅 점수가 높기 때문에 상관이 없다. ($\min B_{a_x}-D_{x-1} >= \max B_{a_x+1}-D_{x}$)

만약 $B_{a_x}-D_{x-1}$에 선수가 없다면, 상대의 $x$번째 선수를 이길 수 있는 우리팀 선수가 없다는 이야기이다. 따라서 $(B-B_{a_x})-D_{x-1}$에 해당하는 선수중에 가장 작은레이팅 점수를 가지는 선수를 출전 시킨다. 그 이유는 레이팅 점수가 작은 선수가 상대팀 선수를 이기는 경우가 가장 작기 때문이다. 

## [도시락 데우기](https://algospot.com/judge/problem/read/LUNCHBOX)

$N$명의 참가자을 위해 $N$개 점심도시락을 준비했다. 많은 양의 주문때문에, 모두 같은 메뉴를 준비할 수 가 없었다. 대신에, 각기 다른 종류의 $N$개의 점심 도시락을 준비했다. 그런데 점심시간에 보니 전자레인지가 딱 하나밖에 없다. 모든 점심도시락의 종류가 같지 않기 때문에, 다른 종류의 전자레인지가 필요하다. $i$번째 점심 도시락은 데우는데 $H_i$ 시간이 걸리고 먹는데 $E_i$ 초가 걸린다.

점심 시간을 최소화하기위해서 전자레인지 사용 스케쥴을 생각해야 한다. 
점심 시간은 도시락을 전자레인지에 돌릴때부터 모든 참가자가 도시락을 다 먹을때 까지이다. 도시락은 빨리 식기 때문에 데우고 나서 바로 먹기 시작한다고 할때, 최소 점심시간을 계산해주는 프로그램을 짜자. 중요한점은 전자레인지는 하나지만 일단 도시락이 데워지기만 하면 도시락을 받은 사람들은 동시에 식사가 가능하다. 

우리가 구해야할 최소 점심시간은 아래와 같은 식으로 표현가능하다. 

$$minCostTime = \max_{i=1 \cdots n}(∑_{p=0}^{i-1}H_p+H_i +E_i)$$

즉 참가자가 일련의 과정을 거쳐 마침내 자신의 도시락을 다 먹는데까지 걸리는 시간 중의 가장 큰 값이 우리가 알고 싶은 최소 소요 점심시간이 된다. 

직감적으로 먹는 시간이 오래 걸리는 사람($E$)의 도시락을 먼저 처리해야 점심시간을 최소화할 수 있어 보인다. 이것을 증명하기 위해 귀무가설인 도시락을 먹는데 걸리는 시간이 적은 순서대로 처리한다고 가정해보자. 작은순서로 처리했을때 최대값을 못찾는 경우를 밝히면 먹는 시간이 오래걸리는 사람을 먼저 처리하는 방법이 옳은 것으로 증명된다. 
먼저, 임의의 $k$번째 사람이 최대값을 가지는 경우라고 생각하자.$$\max_{i=1 \cdots n}(∑_{p=0}^{i-1}H_p+H_i +E_i) = ∑_{p=0}^{k-1}H_p+H_k +E_k$$
그러면 $i < j$ 일때 아래 식이 성립하게 된다. 
$$∑_{p=0}^{i-1}H_p+H_i +E_i <= ∑_{p=0}^{j-1}H_p+H_j +E_j$$
$$H_i +E_i <= ∑_{p=0}^{j-1}H_p - ∑_{p=0}^{i-1}H_p+H_j +E_j = ∑_{p=i}^{j-1}H_p+H_j +E_j$$
$$E_i - E_j <= ∑_{p=i}^{j-1}H_p+H_j - H_i = ∑_{p=i+1}^{j}H_p$$
여기서 $E_i - E_j(E_i <= E_j)$는 0 이하이고 $H_p$는 0 이상이기 때문에  위의 식은 성립한다.  

즉 실제 $k$번째 경우가 최대값을 가지는데 위의 방식대로 가면 무조건 $N$번째 경우가 최대값으로 계산된다. 따라서 귀무가설에 의해 처리 시간이 오래걸리는 도시락을 먼저 처리해야 한다. 

## [문자열 합치기](https://algospot.com/judge/problem/read/STRJOIN)

프로그래밍 언어 C 의 큰 문제점 중 하나는 언어 차원에서 문자열 변수형을 지원하지 않는다는 것이다. C 에서는 문자 배열로 문자열을 표현하되 \0 (NULL) 로 문자열의 끝을 지정하는데, 이래서는 문자열의 길이를 쉽게 알 수 있는 방법이 없기 때문에 여러 가지 문제가 발생하게 된다.
```
void strcat(char* dest, const char* src) {
 while(*dest) ++dest; // dest 의 마지막 위치를 찾는다
 while(*src) *(dest++) = *(src++); // src 를 한 글자씩 dest 에 옮겨 붙인다
 *dest = 0; // 문자열의 끝을 알리는 \0 을 추가한다
}
```

이런 문제 중 하나로 문자열을 조작하는 함수들의 동작 시간이 불필요하게 크다. 앞에 주어진 함수 strcat() 은 문자열 dest 뒤에 src 를 붙이는 함수인데, 실행 과정에서 반복문을 두 문자열의 길이를 합한 만큼 수행해야 한다. 이 함수를 사용해 두 개의 문자열을 합치는 비용은 두 문자열의 길이의 합이다.

이 함수를 이용해 $n$개의 문자열을 순서와 상관없이 합쳐서 한 개의 문자열로 만들고 싶습니다. 순서가 상관 없다는 말은 {al,go,spot} 을 spotalgo 로 합치든 alspotgo 로 합치든 상관 없다는 의미이다. 그러나 문자열을 합치는 순서에 따라 전체 비용이 달라질 수 있습니다. 
 예를 들어 먼저 al 과 go 를 합치고 (2+2=4), 이것을 spot 과 합치면 (4+4=8) 총 12 의 비용이 들지만 al 과 spot 을 합치고 (2+4=6) 이것을 다시 go 에 합치면 (6+2=8) 총 14 의 비용이 필요하다.

$n$개의 문자열들의 길이가 주어질 때 필요한 최소 비용을 찾는 프로그램을 작성하자. 

들어온 문자열을 어떤 조합으로 두개씩 계속해서 묶어 나가느냐에 따라 최종 비용의 합이 달라진다. 일단 임의의 두 단어가 합쳐지는데 총 비용은 각 단어의 길이의 합이다. 그리고 이렇게 합쳐진 단어는 언제가 다른 단어와 또 합쳐질텐데 이때 이 단어의 길이가 비용에 재사용되는 구조이다. 추가적으로 한 차례에 두 단어만을 합쳐나간다고 했을때 수행해야할 차례 갯수는 $n-1$개이다. (두 단어가 합쳐지면 한 단어가 남는다.) 하지만 임의의 두 단어를 뽑는 경우의 수는 엄청나게 많다. ($nC_2 \cdot {n-1}C_2 \cdot{n-2}C_2 \cdots$)

직감적으로 현재 남아있는 단어의 수가 작은것 끼리 합쳐 나가면 전체 비용이 최소가 될것 같다는 생각이 든다. 단어의 수가 큰 것끼리 합쳐 나갔을때 전체 비용이 최소가 될것이라는 귀무가설을 세우고 이것이 모순임을 밝혀보자. 임의의 문자열 $i$와 $j$에 대해, $i < j$이면 문자열의 크기는 $n_i > n_j$이다. 

매 차례마다 제일 앞에 있는 문자열이 제일 크기 때문에 각 차례마다 드는 비용은 아례와 같은 규칙을 따른다.$$(n_1) + (n_2)$$$$(n_1 + n_2) + (n_3)$$$$(n_1 + n_2+n_3) + (n_4)$$

즉 총비용의 합은 $(n-1)n_1+(n-2)n_2+ \cdots +n_n$ 이고 $i < j$이면 문자열의 크기는 $n_i > n_j$이기 때문에 총비용 합은 가능한 가장 큰 값이 된다. 따단라서 단어의 수가 큰 것끼리 합쳐 나갔을때 전체 비용이 최소가 될것이라는 귀무가설의 모순을 밝혔다. 따라서 단어의 수가 작은것 끼리 합쳐나가도록 하자.
여기서 주의할 점이 있는데, $n_i + n_{i+1} <= n_{i+2}$가 만족한다면 다음 차례에 그대로 $n_{i+2}$와 더해가면 된다. 하지만 $n_i + n_{i+1} > n_{i+2}$이라면 $n_i + n_{i+1}$를 적절한 자리에 넣고 나 후에 $n_{i+2}$과 $n_{i+3}$를 더해나간다. 
 간단한 예를 들어 [10, 15, 20, 22]의 문자열 길이가 주어졌을때, 먼저 최소 비용은 (10+ 15) + (20 + 22) + (25 + 42) = 50 + 42*2 = 134가 된다. 만약 단순히 계속 더해나가기만 했으면, (10+15) + 25+20 + 45 + 22 = 50 + 65 + 22 = 115+22 = 137이 된다. 이 예제에서 보듯이 




> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjY3ODY5ODU5LDYyNDAwNzUzLDk0MjA0OD
A4OSwtMTA3MzEzMDE0NywtMTIxMzc3NywtNDk4MzEzNzA4LC01
MTkzNTIzMzMsMjEwODM1NzMwOCwxOTEzNjIwMjAyLC0xNjU1Nz
Q4NzU0LDIwNDc4MjczMTcsLTY1NTg2NTM4MSw0MjU5MjgxODIs
LTI2MzUwMzE0MCwxMzU2MDc0Mzg0LDE1MTcwNzk1NiwtMTkwNz
Y3NzIzNiwxNzQzODA0MTA5LDYzNDg1MzM5OCwtMTc3MTc4NjY5
OF19
-->