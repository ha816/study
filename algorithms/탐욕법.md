# 탐욕법(Greedy Method)

탐욕법(Greedy Method)은 가장 직관적인 알고리즘 설계 패러다임 중 하나다. 탐욕법을 이용한 알고리즘, 혹은 탐욕적인 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 조각으로 쪼개고, 각 단계마다 답의 결과를 만들어 간다는 점에서 동적계획법, 완전탐색과 비슷하다. 하지만 탐욕법은 두 방법과 달리, 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다. 

예를 들어, 외판원 문제는 모든 도시들을 하나씩 검사하여 필요한 거리를 최소화하는 경로를 찾는다. 탐욕법은 지금의 선택이 앞으로 남은 선택에 어떤 영향을 미칠지 고려하지 않고 당장 눈앞에 최소 경로를 가지는 도시를 선택한다. 

당연히 이런 간단한 방법으로는 우리가 원하는 정답이 나올리 없다. 탐욕적 알고리즘은 대체로 최적해를 찾지 못한다. 따라서 탐욕법이 사용되는 경우는 크게 두가지로 제한된다. 

1. 탐욕법을 사용해도 최적해를 구할 수 있는 문제인 경우, 탐욕법은 동적계획법보다 수행시간이 훨씬 빠르기 때문에 유용하다.
2. 시간이나 공간적 제약으로 다른 방법으로 최적해를 찾기 너무 어려운 경우, 최적해 대신 적당한 답을 찾는 것으로 타협이 가능하다. 이럴때 탐욕법이 유용하게 사용된다.

탐욕법의 개념은 간단하지만 굉장히 어려운 주제다. 한 문제를 해결하는데 탐욕적으로 해결하는 방법이 한가지만이 아닌 경우도 많고, 어느 방법을 선택해야 최적해를 구하는지 알기가 어렵기 때문이다. 실제로 최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많다. 그러니 탐욕적 알고리즘을 풀때는 정당성 증명과정을 정확히 하는게 좋다. 


## 회의실 예약(ActivitySelectionProblem)

회사에 회의실이 하나밖에 없는데 여러 팀이 하루동안 회의실을 사용한다고 하자. 회의실 사용시간은 08:00에서 18:00까지, 최소 한 시간 단위의 사용이 가능하다. 우리는 다수 팀으로부터 회의실 사용시간표를 받았고 이 중 시간이 서로 겹치지 않는 회의들을 잡아야 한다. 최대 몇개나 선택할 수 있을까?

천천히 생각해보면 서로 시간이 겹치지 않는 회의들의 집합이 모두 이 문제의 답이다. 그리고 이 중에서 가장 좋은 답, 곧 최적해는 집합의 크기가 가장 큰 부분 집합이다.  

가장 간단히 접근법은 $n$개의 팀에 대한 가능한 모든 부분집합을 만들고 그 중 시간이 겹치치 않는 팀 조합을 만들어보고 크기가 가장 큰 부분집합을 찾는것이다. 그러나 확인해야할 부분집합의 수는 $2^n$이기 때문에 복잡도가 너무 높다. 

탐욕적 방법으로 이 문제를 푸는 방법은 다양하다. 먼저 길이가 짧은 회의부터 하나하나 순회하면서 앞의 것들과 겹치지 않는 것들을 추가하는 방법을 생각해보자. 이 방법은 회의실을 사용하는 시간을 최대화 하려고 노력하기 때문에 그럴싸해보인다. 하지만 긴 회의를 두개를 연달아 개최하는 경우 최적값을 찾지 못한다. 이렇듯 탐욕법에서는 그럴듯하다고 해서 정답을 찾는 것이 아니다. 그래서 어렵다. 

정답을 말하자면 **회의 시간 길이와 상관없이 가장 먼저 끝나는 회의를 선택하는 것이다.** 가장 먼저 끝나는 회의를 선택하고, 이 회의와 겹치는 것들을 모두 지운뒤 다시 이중에서 가장 먼저 끝나는 회의를 선택하는 것을 반복하는 것이다. 

1. 주어진 목록 $S$에 남은 회의 중 가장 일찍 끝나는 회의 $S_{min}$을 선택한다.
2. $S_{min}$과 겹치는 회의를 $S$에서 모두 지운다.
3. $S$가 텅빌때 까지 반복한다. 

[테스트 데이터](https://ratsgo.github.io/data%20structure&algorithm/2017/11/22/greedy/)


## 정당성 증명: 탐욕적 선택속성(greedy choice property)

알고리즘의 정당성 증명은 대다수가 일정한 패턴을 가진다. 이 증명패턴은 탐욕적 알고리즘이 항상 최적해를 찾는다는 것을 두 가지 속성을 증명함으로써 밝힌다. 이 두가지 속성은 탐욕적 선택속성(greedy choice property)과 최적부분구조(optimal substructure)이다.

탐욕법에서 탐욕적 선택속성(greedy choice property)은 매우 중요하기 한데 동적계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로 선택하더라도 최적해를 구할 수 있기 때문이다. 즉 어떤 알고리즘이 이 속성을 만족할 경우, 우리는 각 단계에서 탐욕적인 선택을 해서 손해를 볼일이 없다는 것을 알 수 있다. 

앞서 회의 시간 길이와 상관없이 가장 먼저 끝나는 회의를 선택하는 것은 사실 탐욕적 선택속성이 성립하고 다르게 표현하자면 아래와 같이 이야기 할 수 있다. 

> 가장 종료시간이 빠른 회의($S_{min}$)를 포함하는 최적해가 반드시 존재한다. 

만약 $S$의 최적해 중에서 $S_{min}$을 포함하지 않는 답이 있다고 하자. 이 답은 서로 겹치치 않는 회의의 목록이라는 가정하에 있는데, 이 목록에서 첫 번째로 개최되는 회의를 지우고 $S_{min}$을 대신 추가해서 새로운 목록을 만들자. $S_{min}$은 $S$에서 가장 일찍 끝나는 회의이기 때문에 지워진 회의는 $S_{min}$보다 일찍 끝날 수가 없다. 따라서 두번째 회의와 $S_{min}$이 겹치는 일은 없으며, 새로 만든 목록도 최적해중 하나가 된다. 따라서 항상 $S_{min}$을 포함하는 최적해는 존재한다. 

우리는 위 증명을 통해서 가장 일찍 끝나는 회의를 선택하면 언제나 최적해를 얻는 것을 밝혔다. 하지만 탐욕적 방법이 답을 줄 수 있다고 해서 증명이 끝난 것이 아니다. 항상 탐욕적 선택해도 전체 문제의 최적해를 얻을 수 있음을 보여야 한다. 다행이 이 속성은 대개 매우 자명해서 따로 증명할 필요가 없는 경우가 많다.



## [출전순서 정하기](https://algospot.com/judge/problem/read/MATCHORDER)

알고스팟 컵의 결승전이 다가왔다. 각 팀은 n명씩의 프로 코더들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전해 1:1 경기를 벌여 더 많은 승리를 가져가는 팀이 최종적으로 우승하게 된다. 

한국팀의 유감독은 첩보를 통해 상대 러시아팀의 출전 순서를 알아냈다. 이 대회에서는 각 선수의 실력을 레이팅(rating)으로 표현한다. 문제를 간단히 하기 위해 1:1 승부에서는 항상 레이팅이 더 높은 선수가 승리하고, 레이팅이 같을 경우 우리 선수가 승리한다고 가정하자.

|경기|1|2|3|4|5|6|
|--|--|--|--|--|--|--|
|러시아팀|3000|2700|2800|2200|2500|1900|
|한국팀|2800|2750|2995|1800|2600|2000|

표와 같이 출전 순서를 정했다고 하면 한국팀은 2번, 3번, 5번, 6번 경기에서 승리해 전체 네 경기를 이기게 된다. 그러나 대신 4번 경기와 1번 경기에 나갈 선수를 바꾸면 1번 경기만을 제외하고 모든 경기에 승리할 수 있다. 상대방 팀 선수들의 순서를 알고 있을 때, 어느 순서대로 선수들을 내보내야 승수를 최대화할 수 있을까? 최대승수를 계산하는 프로그램을 짜보자.

가장 간단한 방법은 모든 가능한 순서에 대해서 승수를 계산해서 그중에 가장 큰 승수를 반환하면 된다. 그러나 따져보아야 하는 순서가 모두 $n!$개 이기 때문에 복잡도가 너무 높다. 

상대의 선수들의 출현 순서와 레이팅 점수를 알고 있기 때문에, 상대 선수들의 레이팅 점수로 정렬하고 정렬된 리스트를 $A$라 하자. 반대로 우리팀 선수들의 레이팅 점수로 정렬된 리스트를 $B$라고 하자.

상대팀 중 레이팅 점수가 $x$번째로 높은 선수에 대해서, 그 선수의 레이팅 점수인 $a_x$과 같거나 큰 레이팅 점수를 가지는 우리팀 선수가 존재하면 그 선수를 이길 수 있다. $a_x$과 같거나 큰 점수를 가지는 $B$의 부분집합을 $B_{a_x}$라 하자. 그러면 성질 $\forall b \in B_{a_x}, b >= a_x$를 만족한다. 

상대팀의 $x+1$번째 높은 선수에 대해서, 정의대로 우리팀$B_{a_x+1}$에 선수들은 모두 상대팀의 $x+1$ 번째 선수를 이길 수 있다. 그런데 $B_{a_x+1}$는 $B_{a_x}$와 $\min B_{a_x}$ 보단 작지만  $a_{x+1}$ 보단 큰 레이팅 점수를 가지는 $B$의 선수들로 이루어진다.

자 정리를 하자면 상대팀 $x$번째 선수에 대해서, 이길수 있는 $B_{a_x}$를 구하고, 존재하면 이번 선수를 이길 수 있다는 것이다. 
자 그러면 이번 선수를 무조건 이기는 것이 최대승수를 얻을수 있을까 아니면 전략적으로 일부러 지는 것이 최대 승수를 얻을 수 있을까? 
정답은 무조건 이기는 것이 최대승수를 얻을 수 있다. 그리고 우리가 구할 수 있는 최대 승수는 정해져있다. 상대팀 가장 마지막 선수에 대해서 $B_{a_n}$은 $a_n$보다 같거나 큰 값으로 이루어지는데, $a_{n-1} >= a_{n}$이고 


전략적으로 이번 $x$번째 선수에게 일부러 진다는 것은 승수를 하나 버리고 나중 판에 승수를 반드시 하나 얻겠다는 이야기다. 그런데 이 방법으로 이득을 얻으려면 지금 패를 택하는 것이 결과적으로 2개이상의 승수를 가져와야 한다는 것이다. 다음 차례에서 



 그런데 지금처럼 정렬되 되어 있는 상태라면 얻을 수 있는 최대 승수는 결국 최대한 패를 택해서 이제 무조건 이기는 선수밖에 남지 않게 된다. 

100 50 25 10 5 
150 40 30 5 1

최대 4승




  
//위와 방식으로 하면 정말로 최대 승수를 얻을 수 있을가??  
  
// 우리가 알고 싶은 최대 승수 optimal의 경우는 어떻게 정의해야하지?  
  
// 패를 가지고 있는데 패를 조금식 버려가면서 게임을 진행한다.  
// 현재 내가 가지고 있는 패가 상대 패를 이길 수 있는데 일부러 지는경우라면 언제 나올지 모르는 상대의 강한 카드를 이기기 위함이다.  
// 즉 현재 내가 일부러 진다면 나중에 승리를 하기 위함인데... 설령 나중에 한건의 승리를 더 얻을지라도, 결과적으로 승수에는 차이가 없다.



## [도시락 데우기](https://algospot.com/judge/problem/read/LUNCHBOX)

## [문자열 합치기](https://algospot.com/judge/problem/read/STRJOIN)







> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTA4Nzc5MjE0MCwtMTc4NjIyMjMyLC05Nj
I0NDY0NDksLTEyMDkyNzU3MDksLTk4ODIxODQwNSwtMTA4MjUx
ODQ2NCwxNDAwOTEwNzY5LDE5OTk0NzgxNzAsLTE2NzI0OTI0Nz
UsOTA1NTU4MDY1LDg4MzI0MTY3NSw5OTc2MzA1MDUsLTEyODIy
NTU2MjEsLTE1MjI2NDc1MjEsNTU4Njg1NTMyLC0zNzkyNDAyMT
AsLTIxODQ5ODg4OCwtMTQ4MDY2NDY2NSwtMTQwNzE5NTI2Niwx
ODIyNDE4OTI0XX0=
-->