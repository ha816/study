#  동적 계획법(Dynamic Programming)

동적 계획법은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임이다. 이름만 가지고는 무엇을 의미하는지 영 알기가 어렵기 때문에 많은 오해를 불러일으키는 주제이기도 한다.

동적 계획법이란 말은 최적화 무제를 연구하는 수학 이론에서 왔으며, 우리가 전삭한 전반에서 일반적으로 사용하는 동적, 혹은 프로그래밍이라는 단어와는 아무 관련이 없다. 

동적 계획법의 고안자 벨만은 dynamic이라는 단어가 멋있어서 선택했다고 한다. Programming이란 말은 최적화 연구분야에서 최적의 프로그램을 찾아낸다는 의미로 사용된다.

동적 계획법은 사용하는 알고리즘들 은 처음에 주어진 문제를 더 작은 문제들로 나눈뒤 각 부분의 답을 계산후, 이 답들로 부터 원래 문제에 대한 답을 계산해 낸다.

이러한 형태는 사실 큰 의미에서 분할 정복 방법과 비슷하다. 두 패러다임의 차이는 문제를 나누는 방식에서 있다.  동적계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용 될수 있기 때문에, 문제의 답을 여러번 계산하는 대신 한번만 계산하고 그 계산결과를 재활용함으로써 속도의 향상을 꾀할 수 있다. 

그러기 위해서는 각 문제의 답을 저장해 둘 필요가 있으며, 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시라고 부른다. 또 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblmes)라고 부른다. 

결과를 저장하는 장소를 마련해두고, 계산한 값을 저장해둿다 재활용하는 최적화 기법을 [메모이제이션(memoization)](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)이라고 한다. 메모라이제이션이라고 잘못 사용하는 경우가 많은데 메모이 제이션이 옳은 표현이다 . 

본 장에서 다루게 될 동적 계획법을 활용한 알고리즘은 순서대로 아래와 같다.

최적 부분 구조 : 이항계수계산, 외발뛰기, 삼각형위의 최대경로, 최대증가 부분수열(LIS; longest Increasing Subsequence), 원주율 외우기, 양자화(Quantization), 
한주에 3개씩 하기 

경우의수 이용 : 삼각형 위의 최대 경로 개수 세기, 두니발 박사의 탈옥

외판원 문제 : TSP

## [이항계수계산](https://ko.wikipedia.org/wiki/%EC%9D%B4%ED%95%AD_%EA%B3%84%EC%88%98)(binomial coefficient)

이항 계수는 n개의 서로 다른 원소중에서 r개의 원소를 순서 없이 뽑는 문제이다. 사실 가능한 조합의 갯수를 계산하는 것.

${n}\choose{r}$ = ${n-1}\choose{r-1}$ +${n-1}\choose{r}$

이 식을 재귀적 호출로 간단하게 구현하면 아래와 같다. 이때 주목할 점은 이항계수의 특성상 같은 값을 두 번 이상 계산할 일이 빈번하다는 점이다. 

``` 
int binomial(int n, int r) {재귀호출을 이용한 이항 계수의 계산
	if(n == r || r==0){
		return 1;
	} // base 모든 원소를 다 고른 경우 또는 고를 원소가 없는 경우
	return binomial(n-1, r-1) + binomial(n-1, r)
}
```
![](http://andromeda-express.com/dp/figures/binomial_call_tree.dot.png)

위의 그림은 bino(4,2)를 계산하는 과정을 나타낸 그림이다. 여기서 중요한 점은 bion(2,1)이 두번 호출된다는 점이다. 

bino(2,1)은 bino(3,1)과 bino(3,2)를 위해서 필요하다. 게다가 bino(2,1)은 bino(1,0)과 bino(1,1)을 호출하기 때문에 같은 계산을 두번이나 하게 된다. 

함수의 중복 호출 수는 n과 r이 커짐에 따라 기하 급수적으로 증가한다.  아래 그림을 보면, bino(8,4)를 계산하기 위해서 bino(1,0)과 bino(1,1)를 반복적으로 호출하는 것을 볼 수가 있다.

일반화 해서 더 많은 n에 대해서 호출의 수를 계산해보자면, 
$bino(n, \frac{n}{2})$을 계산하기 위해서, 아래와 같이 n이 증가할때마다 거의 두배 가까이 증가하는 것을 볼수 있다. 

|n| 2 | 3  |  4| 5|6 | ... | 18| ...  | 25|
|--|--|--|--|--|--|--|--|--|--|
|호출 횟수| 3|5 | 11 |19|39|...|97239|...|10400599

### 메모이제이션 전략

![](http://andromeda-express.com/dp/figures/binomial_call_tree3.dot.png)

## [외발뛰기](https://algospot.com/judge/problem/read/JUMPGAME)

외발뛰기 문제는 $n * n$ 크기의 격자에 1부터 9까지 정수를 쓴 게임판이 주어진다. 게임의 목적은 게임판의 왼쪽 위칸에서 시작해서 게임판 맨 오른쪽 아래에 도착하는 것이다. 이때 각 칸에 적혀있는 숫자만큼 아래쪽이나 오른쪽으로 이동할 수 있으며, 중간에 게임판 밖으로 벗어나면 안된다. 

문제의  답은 게임판이 주어질때 시작점에서 끝점으로 도달하는 방법이 있는지 없는지 확인하는 것이다. 즉 판별문제라고 보면 된다.  예를 들어 b 게임판에서는 끝에 도달할 수 있는 방법이 없다고 이야기할 수 있다. 

![](https://mblogthumb-phinf.pstatic.net/20160617_21/oncoder-hs_1466144620717O5LA9_PNG/11111.png?type=w2)

### 메모이제이션 적용하기

여기서 주목할 점은 완전 탐색이 만드는 경로의 수는 엄청 많지만 jump()에 주어진 입력 갯수는 $100*100= 10000$개 뿐이라는 점이다. 
즉 재귀적인 계산과정에서 같은 인풋을 가진 jump()함수를 여러번 호출한다. 여기에 메모이제이션을 적용하면 어느 단계에서 계산된 캐시를 이용해서 계산량을 줄일 수 있다.

## [삼각형 위의 최대경로](https://algospot.com/judge/problem/read/TRIANGLEPATH)

아래와 같이 삼각형 모양으로 배치된 자연수들이 있다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 한다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있다. 이 때 모든 경로 중 포함된 숫자의 합의 최대값을 찾고 최대값의 경로도 보여라.

```
6
1  2
3  7  4
9  4  1  7
2  7  5  9  4
```

### 완전 탐색 시작
책에서는 pathSum(y,x, sum) 이라고 표현했다. y,x 는 현재의 좌표 (y,x)를 나타내고 지금까지 만난 수의 합을 sum이라고 표현했다. 이 경로를 맨 아래줄 까지 연장해서 얻을 수 있는 최대 합을 반환한다. 

이때 아래쪽으로 가거나 오른쪽으로 내려갔을때 최대의 합긊 각각 pathSum을 사용하여 표현 하면 아래와 같은 점화식을 얻을 수 있다. 

$$pathSum(y,x) = max$$

### 메모이제이션 적용
이 문제에서 가능한 경로의 개수는 삼각형의 가로줄이 하나 늘어날때마다 두배씩 늘어난다.  즉 n개의 가로줄이 있을때 가능한 경로의 수는 $2^n-1$이 된다. 

점화식을 보면 세개의 pathSum(y,x, sum) 파라미터를 받아 처리를 하는데 이 파라미터를 두 부류로 나누면 아래와 같다. 

* x,y는 재귀 호출시 풀어야할 부분 문제를 지정한다. 입력이 정해지면 앞으로 풀러야할 경로가 정해진다. 즉 앞으로 어떤 부분 문제를 추가로 풀어야 하는지 정보를 알려준다. 
* sum은 지금까지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다. 지금까지 풀었던 문제들에 대한 정보다. 

여기서 중요한 점은 과연 sum이 앞으로 남은 조각을 계산하는데 필요한지 생각해보아야 한다. 임의의 x,y에서 내려가는 최대 경로는 sum이 얼마건 상관 없이 똑같다. 

단 재귀함수에서 sum을 입력 받지 않으면, 이전까지 어떤 숫자를 만났는지 알수가 없기 때문에 경로의 최대합을 반환 할수가 없다. 따라서 함수의 반환값을 전체 경로의 최대치가 아니라 y,x로 시작하는 부분 경로의 최대치로 바꿀 필요가 있다. 

재정의를 하면 path2(y,x)는 (y,x)에서 시작해서 맨 아랫줄로 내려가는 부분 경로의 최대합을 반환한다. 

그에 따른 점화식은 아래와 같다. 

$path2(y,x) = triangle[y][x] + max{path2(y+1, x)}$

### 최적 부분구조

위에 최적화 하는 과정에서 우리는 sum이 앞으로 남은 조각을 계산하는데 필요한지 생각해보았다. 최적화 할 수 있었던 이유는 sum이라는 정보가 (y, x)에서 맨 아래줄 까지 내려가는 문제를 해결하는데 아무상관이 없다는 사실 때문이다. 다시 말해 지금까지 어떤 경로로 부분 문제에 도착했건 남은 부분 문제는 상관이 없다는 것이다. 이 조건이 효율적인 동적 프로그램을 적용하기 위해 아주 중요한 조건이다. 얼마나 중요할 정도냐면, 최적 부분구조(optimal substrucutre)라는 유식한 이름을 붙여서 이야기를 한다. 

최적 부분 구조는 어떤 문제와 분할 방식에 성립하는 조건이다. 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어 낼수 있는 경우, 이 조건이 성립한다.

반면 더 부분문제의 최적해만으로 전체문제의 최적해를 구할수 없다면 그 문제는 최적 부분 구조가 존재하지 않는다고 한다. 

## [최대증가부분수열](https://algospot.com/judge/problem/read/LIS)(LIS; longest Increasing Subsequence)



정수 수열 S의 부분 수열이란 S에서 0개 이상의 숫자를 지우고 남은 수열을 말한다. 



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjk0NjQ5OTA4LDM3NTk0MTY1LDE1ODY4OD
M2MTcsLTE5MDUwODIzNzQsLTE2ODU1Nzc5OTIsLTE0MzY2MTQx
NjcsLTIwMjM2NDg0NDMsLTU2ODIxNDk4NCwtMTg0NjI4MDgzOC
wxNjU5MjI4OTI2LDE0MzQ5NjQ0NTIsLTEyOTY0NTMzOTMsLTEw
MzgyNTg1OTEsMjA1NjkyMjQwOSwtMjExMTAzNDEyMiwtNDk0OD
A2NzMxXX0=
-->