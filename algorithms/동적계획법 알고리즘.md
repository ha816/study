#  동적 계획법(Dynamic Programming)

동적 계획법은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임이다. 이름만 가지고는 무엇을 의미하는지 영 알기가 어렵기 때문에 많은 오해를 불러일으키는 주제이기도 한다.

동적 계획법이란 말은 최적화 무제를 연구하는 수학 이론에서 왔으며, 우리가 전삭한 전반에서 일반적으로 사용하는 동적, 혹은 프로그래밍이라는 단어와는 아무 관련이 없다. 

동적 계획법의 고안자 벨만은 dynamic이라는 단어가 멋있어서 선택했다고 한다. Programming이란 말은 최적화 연구분야에서 최적의 프로그램을 찾아낸다는 의미로 사용된다.

동적 계획법은 사용하는 알고리즘들 은 처음에 주어진 문제를 더 작은 문제들로 나눈뒤 각 부분의 답을 계산후, 이 답들로 부터 원래 문제에 대한 답을 계산해 낸다.

이러한 형태는 사실 큰 의미에서 분할 정복 방법과 비슷하다. 두 패러다임의 차이는 문제를 나누는 방식에서 있다.  동적계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용 될수 있기 때문에, 문제의 답을 여러번 계산하는 대신 한번만 계산하고 그 계산결과를 재활용함으로써 속도의 향상을 꾀할 수 있다. 

그러기 위해서는 각 문제의 답을 저장해 둘 필요가 있으며, 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시라고 부른다. 또 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblmes)라고 부른다. 

결과를 저장하는 장소를 마련해두고, 계산한 값을 저장해둿다 재활용하는 최적화 기법을 [메모이제이션(memoization)](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)이라고 한다. 메모라이제이션이라고 잘못 사용하는 경우가 많은데 메모이 제이션이 옳은 표현이다 . 

본 장에서 다루게 될 동적 계획법을 활용한 알고리즘은 순서대로 아래와 같다.

최적 부분 구조 : 이항계수계산, 외발뛰기, 삼각형위의 최대경로, 최대증가 부분수열(LIS; Longest Increasing Subsequence), 합친 부분수열(JLIS; Joined Longest Increasing Subsequence), 원주율 외우기, 양자화(Quantization) 
경우의수 이용 : 삼각형 위의 최대 경로 개수 세기, 두니발 박사의 탈옥

외판원 문제 : TSP

## [이항계수계산](https://ko.wikipedia.org/wiki/%EC%9D%B4%ED%95%AD_%EA%B3%84%EC%88%98)(binomial coefficient)

이항 계수는 n개의 서로 다른 원소중에서 r개의 원소를 순서 없이 뽑는 문제이다. 사실 가능한 조합의 갯수를 계산하는 것.

${n}\choose{r}$ = ${n-1}\choose{r-1}$ +${n-1}\choose{r}$

이 식을 재귀적 호출로 간단하게 구현하면 아래와 같다. 이때 주목할 점은 이항계수의 특성상 같은 값을 두 번 이상 계산할 일이 빈번하다는 점이다. 

``` 
int binomial(int n, int r) {재귀호출을 이용한 이항 계수의 계산
	if(n == r || r==0){
		return 1;
	} // base 모든 원소를 다 고른 경우 또는 고를 원소가 없는 경우
	return binomial(n-1, r-1) + binomial(n-1, r)
}
```
![](http://andromeda-express.com/dp/figures/binomial_call_tree.dot.png)

위의 그림은 bino(4,2)를 계산하는 과정을 나타낸 그림이다. 여기서 중요한 점은 bion(2,1)이 두번 호출된다는 점이다. 

bino(2,1)은 bino(3,1)과 bino(3,2)를 위해서 필요하다. 게다가 bino(2,1)은 bino(1,0)과 bino(1,1)을 호출하기 때문에 같은 계산을 두번이나 하게 된다. 

함수의 중복 호출 수는 n과 r이 커짐에 따라 기하 급수적으로 증가한다.  아래 그림을 보면, bino(8,4)를 계산하기 위해서 bino(1,0)과 bino(1,1)를 반복적으로 호출하는 것을 볼 수가 있다.

일반화 해서 더 많은 n에 대해서 호출의 수를 계산해보자면, 
$bino(n, \frac{n}{2})$을 계산하기 위해서, 아래와 같이 n이 증가할때마다 거의 두배 가까이 증가하는 것을 볼수 있다. 

|n| 2 | 3  |  4| 5|6 | ... | 18| ...  | 25|
|--|--|--|--|--|--|--|--|--|--|
|호출 횟수| 3|5 | 11 |19|39|...|97239|...|10400599

### 메모이제이션 전략

![](http://andromeda-express.com/dp/figures/binomial_call_tree3.dot.png)

## [외발뛰기](https://algospot.com/judge/problem/read/JUMPGAME)

외발뛰기 문제는 $n * n$ 크기의 격자에 1부터 9까지 정수를 쓴 게임판이 주어진다. 게임의 목적은 게임판의 왼쪽 위칸에서 시작해서 게임판 맨 오른쪽 아래에 도착하는 것이다. 이때 각 칸에 적혀있는 숫자만큼 아래쪽이나 오른쪽으로 이동할 수 있으며, 중간에 게임판 밖으로 벗어나면 안된다. 

문제의  답은 게임판이 주어질때 시작점에서 끝점으로 도달하는 방법이 있는지 없는지 확인하는 것이다. 즉 판별문제라고 보면 된다.  예를 들어 b 게임판에서는 끝에 도달할 수 있는 방법이 없다고 이야기할 수 있다. 

![](https://mblogthumb-phinf.pstatic.net/20160617_21/oncoder-hs_1466144620717O5LA9_PNG/11111.png?type=w2)

### 메모이제이션 적용하기

여기서 주목할 점은 완전 탐색이 만드는 경로의 수는 엄청 많지만 jump()에 주어진 입력 갯수는 $100*100= 10000$개 뿐이라는 점이다. 
즉 재귀적인 계산과정에서 같은 인풋을 가진 jump()함수를 여러번 호출한다. 여기에 메모이제이션을 적용하면 어느 단계에서 계산된 캐시를 이용해서 계산량을 줄일 수 있다.

## [삼각형 위의 최대경로](https://algospot.com/judge/problem/read/TRIANGLEPATH)

아래와 같이 삼각형 모양으로 배치된 자연수들이 있다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 한다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있다. 이 때 모든 경로 중 포함된 숫자의 합의 최대값을 찾고 최대값의 경로도 보여라.

```
6
1  2
3  7  4
9  4  1  7
2  7  5  9  4
```

### 완전 탐색 시작
함수명을 $pathSum(x, y, sum)$이라고 하자. 책에서는 $pathSum(y, x, sum)$라고 표현했다. 앞에 두 인자는 현재의 위치 (x,y)를 나타내고 지금까지 만난 수의 합을 sum로 나타낸다. 결국 경로를 내려가면서 경로에 있는 값을 아래줄까지 더해 얻을 수 있는 최대 합을 반환한다. 이때 아래쪽으로 가거나 오른쪽으로 내려가는 과정을 위 함수로 표현 하면 아래와 같은 점화식을 얻을 수 있다. 
$$pathSum(x,y, sum) = max \begin{cases} pathSum(x,y+1, sum+cost(x,y)) \\
pathSum(x+1, y+1, sum+cost(x,y)) \end{cases}$$

### 메모이제이션 적용
이 문제에서 가능한 경로의 개수는 삼각형의 가로줄이 하나 늘어날때마다 두 배씩 늘어난다.  즉 n개의 가로줄이 있을때 가능한 경로의 수는 $2^n-1$이 된다. 

위 점화식에선 세 개의 파라미터를 받아 처리를 하는데 이 파라미터를 두 부류로 나누면 아래와 같다. 

* x,y는 재귀 호출시 풀어야할 부분 문제를 지정한다. 입력이 정해지면 앞으로 풀러야할 경로가 정해진다. 즉 앞으로 어떤 부분 문제를 추가로 풀어야 하는지 정보를 알려준다. 
* sum은 지금까지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다. 지금까지 풀었던 문제들에 대한 정보다. 

여기서 중요한 점은 과연 sum이 앞으로 남은 조각을 계산하는데 필요한지 생각해보아야 한다. 임의의 x,y에서 내려가는 최대 경로는 sum이 얼마건 상관 없이 똑같다. 

단 재귀함수에서 sum을 입력 받지 않으면, 이전까지 어떤 숫자를 만났는지 알수가 없기 때문에 경로의 최대합을 반환 할수가 없다. 따라서 함수의 반환값을 전체 경로의 최대치가 아니라 y,x로 시작하는 부분 경로의 최대치로 바꿀 필요가 있다. 

위 아이디어롤 토대로 점화식을 새로 정의해보자. pathSum2(x,y)는 과거 경로를 고려하지 않고 (x,y) 좌표에서 시작해서 맨 아랫줄로 내려가는 부분 경로의 최대합을 반환한다. 

$$pathSum2(x,y) = cost(x,y) + max \begin{cases} pathSum2(x,y+1) \\
pathSum2(x+1, y+1) \end{cases}$$

### 최적 부분구조(optimal substructure)

우리는 파라미터 sum이 앞으로 남은 조각을 계산하는데 필요한지 생각해보았다. 최적화 할 수 있었던 이유는 sum이라는 정보가 (y, x)에서 맨 아래줄 까지 내려가는 문제를 해결하는데 아무상관이 없다는 사실 때문이다. 다시 말해 지금까지 어떤 경로로 부분 문제에 도착했건 남은 부분 문제는 상관이 없다는 것이다. 이 조건이 효율적인 동적 프로그램을 적용하기 위해 아주 중요한 조건이다. 얼마나 중요할 정도냐면, 최적 부분구조(optimal substructure)라는 유식한 이름을 붙여서 이야기를 한다. 

최적 부분 구조는 어떤 문제와 분할 방식에 성립하는 조건이다. 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어 낼수 있는 경우, 이 조건이 성립한다.

반면 더 부분문제의 최적해만으로 전체문제의 최적해를 구할수 없다면 그 문제는 최적 부분 구조가 존재하지 않는다고 한다. 

## [최대증가부분수열](https://algospot.com/judge/problem/read/LIS)(LIS; Longest Increasing Subsequence)

먼저 수열(sequence)이란 정수를 원소로 가지는 리스트를 말한다. 길이가 $n$인 수열의 부분수열(subsequence)은 0개 이상의 숫자를 지운 수열을 말한다. 따라서 길이가 $n$인 수열의 경우, 모든 부분수열의 갯수는 $2^n$이다. 예를 들어 `10 7 4 9` 의 부분 수열에는 `7 4 9`, `10 4`, `10 9` 등이 있다. 단, `10 4 7` 은 원래 수열 순서와 다르므로 `10 7 4 9` 의 부분 수열이 아니다. 즉 부분 수열은 원래 수열의 순서를 지켜야 한다. 

다음으로 증가부분수열이란 부분수열에 포함된 숫자들이 증가하는 (increasing) 추세면 증가부분수열(increasing subsequence)이라고 한다. 인접한 숫자가 같은 경우가 없다면 순 증가(strictly increasing)한다고 세분화 할 수 있다.

* 순 증가(strictly increasing)
	* 수열에서 두 인접한 숫자 중 앞의 것이 항상 더 작다.
* 단조 증가(monotonically increasing)
	* 수열에서 두 인접한 숫자가 같거나 작다.

결국 최대증가부분수열 문제는 하나의 수열이 주어졌을때 얻을수 있는 증가부분수열 중 길이가 길고 단조증가하는 수열을 찾는 것이다.

```
1 2 3 4 
5 4 3 2 1 6 7 8 
5 6 7 8 1 2 3 4
```

### 완전탐색

최대증가부분수열을 구하는 함수는 수열을 입력 받아 길이가 가장 긴 LIS(Longest Increasing Subsequence)를 반환하는 재귀함수다. 가장 간단한 전략은 $2^n$개의 부분수열을 모두 구하고 하나씩 가장 길면서 증가하는 부분수열을 찾으면 된다. 너무 계산량이 많으니 다른 전략을 생각해야 한다. 

수열에서 임의의 한 원소를 제일 앞에 두고있는 LIS의 두번째 수부터는 첫번째 수 보다 항상 같거나 큰 수를 가져야 한다. 예를 들어 $5, 1, 10, 7, 13$이 있다면 5를 가장 앞에 가지는 LIS는 두번째 부터는 5이상인 수만으로 구성된다는 이야기다. 
이 전략을 사용한다면 실제 구현은 아래와 같다. 
먼저, 입력된 수열에 수를 앞에서 부터 하나씩 기준으로 삼는다. 
기준이 된 수를 제일 앞에 포함하는 LIS을 찾기 위해 기준 수보다 같거나 큰 숫자들로만 이루어진 부분 수열들을 만든다. 마지막으로, 다음 재귀함수에 만들어진 부분수열을 넣고 계산을 반복한다. 

```
getLIS(sequence){
	candidateLIS = {};
	for(int index=0; index < sequence.lenth; index++)		
		IS = getIncreasingSubsequence(index+1)
		candidateLIS.add(getLIS(IS));
	}
	filterCandidateLIS()
	//filter IS which has lowerlenth than longestlenth
}
```
위 전략을 사용면서 메모이제이션을 사용하면 최대시간복잡도는 $O(n^2)$이다. 왜냐하면, 중복을 제외하면 함수 호출시 가능한 수열은 $n$가지가 되고 수열마다 증가부분수열을 구하기위해  $n$번의 추가 연산이 필요하기 때문이다. 또한 특정 수열에 대한 LIS를 계산하기 위해 과거에 연산을 알 필요가 없다는 점에서 최적 부분 구조가 여기서도 성립한다. 

### 더 빠른 방법

보다 전략적인 다른 방법을 이용하면 $O(n log n)$만에 LIS의 길이를 찾는 것이 가능하다. 주의할 점은 LIS 수열 자체가 아니라 최대 길이를 계산할 수 있다는 점이다 주의하도록 하자.

 이 방법은 정렬된 리스트 L에 원소를 추가 또는 교체하면서 진행한다. 주어진 입력 수열의 원소들을 앞에서부터 순회하는데 특정 순회 차례의 원소를 t(target)이라고 하겠다. 이때 추가 또는 교체하는 조건은 아래와 같다. 

1. 추가(Adding) 
	* 리스트가 비어있거나, 현재 리스트의 마지막 원소보다 t가 클 경우, 리스트에 t를 추가한다. 
2. 교체(Replacing)
	* 추가 조건이 아니라면 리스트에서 t의 LowerBound를 찾아 t로 교체한다.
	 
>LowerBound
>정렬된 리스트(L)에 어떤 입력값(t)을 삽입하려고 하는데 삽입 후에도 정렬된 상태를 유지하고자 한다. 이 때 **삽입 가능한 위치 중에 가장 작은 값**을 리스트(L)에서 입력값(t)에 대한 LowerBound라고 한다. 
 
[1, 3, 3, 6, 7] 이라는 배열에서 5의 LowerBound는 3, 3의 LowerBound는 1, 1의 LowerBound는 0이다. 
LowerBound를 찾는 연산은 최악의 경우 $O (log n)$ 이다.

자, 그러면 제안한 전략대로 하면 정말 LIS에 해당하는 길이를 계산할 수 있을까?
먼저 추가의 경우, 지금까지 정렬된 수열보다 큰 수를 찾은 것을 뜻하며 추가해도 LIS 조건에 부합하기때문에 문제가 없다. 
교체의 경우, 수열에 가장 큰 수보다 작은 수가 기존 수열의 한 수를 교체한다는 것을 말한다. LowerBound에 있는 수를 교체하기 때문에 교체 후에도 정렬 상태를 유지하며 작은수로 큰값을 교체하거나 같은 값을 그대로 유지한다.

결과로 반환되는 수열은 지금까지 입력 수를 더하거나 교체하면서 만들어졌는데 극닥적으로 교체만 일어났다면, 언제나 

1 5 10 15 20, 0 


수열에 있는 $n$개의 수 마다 LowerBound를 계산할 수 있기 때문에 최악의 경우 시간복잡도는 $O(n log n)$이다.

초기의 빈 리스트 L은 정렬되어 있다고 볼 수 있고, 위의 과정으로만 리스트를 변형하면 다음 호출시 정렬된 상태가 깨지지 않는다. 계속해서 LowerBound를 찾는데 이진 탐색을 사용할 수 있다. 

## [합친최대부분수열](https://algospot.com/judge/problem/read/JLIS)(JLIS; Joined longest Increasing Subsequence)

두 개의 정수 수열 A 와 B 에서 각각 **증가 부분 수열**을 얻은 뒤 이들을 크기 순서대로 합친 것을 **합친 증가 부분 수열**이라고 부른다. 이 중 가장 긴 수열을 **합친 LIS**(JLIS, Joined Longest Increasing Subsequence)이라고 한다.
예를 들어, [1,9,4] 와 [3, 4, 7]의 JLIS는 [1,3,4,7,9]가 된다. 

사실 위의 문제는 앞에서 본 LIS 문제의 확장판이다. 본질적으로 LIS와 다르지 않다. LIS에서 다룬 더 빠른방법을 이용해서 풀면 된다. 

## [원주율 외우기](https://algospot.com/judge/problem/read/PI)

원주율을 몇만 자리까지 외우는 신동들이 존재한다. 이들이 이 수를 외우기 위해 사용하는 방법 중 하나는 숫자를 몇자리씩 끊어서 외우는 것이다. 숫자 3~ 5자리로 끊어서 외우는데, 외우기 쉬운 조각들로 외운다. 조각들의 난이도는 아래와 같다.

|경우|예|난이도|
|--|--|--|
|모든숫자가 같을때|333,5555| 1|
|숫자가 1씩 단조증가 또는 감소할때|23456, 3210|2|
|두 개의 숫자가 번갈아가며 나타날때|323, 54545|4|
|숫자가 등차수열을 이룰때|147, 8642|5|
|이외의 모든 경우|17912, 331|10|

원주율의 일부가 입력으로 주어질때, 난이도의 합을 최소화하도록 숫자들을 세 자리에서 다섯 자리까지 끊어 읽고 싶다. 최소의 난이도를 계산하는 프로그램을 작성하자.

예제 
* 12341234 => 2+2 = 4
* 11111222 => 1 + 1 = 2
* 12122222 => 4 + 1 = 5
* 22222222 => 2
* 12673939 => 10+4

점화식을 만드는데 힌트는 아래와 같다.
* 길이 3인 조각의 난이도 + 나머지 수열에 대한 최적해
* 길이 4인 조각의 난이도 + 나머지 수열에 대한 최적해
* 길이 5인 조각의 난이도 + 나머지 수열에 대한 최적해

그리고 중요한 점은 앞의 부분 수열을 어떤 식으로 쪼개서 난이도를 계산했든 나머지 수열의 최적해의 최적해 계산에는 무관하다. 즉 최적 부분 구조가 성립한다. 

## [양자화](https://algospot.com/judge/problem/read/[https://algospot.com/judge/problem/read/QUANTIZE](https://algospot.com/judge/problem/read/QUANTIZE))

양자화(Quantization) 과정은, 더 넓은 범위를 갖는 값들을 작은 범위를 값들로 근사해 표현함으로써 자료를 손실 압축하는 과정을 말한다. 예를 들어, 키가 161, 164, 178인 학생을 160대 2명, 170대 1명이라고 축약해 표현하는 것도 양자화의 일종이다. 

1000이하의 자연수들로 구성된 수열을 s가지의 자연수만을 사용하도록 양자화 하도록 하자. 예를들어, 수열 [12345]를 두 가지의 자연수 2와 3을 사용하여 [22333]으로 양자화하면 각 수자별 오차는 -1, 0, 0, 1, 2가 되고 오차 제곱합은 $1+0+0+1+4= 6$ 이다.만약 두가지 자연수 2와 4를 사용하여 [22244]로 양자화하면 오차의 제곱합은 $1+0+1+0+1=3$이 된다. 후자처럼 수열과 s가 주어졌을때, 가능한 오차제곱합을 최소로 하는 양자화와 그 값을 구하자.

```
3 3 3 1 2 3 2 2 2 1 
1 744 755 4 897 902 890 6 777
```

### 하던대로 하면 안된다.

아주 단순하게 생각해보자. 주어진 수열 맨 앞에 숫자부터 가능한 양자화를 하고 그러한 모든 가능한 수열에 대해서 평균을 구하고 차이의 제곱의 합 중 최소값을 구한다. 
$$quantize(A, U)$$ 
여기서 A는 주어진 수열, U는 지금까지 양자화에 사용한 수 집합($|U| <= s$)을 말한다. $quantize(A, U)$의 반환값은 한 번 이상 양자화에 사용한 숫자 집합U를 고려하면서 수열의 가장 앞 숫자를 양자화했을때 얻을 수 있는 최소 오차 제곱의합이다. 그런데 여기서 어떤 숫자로 A의 가장 앞에 숫자를 양자화를 할지 결정하는데 엄청나게 많은 경우를 생각해야 한다. 자연수 1000개니 $_{1000}\mathrm{C}_{s}$개의 경우를 고려해야 한다. 이 정도 경우의 수라면 절대로 답을 구할 수 없다.

### 답의 형태 제한하기

최적 양자화를 찾기 위해선 흩어져있는 수열 값중에서 최대한 비슷한 값들을 묶어 양자화 하는것이 유리하다. 최대한 비슷한 값을 묶는 방법은 다양하지만 가장 간단하게는 주어진 수열을 정렬하면 된다. 정렬을 하면 같은 숫자로 양자화되는 숫자들은 인접하게 된다. 아래와 같은 예를 들어 보자.
$$1,6, 744, 4, 777, 890, 755, 902, 897$$
정렬하고 양자화에 사용할 수가 3(s=3)이면 아래와 같은 수열이 된다.
$${(1,4,6)}[4], (744, 755, 777)[759], (890, 897, 902)[896]$$

하나의 묶음에서 편차의 제곱의 합을 최소로하는 양자화수는 바로 묶음에 있는 수들의 평균이다.  사실 양자화수는 묶음으로 묶기만 하면 정해져있는 값이다. 우리는 n개의 수를 s개의 묶는 $_{n}\mathrm{C}_{s}$의 경우만 생각하면 된다. 이때 최적의 전략이 최대한 비슷한 값들끼리 묶는 것이다. 그렇다면 위의 정렬을 통해서 비슷한 값끼리 묶어 양자화를 하면 언제나 최적 값을 찾을 수 있을까? 

이것을 증명하고 싶다면 반대로 최대한 비슷하지 않은 값들로 묵음을 만들어 비교를 해보면 간단하다. 
$$1,6, 744, 4, 777, 890, 755, 902, 897$$
$${(1, 755, 902)}[553], (4, 777, 897)[559], (6, 744, 890)[547]$$

즉 묶음에 있는 수열들의 값의 차이가 최대한 적어야 평균과의 편차가 최소화하기 때문에 편차 제곱의 합도 최소화가 되고 최적값을 찾게 된다. 

첫 묶음의 크기를 x라고 하면 나머지 n-x개의 숫자들을 다음 재귀함수에 사용하게 되고 그 재귀함수에서는  s-1개의 묶음으로 나누게 된다. 이때 나머지 s-1묶음의 오류의 합이 최소여야 전체도 최소 오류이기 때문에, 최적 부분 구조 또한 성립한다. 

이 아이디어를 적용하여 점화식으로 적으면 아래와 같다. 
$$quantize(L, s) = \min_{to=1}^{to=|L|-s} [minError(from=0, to) + quantize( L.sublist(to), s-1)]$$

구체적으로 설명하자면, 먼저 수열 L을 to까지 묶음을 만들어본다. 즉 $|L|-s+1$개의 묶음이 가능하다. 예를 들어 s가 2이고 수열 A가 $1,4,6, 744,755$와 같다면 만들어 질 수 있는 묶음은 아래와 같다.
$(1), (1,4), (1,4,6), (1,4,6,744)$

그 다음으로 묶음의 나머지를 재귀적함수의 인자로 사용한다. 
여기서 minError함수는 크게 두가지이다.

1. to까지의 묶음을 양자화하기
2. 양자화 값으로 실제 구간의 오차 계산하기

사실 하나의 수열에서 오차의 값을 최소로 하는 값은 평균이다. 이건 수학적인 내용이므로 pass.
평균을 구하는 작업은 $O(n)$이지만 부분 합 기법을 사용하면 $0(1)$에 계산도 가능하다. 

따라서 minError()는 $O(1)$만에 계산이 가능하고 알고리즘의 전체 복잡도는 부분 문제의 수 O(ns)마다 문제의 답을 계산하는데 드는시간 $O(n)$을 곱한 $O(n^2s)$와 같다.


## 삼각형 위의 최대 경로 개수 세기

## 두니발 박사의 탈옥





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwNTY5MDQyNCw2NjkwOTA5NTgsOTYxOT
U1NjE0LC03ODk1Mjg1NjcsLTEyNjI2NTI4NzAsLTQ5NjAyNjE5
NiwtMjA2NzMxNDA5OCwtMTMyODM0NTE4MywtMTY0MjgyOTc0OC
wtMTUzMzQ3NDk4LC05MDY3NDgwNywtNTcxMjUxNjkyLC02Mjcy
NzE2NSwxNjQ4OTUwODU2LDE1OTU3MTQyMjYsNDY2MzU3NjAsLT
czNjc5MjI1NSwtNzk1MDkzNTE1LC04NDYyMzkyODcsLTUzNjI1
MDQ1NF19
-->