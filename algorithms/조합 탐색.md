# 조합탐색(combinational search)

동적 계획법이나 분할정복등의 디자인 패러다임은 적절히 사용될때는 매우 유용하지만 많은 문제에 적용되기는 힘들다. 적절한 분할 방법이 없는 경우 분할정복을 쓸수 없고 부분문제가 너무 많아 메모리가 부족한 경우 동적계획법을 쓸수가 없다. 이럴 경우 원점인 완전 탐색으로 돌아와야 한다. 

완전 탐색 알고리즘은 대개 답을 만드는 과정이 여로 개의 선택으로 나뉘고, 재귀 호출을 통해 각 선택지를 채워가는 형태로 구현된다. 이때 부분 답과 완성된 답의 집합을 탐색 공간(search space)이라고 한다. 
완전 탐색의 수행시간은 탐색 공간의 크기와 직접적으로 비례한다. 그런데 대부분 문제에서 탐색 공간의 크기는 문제의 규모에 따라 기하급수적으로 증가한다. 따라서 완전 탐색은 규모가 커질 수록 사용하기 어렵다는 문제가 있다. 

완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 조합탐색(combinational search)이라고 한다. 조합탐색에는 다양한 최적화 기법이 있으며, 접근 방법은 다르지만 모두 기본적으로 최적해가 될 가능성이 없는 답을 탐색하는 것을 방지하여 계산해야할 답의 수을 줄인다. 

조합 탐색을 최적화 하기 위해서는 문제에 대한 높은 식견과, 속도와 정확도 사이 상충 관계, 다양한 입력 형태 사이에 관계 등을 모두 고려하기 때문에 딱히 정답이 없어 아직도 활발히 연구되고 있는 주제이다.  

조합 탐색 최적화 기법에는 대표적으로 분기한정법이 있다.
## 분기한정법(branch-and-bound)
분기한정법은 여러가지의 최적화 문제, 특히 조합최적화 (combinatorial optimization) 에서 최적해를 찾기위한 일반적인 방법이다. `최소한 특정 영역 내에 있어야 최적의 답을 찾을 가능성이 있다.`라는 한정 범위(가능영역;feasible region)를 정해두고 범위를 벗어나는 경우는 계산과정에서 제외하여 속도 향상을 꾀한다. 

분기한정 과정은 분기(branching)와 한정(bounding)이라는 두 가지 과정을 거친다. 

분기(branching)
: 분기는 가능영역(feasible region)에서 여러 개의 작은 하위영역(feasible subregion)을 구성한다. 이 작은 하위 영역은 재귀 반복 과정을 통해 만들어지고 자연스럽게 branch-and-bound-tree 라고 불리는 tree 구조를 형성한다. 이 구조의 각 노드들이 바로 하위영역이다.

한정(bounding)
: 한정은 하위영역에서 최소 또는 최대의 범위(upper and lower bound)를 계산하는 과정을 말한다. 이 계산 결과를 이용해서 탐색공간(search space)를 줄이는 것이 가능한데 이런 기법을 가지치기(pruning)이라고 부른다. 
예를 들어 외판원 문제에서, 길이가 10인 경로를 이미 찾아냈다고 하자. 그러면 재귀 호출 도중 현재까지 만든 부분경로의 길이가 이미 10이상이라면 더 이상 탐색하지 않아도 된다. 왜냐하면 나머지 탐색을 진행해도 10보다 작은 경로를 찾을 수 없다는게 자명하기 때문이다. 

 분기한정법의 효율은 가지치기(pruning) 전략에 좌지우지 된다. 비효율적인 알고리즘을 사용하면 하위영역이 매우 작아질 때 까지 어떤 가지치기도 없이 반복해서 분기만 할수도 있다. 

## [외판원문제, TSP](https://algospot.com/judge/problem/read/TSP2)

외판원 문제는 모든 가능한 경로를 모두 계산하는 동적계획법으로도 해결이 가능하지만 도시가 많아지면 메모리 공간을 기하급수적으로 쓰기 때문에 비효율적인 방법이다.

### 간단한 휴리스틱(heuristic)을 이용한 가지치기

가지치기 기법의 가장 간단한 방법은 현재 상태의 답이 지금까지 구한 최적해와 같거나 더 나쁠때는 탐색을 중단하는 것이다. 이 방법은 나름 유용하지만 아직 좀 더 개선할 여지가 남아 있다.

조학 탐색에서 방문하는 상태의 수는 탐색의 길이가 깊어질수록 증가하기 때문에 이 부분에서는 최적해가 나올 수 없다는 것을 가능한 일찍 아는 것이 유리하다. 예를 들어, 방문할 도시가 5개가 남은 시점에서 탐색을 중단했다면 5!을 방문하는 경로를 만드는 시간을 절약할 수 있다.

휴리스틱(heuristic)을 이용한 가지치기는 남은 조각들을 푸는 정확한 최적해를 찾기는 오래걸리더라도, 이 값을 대충 어림짐작하기는 훨씬 빠르다는 점을 이용해 가지치기를 한다. 

한 상태가 주어질때 아직 남은 도시들을 방문하기 위한 경로가 얼마나 길지를 적당히 어림짐작하는 휴리스틱 함수를 만들어 보자. 휴리스틱 함수의 결과 값은 항상 정확한 답일 필요는 없고 그럴 수도 없다. 휴리스틱 함수는 결과값이 정확하지 않기 때문에 언제나 남은 최단 경로의 길이보다는 작거나 같아야 하는데, 이런 휴리스틱 방법을 과소평가(underestimate) 또는 낙천적인(optimistic)휴리스틱이라고 한다. 

탐색 과정에서 찾은 가장 좋은 답을 best라고 하고, 현재 부분경로의 길이를 lenth라고 하자. 현재 상태에서 탐색을 계속해 최적해를 갱신할 수 있으려면 앞으로 길이가 best-lenth 미만인 경로로 남은 도시들을 모두 방문하고 시작점으로 돌아가야 한다. 













> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjQ3NDE2OTY3LC00NTIwNDc1MDAsLTE0NT
A5OTU5NTgsLTE5NjEyMjA2NzYsLTE5MDE3NzkyNTUsLTEzODE4
NjczNjEsLTEzNzk0NTcyMTAsOTU5MzYzOTU1LDExNjAxODEyMz
YsMTQ3NzIzNzA5OF19
-->