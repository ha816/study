# 조합탐색(combinational search)

동적 계획법이나 분할정복등의 디자인 패러다임은 적절히 사용될때는 매우 유용하지만 많은 문제에 적용되기는 힘들다. 적절한 분할 방법이 없는 경우 분할정복을 쓸수 없고 부분문제가 너무 많아 메모리가 부족한 경우 동적계획법을 쓸수가 없다. 이럴 경우 원점인 완전 탐색으로 돌아와야 한다. 

완전 탐색 알고리즘은 대개 답을 만드는 과정이 여로 개의 선택으로 나뉘고, 재귀 호출을 통해 각 선택지를 채워가는 형태로 구현된다. 이때 부분 답과 완성된 답의 집합을 탐색 공간(search space)이라고 한다. 
완전 탐색의 수행시간은 탐색 공간의 크기와 직접적으로 비례한다. 그런데 대부분 문제에서 탐색 공간의 크기는 문제의 규모에 따라 기하급수적으로 증가한다. 따라서 완전 탐색은 규모가 커질 수록 사용하기 어렵다는 문제가 있다. 

완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 조합탐색(combinational search)이라고 한다. 조합탐색에는 다양한 최적화 기법이 있으며, 접근 방법은 다르지만 모두 기본적으로 최적해가 될 가능성이 없는 답을 탐색하는 것을 방지하여 계산해야할 답의 수을 줄인다. 

조합 탐색을 최적화 하기 위해서는 문제에 대한 높은 식견과, 속도와 정확도 사이 상충 관계, 다양한 입력 형태 사이에 관계 등을 모두 고려하기 때문에 딱히 정답이 없어 아직도 활발히 연구되고 있는 주제이다.  

조합 탐색 최적화 기법에는 대표적으로 분기한정법이 있다.
## 분기한정법(branch-and-bound)
분기한정법은 여러가지의 최적화 문제, 특히 조합최적화 (combinatorial optimization) 에서 최적해를 찾기위한 일반적인 방법이다. `최소한 특정 영역 내에 있어야 최적의 답을 찾을 가능성이 있다.`라는 한정 범위(가능영역;feasible region)를 정해두고 범위를 벗어나는 경우는 계산과정에서 제외하여 속도 향상을 꾀한다. 

분기한정 과정은 분기(branching)와 한정(bounding)이라는 두 가지 과정을 거친다. 

분기(branching)
: 분기는 가능영역(feasible region)에서 여러 개의 작은 하위영역(feasible subregion)을 구성한다. 이 작은 하위 영역은 재귀 반복 과정을 통해 만들어지고 자연스럽게 branch-and-bound-tree 라고 불리는 tree 구조를 형성한다. 이 구조의 각 노드들이 바로 하위영역이다.

한정(bounding)
: 한정은 하위영역에서 최소 또는 최대의 범위(upper and lower bound)를 계산하는 과정을 말한다. 이 계산 결과를 이용해서 탐색공간(search space)를 줄이는 것이 가능한데 이런 기법을 가지치기(pruning)이라고 부른다. 
예를 들어 외판원 문제에서, 길이가 10인 경로를 이미 찾아냈다고 하자. 그러면 재귀 호출 도중 현재까지 만든 부분경로의 길이가 이미 10이상이라면 더 이상 탐색하지 않아도 된다. 왜냐하면 나머지 탐색을 진행해도 10보다 작은 경로를 찾을 수 없다는게 자명하기 때문이다. 

 분기한정법의 효율은 가지치기(pruning) 전략에 좌지우지 된다. 비효율적인 알고리즘을 사용하면 하위영역이 매우 작아질 때 까지 어떤 가지치기도 없이 반복해서 분기만 할수도 있다. 

## [외판원문제, TSP](https://algospot.com/judge/problem/read/TSP2)

외판원 문제는 모든 가능한 경로를 모두 계산하는 동적계획법으로도 해결이 가능하지만 도시가 많아지면 메모리 공간을 기하급수적으로 쓰기 때문에 비효율적인 방법이다.

### 간단한 휴리스틱(heuristic)을 이용한 가지치기

가지치기 기법의 가장 간단한 방법은 현재 상태의 답이 지금까지 구한 최적해와 같거나 더 나쁠때는 탐색을 중단하는 것이다. 이 방법은 나름 유용하지만 아직 좀 더 개선할 여지가 남아 있다.

조학 탐색에서 방문하는 상태의 수는 탐색의 길이가 깊어질수록 증가하기 때문에 이 부분에서는 최적해가 나올 수 없다는 것을 가능한 일찍 아는 것이 유리하다. 예를 들어, 방문할 도시가 5개가 남은 시점에서 탐색을 중단했다면 5!을 방문하는 경로를 만드는 시간을 절약할 수 있다.

휴리스틱(heuristic)을 이용한 가지치기는 남은 조각들을 푸는 정확한 최적해를 찾기는 오래걸리더라도, 이 값을 대충 어림짐작하기는 훨씬 빠르다는 점을 이용해 가지치기를 한다. 

한 상태가 주어질때 아직 남은 도시들을 방문하기 위한 경로가 얼마나 길지를 적당히 어림짐작하는 휴리스틱 함수를 만들어 보자. 휴리스틱 함수의 결과 값은 항상 정확한 답일 필요는 없고 그럴 수도 없다. 

탐색 과정에서 찾은 가장 좋은 답을 best라고 하고, 현재 부분경로의 길이를 lenth라고 하자. 현재 상태에서 탐색을 계속해 최적해를 갱신할 수 있으려면 앞으로 길이가 best-lenth 미만인 경로(H(last))로 남은 도시들을 모두 방문하고 시작점으로 돌아가야 한다. 
$$best > length + H(last)$$

휴리스틱 함수는 결과값이 정확하지 않기 때문에 언제나 남은 최단 경로의 길이보다는 작거나 같아야 best를 갱신하게 된다. 이런 휴리스틱 방법을 과소평가(underestimate) 또는 낙천적인(optimistic) 휴리스틱이라고 한다. 

항상 답을 과소평가 하는 휴리스틱 함수를 만드는 것은 간단하다. 항상 0이라고 하면 된다. 단 이래서는 탐색공간을 줄이는 데는 아무 도움이 되지 않는다. 반대로 말하면 휴리스틱이 큰 값을 반환할수록 더 많은 가지를 칠 수가 있다.

휴리스틱 함수를 만드는 과정은 문제마다 다르기 때문에 정해진 바법은 없지만, 좋은 방법 중 하나는 문제의 제약조건을 일부 없앤 더 단순한 형태로 문제를 푸는 것이다. 
이제는 이러한 휴리스틱 함수를 다양한 접근법으로 만들어보자.

#### 탐욕적 접근법
여기서 처음 사용할 함수는 아직 방문하지 않은 도시들에 대해서 인접한 경로 중에 가장 짧은 경로를 더해나가는 것이다. 이 방법은 항상 최적해를 가져다 주지는 않지만, 바로 옆에 도시가 몇개씩 뭉쳐있는 경우, 멀리 있는 도시 대신에 바로 옆에 있는 도시를 방문하는 것이 유리한 경우가 많아 가지치기를 하는 경우가 많을 수 있다. 

#### 지나온 경로를 이용한 가지치기
앞으로 남은 경로 비용을 휴리스틱 함수에 이용 가능한것은 아니다. 지금까지 지나쳐온 경로를 활용할 수도 있다. 
지금까지 만든 경로가 시작 상태에서 현재 상태까지 도달하는 최적해가 아니라고 가정하자. 그러면 앞으로 남은 도시들을 아무리 잘 선택해도 최적해는 찾지 못할것이고 더 이상 탐색할 필요가 없다. 

두 개의 인접한 도시를 골라서 이 둘의 순서를 바꿔 본 뒤, 경로가 더 짧아지면 탐색을 중단하는 가지치기를 구현할 수 있다. 지금까지 만든 경로가 아래와 같을때
$$(\cdots p, a, b, q, \cdots, here)$$
a와 b의 순서를 바꾸었을때, $p-q$구간의 거리가 더 짧아진다면, 이 경로에서 최적해를 찾을 가능성이 없으니 탐색을 중단해도 된다. 여기서 항상 현재 도시 이전의 두 도시만을 본다. 왜냐하면 이미 앞서 재귀적 호출을 할때 지금까지 본 경로들은 이미 최적의 경로이기 때문이다.  이렇게 두 도시의 순서만을 바꾸었을때 경로가 더 작아지는지 여부를 반단하는 함수는 아래와 같다. 

``` 
public boolean pathSwapPruning(paths){
	if(paths.size < 4) return false;
	int p = path.size - 4;
	int a = path.size - 3;
	int b = path.size - 2;
	int q = path.size - 1;
	return distance[p][a] + distance[b][q] > distance[p][b] + distance[a][q];
}
```
pathSwapPruning()은 탐색과정에서 우리가 자기 자신을 교차하는 경로를 만들지 않게 해준다. 그리고 TSP 경로가 자기자신을 교차하면 이 답은 항상 최적이 아니다. 


인접한 도시를 골라서 둘의 순서를 바꿔보는 과정을 좀더 일반화하면 더 나은 성능을 얻을 수 있다. 두 도시의 순서를 바꾸는 대신, 전체 경로의 일부분을 통째로 뒤집는 것이다. 예를 들어 지금까지 방문한 도시의 순서가 아래와 같다고 하자.

$$(\cdots p, a, b, c, d, e, q, \cdots, here)$$
길이가 5인 부분 경로 $(a, b, c, d, e)$를 뒤집으면 아래와 같다.
$$(\cdots p, e, d, c, b, a, q, \cdots, here)$$ 이 경로가 원래 경로보다 짧아진다면 가지치기를 할 수 있다. 이때 $(\cdots p, a, b, c, d, e, q, \cdots, here)$나 $(\cdots p, e, d, c, b, a, q, \cdots, here)$은 모두 경로길이 자체는 같기 때문에 달라지는 것은 $p,q$에 인접하는 도시 뿐이다. 만약 q= here인 경우, 즉 현재 이전 도시에서 끝나는 경로들을 뒤집는 경우만 고려한다는 점을 유의하자. 

``` 
public boolean pathReversePruning(paths){
	if(paths.size < 4) return false;	
	int b = path.size - 2;
	int q = path.size - 1;
	for(int i=0; i+ 3 < path.size; ++i){
		int p = path[i];
		int a = path[i+1];
		if(distance[p][a] + distance[b][q] > distance[p][b] + distance[a][q];){
			return true;
		}
	}
	return false;
}
```
pathReversePruning()을 통해 경로의 일부분을 뒤집었을때 더 짧아지지 않는 다는 말은 이 경로가 최소한 자기 자신과 교차하지는 않는다는 사실을 보증해 준다. 

정리하자면, pathSwapPruning은 길이가 2인 경로들을 모두 뒤집어 보는 것이고, pathReversePruning은 모든 길이의 부분 경로를 뒤집어 보기 때문에 보다 많은 경우를 가지치기 할거라고 예측해 볼 수 있다. 실제 pathReversePruning은 pathSwapPruning보다 두배 넘게 빠르게 동작한다. 

### MST 휴리스틱을 이용한 가지치기 구현

앞서 공부했던 내용은 사실 비교적 간단한 최적화였다. 이제 좀 더 나은 휴리스틱한 방법을 공부해보자. 여기서 새로운 개념인 MST를 공부할 건데 그전에 ST(Spanning Tree)를 먼저 이해해보자. 

그래프(Graph)는 정점(Node)와 간선(Edge)로 구성되며, 정점간 간선으로 연결되는 구조를 가진다. 

Spanning Tree
: 그래프 내의 모든 노드를 포함하는 트리 중에서 최소 연결인 트리를 말한다. 최소 연결이란 말은 전체 간선의 수가 가장 적은 것을 뜻한다. 

$n$개의 정점을 가지는 그래프의 최소 간선의 수는 n-1개이고, n-1개의 간선으로 연결되어 있으면 필연적으로 사이클을 포함하지 않게 되며 트리 형태가 된다. 하나의 그래프에는 많은 신장 트리가 존재할 수 있고 DFS나 BFS을 이용하여 신장 트리를 찾을 수 있다.

![enter image description here](https://gmlwjd9405.github.io/images/algorithm-mst/spanning-tree.png)

최소 신장 트리 MST(Minimum Spanning Tree)
: 그래프의 신장 트리 중에서 사용된 간선들의 가중치 합이 최소인 트리.

 각 간선의 가중치가 동일하지 않을 때는 MST를 찾을때 단순히 가장 적은 간선을 사용한다고 해서 최소 비용이 얻어지는 것은 아니다.

이 MST를 계산하는 방법에는 크게 Kruskal MST 알고리즘 방법과 Prim MST방법이 있다. 여기선 Kruskal MST 방법만을 다루도록 하겠다. 

>[Kruskal MST 알고리즘](https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html)
가중치를 모든 간선에 할당한 그래프가 주어졌을때, 모든 정점을 최소 비용(가중치)으로 연결하는 MST를 탐욕적 방법(greedy method)으로 찾는 알고리즘.

>Kruskal MST 구현
>1. 그래프의 간선들을 가중치의 오름차순으로 정렬한다.
>2. 정렬된 간선 리스트에서 순서대로, 가장 낮은 가중치를 가지는 간선을  선택한다.
>3. 사이클을 형성하는 간선은 제외한다.
>4. 선택된 간선을 현재의 MST(최소 비용 신장 트리)의 집합에 추가한다.

Krukal MST는 Greedy approach이기 때문에 단순히 가장 낮은 가중치를 가지는 간선을 계속해서 선택했을때 과연 MST가 되는지를 증명해야 한다. 

정당성 증명(Proof of correctness)

정당성 증명은 알고리즘의 결과가 신장트리(spanning tree)를 반환하는지와 이렇게 반들어진 신장트리가 최소 가중치를 가지는게 맞는지 증명해야 한다. 

$G$를 연결되고, 가중치가 주어진 그래프를 말하고 $Y$를 Krukal 방법으로 만들어진 MST라고 하자.  그러면 정의에 따라서 $Y$는 cycle이 없고 하나의 트리로만 구성이 된다. $Y$는 모든 노드를 가기 때문에 disconnected할 수 없다. 왜냐하면, $Y$의 두 노드를 합친 가장 먼저 마주한 간선이 이미 알고리즘에서 더해졌기 때문
the first encountered edge that joins two components of {\displaystyle Y}![Y](https://wikimedia.org/api/rest_v1/media/math/render/svg/961d67d6b454b4df2301ac571808a3538b3a6d3f) would have been added by the algorithm.
 

 cannot have a cycle, being within one subtree and not between two different trees


![G](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b) be a connected, weighted graph and let {\displaystyle Y}![Y](https://wikimedia.org/api/rest_v1/media/math/render/svg/961d67d6b454b4df2301ac571808a3538b3a6d3f) be the subgraph of {\displaystyle G}![G](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b) produced by the algorithm.


간선을 하나 선택한다는것은 경우에 따라 두가지를 의미한다. 한 경우는 기존 경로에 포함되지않은 두 노드만으로 이루어진 새로운 경로를 만드는 경우이다. 두 번째 경우는 기존 경로에 한 노드를 추가하는 경우다. 

현재까지 방문한 노드들을 visited, 방문하는데 사용된 간선들을 $E_{visited}$라고 하자. 
그러면 $|visited| =  |E_{visited}| -1$이다.

이번 단계에서 남은 간선 중 $E- E_{visited}$ 간선의 길이가 최소인 값은 $E_{visited}$의 어떤 간선의 길이보다 항상 같거나 크다. 이런 상황에서 

 (https://en.wikipedia.org/w/index.php?title=Kruskal%27s_algorithm&action=edit&section=5 "Edit section: Proof of correctness")]

The proof consists of two parts. First, it is proved that the algorithm produces a  [spanning tree](https://en.wikipedia.org/wiki/Spanning_tree "Spanning tree"). Second, it is proved that the constructed spanning tree is of minimal weight.





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbODM0NTAzNzEyLC05MDc3MTExODUsLTE5Mz
IxODUwMDUsLTIxMDg3NDE5NjksNTk2MjQzNTg0LC03Mzc1Mzk3
MDEsNjU2NDIxMjM5LDE1NTg2ODQzNTIsLTExMTY4ODc5MSw4OT
M3OTk5MjcsMTEyNTk5MDgwNywtMzY5MDU5NzQ4LDgzNDc1Mjcx
NiwtNTQ2ODU3NjI3LDEwMDg3OTE5NzIsMTQxMDU2ODIyOCwtNj
YxNDc3MzUzLDYyODQzMzIyLC00NTIwNDc1MDAsLTE0NTA5OTU5
NThdfQ==
-->