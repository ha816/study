# 조합탐색(combinational search)

동적 계획법이나 분할정복등의 디자인 패러다임은 적절히 사용될때는 매우 유용하지만 많은 문제에 적용되기는 힘들다. 적절한 분할 방법이 없는 경우 분할정복을 쓸수 없고 부분문제가 너무 많아 메모리가 부족한 경우 동적계획법을 쓸수가 없다. 이럴 경우 원점인 완전 탐색으로 돌아와야 한다. 

완전 탐색 알고리즘은 대개 답을 만드는 과정이 여로 개의 선택으로 나뉘고, 재귀 호출을 통해 각 선택지를 채워가는 형태로 구현된다. 이때 부분 답과 완성된 답의 집합을 탐색 공간(search space)이라고 한다. 
완전 탐색의 수행시간은 탐색 공간의 크기와 직접적으로 비례한다. 그런데 대부분 문제에서 탐색 공간의 크기는 문제의 규모에 따라 기하급수적으로 증가한다. 따라서 완전 탐색은 규모가 커질 수록 사용하기 어렵다는 문제가 있다. 

완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 조합탐색(combinational search)이라고 한다. 조합탐색에는 다양한 최적화 기법이 있으며, 접근 방법은 다르지만 모두 기본적으로 최적해가 될 가능성이 없는 답을 탐색하는 것을 방지하여 계산해야할 답의 수을 줄인다. 

조합 탐색을 최적화 하기 위해서는 문제에 대한 높은 식견과, 속도와 정확도 사이 상충 관계, 다양한 입력 형태 사이에 관계 등을 모두 고려하기 때문에 딱히 정답이 없어 아직도 활발히 연구되고 있는 주제이다.  

조합 탐색 최적화 기법에는 크게 두 가지로 분류가 될수 있다. 대표적으로는 아래에서 알아볼 분기한정법이다. 

## 분기한정법(branch-and-bound)

분기한정법은 여러가지의 최적화 문제, 특히 조합최적화 (combinatorial optimization) 에서 최적해를 찾기위한 일반적인 방법이다. `최소한 특정 영역 내에 있어야 최적의 답을 찾을 가능성이 있다.`라는 한정 범위(가능영역;feasible region)를 정해두고 범위를 벗어나는 경우는 계산과정에서 제외하여 속도 향상을 꾀한다. 

분기한정 과정은 분기(branching)와 한정(bounding)이라는 두 가지 과정을 거친다. 

분기(branching)
: 분기는 가능영역(feasible region)에서 여러 개의 작은 하위영역(feasible subregion)을 구성한다. 이 작은 하위 영역은 재귀 반복 과정을 통해 만들어지고 자연스럽게 branch-and-bound-tree 라고 불리는 tree 구조를 형성한다. 이 구조의 각 노드들이 바로 하위영역이다.

한정(bounding)
: 한정은 하위영역 내에서 최적해를 찾기위한 최소 또는 최대의 범위(upper and lower bound )를 를 빠르게 찾는다.

분기한정법의 핵심은, (작업을  최소화  하기 위해) 탐색트리에서 하위영역 A 의 lower bound 가 이미 검사된 다른 하위영역 B 의 upper bound 보다 크다면 A 를 탐색에서 제외하는 간단한 방법이다. 이러한 단계를 절단 (pruning) 이라고 부른다. 절단은 검사된 모든 하위영역 중에서 볼수있는 minimum upper bound 를 기록하는 전역변수를 하나 유지함으로써 구현 할 수 있다. 즉 임의의 한 하위영역의 lower bound 가 m 보다 크면 바로 그 하위영역은 계산에서 제외를 한다. 
 이상적으로는 분기한정법은 탐색트리의 모든 노드가 절단 (pruned) 되거나 해결 (solved) 되면 끝난다. 그러한 관점에서 모든 non-pruned subregions 은 함수의 전역 최소값과 같은 upper and lower bounds 를 가질것이다. 
  분기한정법의 효율은 사용되는 branching and bounding algorithm 에 전적으로 의존한다. 즉 잘못된 알고리즘을 사용하면 하위영역이 매우 작아질 때 까지 어떤 pruning도 없이 반복된 branching 만 할수도 있다. 또 반대로 pruning을 하면 안되는 노드에 대해서 pruning을 하여 최적해를 놓치는 경우도 있을 수 있다. 

'대표적인 알고리즘으로는 외판원문제(Traveling Salesman Problem), 배낭문제(Knapsack Problem)이 있다. 


> Written with [StackEdit](https://stackedit.io/).







> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNzk0NTcyMTAsOTU5MzYzOTU1LDExNj
AxODEyMzYsMTQ3NzIzNzA5OF19
-->