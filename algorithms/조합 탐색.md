# 조합탐색(combinational search)

동적 계획법이나 분할정복등의 디자인 패러다임은 적절히 사용될때는 매우 유용하지만 많은 문제에 적용되기는 힘들다. 적절한 분할 방법이 없는 경우 분할정복을 쓸수 없고 부분문제가 너무 많아 메모리가 부족한 경우 동적계획법을 쓸수가 없다. 이럴 경우 원점인 완전 탐색으로 돌아와야 한다. 

완전 탐색 알고리즘은 대개 답을 만드는 과정이 여로 개의 선택으로 나뉘고, 재귀 호출을 통해 각 선택지를 채워가는 형태로 구현된다. 이때 부분 답과 완성된 답의 집합을 탐색 공간(search space)이라고 한다. 
완전 탐색의 수행시간은 탐색 공간의 크기와 직접적으로 비례한다. 그런데 대부분 문제에서 탐색 공간의 크기는 문제의 규모에 따라 기하급수적으로 증가한다. 따라서 완전 탐색은 규모가 커질 수록 사용하기 어렵다는 문제가 있다. 

완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 조합탐색(combinational search)이라고 한다. 조합탐색에는 다양한 최적화 기법이 있으며, 접근 방법은 다르지만 모두 기본적으로 최적해가 될 가능성이 없는 답을 탐색하는 것을 방지하여 계산해야할 답의 수을 줄인다. 

조합 탐색을 최적화 하기 위해서는 문제에 대한 높은 식견과, 속도와 정확도 사이 상충 관계, 다양한 입력 형태 사이에 관계 등을 모두 고려하기 때문에 딱히 정답이 없어 아직도 활발히 연구되고 있는 주제이다.  

조합 탐색 최적화 기법에는 대표적으로 분기한정법이 있다.
## 분기한정법(branch-and-bound)
분기한정법은 여러가지의 최적화 문제, 특히 조합최적화 (combinatorial optimization) 에서 최적해를 찾기위한 일반적인 방법이다. `최소한 특정 영역 내에 있어야 최적의 답을 찾을 가능성이 있다.`라는 한정 범위(가능영역;feasible region)를 정해두고 범위를 벗어나는 경우는 계산과정에서 제외하여 속도 향상을 꾀한다. 

분기한정 과정은 분기(branching)와 한정(bounding)이라는 두 가지 과정을 거친다. 

분기(branching)
: 분기는 가능영역(feasible region)에서 여러 개의 작은 하위영역(feasible subregion)을 구성한다. 이 작은 하위 영역은 재귀 반복 과정을 통해 만들어지고 자연스럽게 branch-and-bound-tree 라고 불리는 tree 구조를 형성한다. 이 구조의 각 노드들이 바로 하위영역이다.

한정(bounding)
: 한정은 하위영역에서 최소 또는 최대의 범위(upper and lower bound)를 계산하는 과정을 말한다. 이 계산 결과를 이용해서 탐색공간(search space)를 줄이는 것이 가능한데 이런 기법을 가지치기(pruning)이라고 부른다. 
예를 들어 외판원 문제에서, 길이가 10인 경로를 이미 찾아냈다고 하자. 그러면 재귀 호출 도중 현재까지 만든 부분경로의 길이가 이미 10이상이라면 더 이상 탐색하지 않아도 된다. 왜냐하면 나머지 탐색을 진행해도 10보다 작은 경로를 찾을 수 없다는게 자명하기 때문이다. 

 분기한정법의 효율은 가지치기(pruning) 전략에 좌지우지 된다. 비효율적인 알고리즘을 사용하면 하위영역이 매우 작아질 때 까지 어떤 가지치기도 없이 반복해서 분기만 할수도 있다. 

## [외판원문제, TSP](https://algospot.com/judge/problem/read/TSP2)

외판원 문제는 모든 가능한 경로를 모두 계산하는 동적계획법으로도 해결이 가능하지만 도시가 많아지면 메모리 공간을 기하급수적으로 쓰기 때문에 비효율적인 방법이다.

### 간단한 휴리스틱(heuristic)을 이용한 가지치기

가지치기 기법의 가장 간단한 방법은 현재 상태의 답이 지금까지 구한 최적해와 같거나 더 나쁠때는 탐색을 중단하는 것이다. 이 방법은 나름 유용하지만 아직 좀 더 개선할 여지가 남아 있다.

조학 탐색에서 방문하는 상태의 수는 탐색의 길이가 깊어질수록 증가하기 때문에 이 부분에서는 최적해가 나올 수 없다는 것을 가능한 일찍 아는 것이 유리하다. 예를 들어, 방문할 도시가 5개가 남은 시점에서 탐색을 중단했다면 5!을 방문하는 경로를 만드는 시간을 절약할 수 있다.

휴리스틱(heuristic)을 이용한 가지치기는 남은 조각들을 푸는 정확한 최적해를 찾기는 오래걸리더라도, 이 값을 대충 어림짐작하기는 훨씬 빠르다는 점을 이용해 가지치기를 한다. 

한 상태가 주어질때 아직 남은 도시들을 방문하기 위한 경로가 얼마나 길지를 적당히 어림짐작하는 휴리스틱 함수를 만들어 보자. 휴리스틱 함수의 결과 값은 항상 정확한 답일 필요는 없고 그럴 수도 없다. 

탐색 과정에서 찾은 가장 좋은 답을 best라고 하고, 현재 부분경로의 길이를 lenth라고 하자. 현재 상태에서 탐색을 계속해 최적해를 갱신할 수 있으려면 앞으로 길이가 best-lenth 미만인 경로(H(last))로 남은 도시들을 모두 방문하고 시작점으로 돌아가야 한다. 
$$best > length + H(last)$$

휴리스틱 함수는 결과값이 정확하지 않기 때문에 언제나 남은 최단 경로의 길이보다는 작거나 같아야 best를 갱신하게 된다. 이런 휴리스틱 방법을 과소평가(underestimate) 또는 낙천적인(optimistic) 휴리스틱이라고 한다. 

항상 답을 과소평가 하는 휴리스틱 함수를 만드는 것은 간단하다. 항상 0이라고 하면 된다. 단 이래서는 탐색공간을 줄이는 데는 아무 도움이 되지 않는다. 반대로 말하면 휴리스틱이 큰 값을 반환할수록 더 많은 가지를 칠 수가 있다.

휴리스틱 함수를 만드는 과정은 문제마다 다르기 때문에 정해진 바법은 없지만, 좋은 방법 중 하나는 문제의 제약조건을 일부 없앤 더 단순한 형태로 문제를 푸는 것이다. 
이제는 이러한 휴리스틱 함수를 다양한 접근법으로 만들어보자.

#### 탐욕적 접근법
여기서 처음 사용할 함수는 아직 방문하지 않은 도시들에 대해서 인접한 경로 중에 가장 짧은 경로를 더해나가는 것이다. 이 방법은 항상 최적해를 가져다 주지는 않지만, 바로 옆에 도시가 몇개씩 뭉쳐있는 경우, 멀리 있는 도시 대신에 바로 옆에 있는 도시를 방문하는 것이 유리한 경우가 많아 가지치기를 하는 경우가 많을 수 있다. 

#### 지나온 경로를 이용한 가지치기
앞으로 남은 경로 비용을 휴리스틱 함수에 이용 가능한것은 아니다. 지금까지 지나쳐온 경로를 활용할 수도 있다. 
지금까지 만든 경로가 시작 상태에서 현재 상태까지 도달하는 최적해가 아니라고 가정하자. 그러면 앞으로 남은 도시들을 아무리 잘 선택해도 최적해는 찾지 못할것이고 더 이상 탐색할 필요가 없다. 

두 개의 인접한 도시를 골라서 이 둘의 순서를 바꿔 본 뒤, 경로가 더 짧아지면 탐색을 중단하는 가지치기를 구현할 수 있다. 지금까지 만든 경로가 아래와 같을때
$$(\cdots p, a, b, q, \cdots, here)$$
a와 b의 순서를 바꾸었을때, $p-q$구간의 거리가 더 짧아진다면, 이 경로에서 최적해를 찾을 가능성이 없으니 탐색을 중단해도 된다. 여기서 항상 현재 도시 이전의 두 도시만을 본다. 왜냐하면 이미 앞서 재귀적 호출을 할때 지금까지 본 경로들은 이미 최적의 경로이기 때문이다.  이렇게 두 도시의 순서만을 바꾸었을때 경로가 더 작아지는지 여부를 반단하는 함수는 아래와 같다. 

``` 
public boolean pathSwapPruning(paths){
	if(paths.size < 4) return false;
	int p = path.size - 4;
	int a = path.size - 3;
	int b = path.size - 2;
	int q = path.size - 1;
	return distance[p][a] + distance[b][q] > distance[p][b] + distance[a][q];
}
```

위의 인접한 도시를 골라서 둘의 순서를 바꿔보는 과정을 좀더 일반화하면 더 나은 성능을 얻을 수 있다. 두 도시의 순서를 바꾸는 대신, 전체 경로의 일부분을 통째로 뒤집는 것이다. 예를 들어 지금까지 방문한 도시의 순서가 아래와 같다고 하자.

$$(\cdots p, a, b, c, d, e, q, \cdots, here)$$
길이가 5인 부분 경로 $(a, b, c, d, e)$를 뒤집으면 아래와 같다.

$$(\cdots p, e, d, c, b, a, q, \cdots, here)$$
이 경로가 원래 경로보다 짧아진다면 가지치기를 할 수 있다. 이때 
$(\cdots p, a, b, c, d, e, q, \cdots, here)$나 $(\cdots p, e, d, c, b, a, q, \cdots, here)$ 모두 경로길이 자체는 같기 때문에 달라지는 것은 $p,q$에 인접하는 도시 뿐이다. 만약 q= here인 경우, 즉 현재 이전 도시에서 끝나는 경로들을 뒤집는 경우만 고려한다는 점을 유의하자. 

``` 
public boolean pathReversePruning(paths){
	if(paths.size < 4) return false;	
	int b = path.size - 2;
	int q = path.size - 1;
	for(int i=0; i+ 3 < path.size; ++i){
		int p = path[i];
		int a = path[i+1];
	}
}
```























> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU3NjE4OTQ0NCw4OTM3OTk5MjcsMTEyNT
k5MDgwNywtMzY5MDU5NzQ4LDgzNDc1MjcxNiwtNTQ2ODU3NjI3
LDEwMDg3OTE5NzIsMTQxMDU2ODIyOCwtNjYxNDc3MzUzLDYyOD
QzMzIyLC00NTIwNDc1MDAsLTE0NTA5OTU5NTgsLTE5NjEyMjA2
NzYsLTE5MDE3NzkyNTUsLTEzODE4NjczNjEsLTEzNzk0NTcyMT
AsOTU5MzYzOTU1LDExNjAxODEyMzYsMTQ3NzIzNzA5OF19
-->