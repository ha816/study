
# 6장 알고리즘 설계 패러다임

여기서는 단순히 각 알고리즘 설계 패러다임에 대한 간략한 정의 및 설명만을 정리한다. 실제 패러다임에 맞는 문제들은 각 페이지 별로 참고하자.


## 무식하게 풀기(Brute /Force)

brute는 "짐승같은, 난폭한"이라는 뜻이고, brute-force는 "난폭한 힘, 폭력"이라는 뜻이다. 

흔히 전삭학에서 무식하게 푼다라는 말의 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법을 의미한다.  

가능한 방법을 모두 만들어 보는 알고리즘을 완전 탐색(exhaustive search)이라고 부른다. 얼핏 보면 이런 것을 언급할 필요가 있나 싶을 정도로 간단한 방법이지만, 완전 탐색은 컴퓨터의 장점을 가장 잘 이용하는 방법이다. 컴퓨터의 최대 장점은 결국 계산 속도가 빠르다는 것이기 때문이다. 

## 분할 정복법(Divide & Conquer)

가장 유명한 알고리즘 디자인 패러다임으로, 각개 격파라는 말이다. 
주어진 문제를 둘 이상의 부분 문제로 나누고, 각 문제에 대한 답을 재귀호출을 이용해 계산하고, 각 부분 문제의 답으로 부터 전체 문제의 답을 계산해낸다. 

분할 정복법을 사용하는 알고리즘은 대개 세 가지 구성요소를 가진다.

* 문제를 더 작은 문제로 나누는 과정(Divide)
* 더 이상 문제를 나누지 않고, 바로 답을 낼 수 있는 매우 작은 문제(Base case)
* 각 문제에 대한 답을 구한뒤, 원래 큰 문제의 답으로 병합하는 과정(Merge)


## 동적 계획법(Dynamic Programming)

동적 계획법은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임이다. 이름만 가지고는 무엇을 의미하는지 영 알기가 어렵기 때문에 많은 오해를 불러일으키는 주제이기도 한다.

동적 계획법이란 말은 최적화 무제를 연구하는 수학 이론에서 왔으며, 우리가 전삭한 전반에서 일반적으로 사용하는 동적, 혹은 프로그래밍이라는 단어와는 아무 관련이 없다. 

동적 계획법의 고안자 벨만은 dynamic이라는 단어가 멋있어서 선택했다고 한다. Programming이란 말은 최적화 연구분야에서 최적의 프로그램을 찾아낸다는 의미로 사용된다.

### 중복되는 부분 문제

동적 계획법은 사용하는 알고리즘들 은 처음에 주어진 문제를 더 작은 문제들로 나눈뒤 각 부분의 답을 계산후, 이 답들로 부터 원래 문제에 대한 답을 계산해 낸다.

이러한 형태는 사실 큰 의미에서 분할 정복 방법과 비슷하다. 두 패러다임의 차이는 문제를 나누는 방식에서 있다.  동적계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용 될수 있기 때문에, 문제의 답을 여러번 계산하는 대신 한번만 계산하고 그 계산결과를 재활용함으로써 속도의 향상을 꾀할 수 있다. 

그러기 위해서는 각 문제의 답을 저장해 둘 필요가 있으며, 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시라고 부른다. 또 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblmes)라고 부른다. 

동적 계획법의 대표적인 알고리즘으로 이항 계수의 계산이 있다. 
이항 계수는 n개의 서로 다른 원소중에서 r개의 원소를 순서 없이 뽑는 문제이다. 

${n}\choose{r}$ = ${n-1}\choose{r-1}$ +${n-1}\choose{r}$

이 식을 재귀적 호출로 간단하게 구현하면 아래와 같다. 이때 주목할 점은 이항계수의 특성상 같은 값을 두 번 이상 계산할 일이 빈번하다는 점이다. 

``` 
int binomial(int n, int r) {재귀호출을 이용한 이항 계수의 계산
	if(n == r || r==0){
		return 1;
	} // base 모든 원소를 다 고른 경우 또는 고를 원소가 없는 경우
	return binomial(n-1, r-1) + binomial(n-1, r)
}
```

![](http://andromeda-express.com/dp/figures/binomial_call_tree.dot.png)

위의 그림은 bino(4,2)를 계산하는 과정을 나타낸 그림이다. 여기서 중요한 점은 bion(2,1)이 두번 호출된다는 점이다. 






> Written with [StackEdit](https://stackedit.io/).


## 탐욕법(Greedy approach)

## 조합 탐색법(Combinatorial search)

Common algorithms for solving combinatorial search problems include:

-   [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm "A* search algorithm")
-   [Alpha-beta pruning](https://en.wikipedia.org/wiki/Alpha-beta_pruning "Alpha-beta pruning")
-   [Branch-and-bound](https://en.wikipedia.org/wiki/Branch-and-bound "Branch-and-bound")
-   [Minimax](https://en.wikipedia.org/wiki/Minimax "Minimax")



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2NDY5NDEzODEsLTg4ODMxMTI4Miw1MT
E3NTcxMjYsNjYxNjQxNTIxLC0xNTcyODMzNDZdfQ==
-->