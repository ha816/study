#  동적 계획법(Dynamic Programming)

동적 계획법은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임이다. 이름만 가지고는 무엇을 의미하는지 영 알기가 어렵기 때문에 많은 오해를 불러일으키는 주제이기도 한다.

동적 계획법이란 말은 최적화 문제를 연구하는 수학 이론에서 왔으며, 우리가 전삭한 전반에서 일반적으로 사용하는 동적, 혹은 프로그래밍이라는 단어와는 아무 관련이 없다. 

동적 계획법의 고안자 벨만은 dynamic이라는 단어가 멋있어서 선택했다고 한다. Programming이란 말은 최적화 연구분야에서 최적의 프로그램을 찾아낸다는 의미로 사용된다.

동적 계획법을 사용하는 알고리즘들은 처음에 주어진 문제를 더 작은 문제들로 나눈 뒤 작은 문제들의 답을 계산후, 이 답으로부터 원래 문제에 대한 답을 계산해 낸다. 이러한 형태는 사실 앞서 공부한 분할 정복 방법과 비슷하다. 

 두 패러다임의 차이는 같은 작은 문제의 답을 거듭해서 필요로 하는지 여부에서 온다. 분할정복방법에서는 계산해야할 작은 문제들이 확실하게 나누어지고 계산 결과가 재사용되지 않는다. 반면에 동적계획법에서 어떤 작은 문제의 답이 재사용 될수 있기 때문에, 계산 결과가 같은 작은 문제 여러번 다시 계산하는 대신 한 번만 계산하고 그 계산결과를 재활용함으로써 속도의 향상을 꾀할 수 있다.  따라서 각 작은 문제의 답을 저장해 둘 필요가 있으며, 계산한 값을 저장해 두는 메모리의 장소를 캐시라고 부른다. 또 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblmes)라고 부른다. 

결과를 저장하는 장소를 마련해두고, 계산한 값을 저장두었다가 재활용하는 최적화 기법을 [메모이제이션(memoization)](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)이라고 한다. 메모라이제이션이라고 잘못 사용하는 경우가 많은데 메모이제이션이 옳은 표현이다 . 

본 장에서 다루게 될 동적 계획법을 활용한 알고리즘은 순서대로 아래와 같다.

최적부분구조 : 이항계수계산, 외발뛰기, 삼각형위의 최대경로, 최장증가부분수열, 최장증가부분수열, 원주율 외우기, 양자화 

## [이항계수계산](https://ko.wikipedia.org/wiki/%EC%9D%B4%ED%95%AD_%EA%B3%84%EC%88%98)(binomial coefficient)

이항 계수는 $n$개의 서로 다른 원소중에서 $r$개의 원소를 순서에 상관 없이 뽑는 문제이다. 즉 가능한 조합의 갯수를 계산하는 것이 목표다. 

${n}\choose{r}$ = ${n-1}\choose{r-1}$+${n-1}\choose{r}$

이 식을 재귀적 호출로 간단하게 구현하면 아래와 같다. 이 때 주목할 점은 이항계수의 특성상 같은 값을 두 번 이상 계산할 일이 빈번하다는 점이다. 

``` 
int binomial(int n, int r) {재귀호출을 이용한 이항 계수의 계산
	if(n == r || r==0){
		return 1;
	} // base 모든 원소를 다 고른 경우 또는 고를 원소가 없는 경우
	return binomial(n-1, r-1) + binomial(n-1, r)
}
```
![](http://andromeda-express.com/dp/figures/binomial_call_tree.dot.png)

위의 그림은 bino(4,2)를 계산하는 과정을 나타낸 그림이다. 여기서 중요한 점은 bion(2,1)이 두번 호출된다는 점이다. 

bino(2,1)은 bino(3,1)과 bino(3,2)를 위해서 필요하다. 게다가 bino(2,1)은 bino(1,0)과 bino(1,1)을 호출하기 때문에 같은 계산을 두번이나 하게 된다. 

함수의 중복 호출 수는 n과 r이 커짐에 따라 기하 급수적으로 증가한다.  아래 그림을 보면, bino(8,4)를 계산하기 위해서 bino(1,0)과 bino(1,1)를 반복적으로 호출하는 것을 볼 수가 있다.

일반화 해서 더 많은 n에 대해서 호출의 수를 계산해보자면, 
$bino(n, \frac{n}{2})$을 계산하기 위해서, 아래와 같이 n이 증가할때마다 거의 두배 가까이 증가하는 것을 볼수 있다. 

|n| 2 | 3  |  4| 5|6 | ... | 18| ...  | 25|
|--|--|--|--|--|--|--|--|--|--|
|호출 횟수| 3|5 | 11 |19|39|...|97239|...|10400599

![](http://andromeda-express.com/dp/figures/binomial_call_tree3.dot.png)

### 메모이제이션 전략

앞서 설명한 것처럼 $n$이 증가할때마다 기하급수적으로 계산량이 늘기때문에 한번 계산된 결과는 캐시를 저장하여 계산량을 줄일 필요가 있다. 메모이제이션을 사용하면 위 알고리즘의 복잡도는 $O(nr)$이 된다. 

## 피보나치 수열 구하기

피보나치 수열의 n번째 값을 구하는 메서드 fibonachi를 만들어보자.
$$L(1) = L(2) = 1,$$$$L(k) = L(k-2) + L(k-1)$$
```
function fibonachi(int n){
	if(n == 1 || n == 2){
		return 1;
	}
	return fibonachi(n-1) + fibonachi(n-2);
}
```

메모이제이션 사용하기

```
Map<Integer, Integer> cache = new HashMap();
function fibonachi(int n){
	if(n == 1 || n == 2){
		return 1;
	}
	if(cache.contain(n)){	
		return cache.get(n);
	}
	int result = fibonachi(n-1) + fibonachi(n-2);
	cache.put(n, result);
	return result;
}
```

## [외발뛰기](https://algospot.com/judge/problem/read/JUMPGAME)

$n * n$ 크기의 격자에 1부터 9까지 정수를 쓴 게임판이 주어진다. 게임의 목적은 게임판의 왼쪽 위칸에서 시작해서 게임판 맨 오른쪽 아래에 도착하는 것이다. 이때 각 칸에 적혀있는 숫자만큼 아래쪽이나 오른쪽으로 이동할 수 있으며, 중간에 게임판 밖으로 벗어나면 안된다. 

문제의 답은 게임판이 주어질때 시작점에서 끝점으로 도달하는 방법이 있는지 없는지 여부를 가리는 것이다. 예를 들어 (b) 게임판에서는 끝에 도달할 수 있는 방법이 없다.

![](https://mblogthumb-phinf.pstatic.net/20160617_21/oncoder-hs_1466144620717O5LA9_PNG/11111.png?type=w2)

본 문제를 풀기 위한 점화식은 아래와 같다. 
$$jump(x,y) = End(x,y)\ or\ \begin{cases} jump(x, y+D[x][y])\\
jump(x+D[x][y], y)\end{cases}$$

$x$, $y$는 게임판에서 특정 좌표이며 $x$는 가로축, $y$는 세로축을 말한다. 주어진 좌표에 대해서 게임판 끝에 도달했다면 시작점에서 끝점으로 도달했다는 것을 알리고 아니라면 게임판의 수($D[x][y]$)만큼 가로, 세로로 이동해보도록 입력 파라미터를 수정하여 함수를 재귀적으로 호출한다. 

본 알고리즘의 복잡도는 메모이제이션을 사용하면 모든 입력 가능한 좌표의 수만큼인 $O(n*n)$이 된다. 그리고 같은 수만큼 $O(n*n)$만큼 캐시 공간을 사용할 수 있다.

## [삼각형 위의 최대경로](https://algospot.com/judge/problem/read/TRIANGLEPATH)

높이가 $n$인 삼각형 모양의 자연수들이 아래 그림처럼 주어졌다. 우리는 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 한다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있다. 이 때 모든 경로 중 포함된 숫자의 합의 최대값을 찾고 최대값의 경로도 보여라.
```
6
1  2
3  7  4
9  4  1  7
2  7  5  9  4
```
본 문제를 해결하는 점화식은 아래와 같다. 
$$pathSum(x,y, sum) = max \begin{cases} pathSum(x,y+1, sum+cost(x,y)) \\
pathSum(x+1, y+1, sum+cost(x,y)) \end{cases}$$
$pathSum(x, y, sum)$에서 앞에 두 인자는 현재의 좌표 $(x,y)$이고 지금까지 만난 경로 값의 합이 $sum$이다. $pathSum$은 아래 혹 오른쪽 아래로 경로를 내려가면서 경로마다 만난 수($cost(x,y)$)를 맨 아래줄까지 더한 값 중 최대합을 반환한다. 
$pathSum$은 세 개의 파라미터를 받아 처리를 하는데 이 파라미터를 두 부류로 나누면 아래와 같다. 
* $x,y$는 풀어야할 부분 문제를 지정한다. $x,y$는 현재 위치이고 이를 기반으로 계산해야할 경로합을 반환한다.   
* $sum$은 지금까지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다. 지금까지 풀었던 문제들에 대한 정보라고 할 수 있다. 

여기서 중요한 점은 $sum$이 과연 앞으로 남은 문제를 푸는데 필요한지 생각해보아야 한다. 처음 시작점에서 부터가 아니라 임의의 $x,y$의 기준에서 최대 경로합은 지금까지 어떤 경로와 계산으로 $sum$이 구해졌던 아무  상관이 없다. 하지만 재귀함수에서 $sum$을 입력 받지 않으면, 이전까지 어떤 숫자를 만났는지 알 수가 없기 때문에 경로의 최대합을 반환 할수가 없다. 
그럼 어떻게 하는게 좋을까? 함수의 반환값을 전체 경로의 최대치가 아니라 $x,y$로 시작하는 부분 경로의 최대치로 바꿀 필요가 있다. 자 새로운 점화식을 정의해보자. $pathSum2(x,y)$는 과거 경로를 고려하지 않고 주어진 $(x,y)$ 좌표에서 시작하여 맨 아랫줄로 내려가는 부분 경로의 최대합을 반환한다. 

$$pathSum2(x,y) = cost(x,y) + max \begin{cases} pathSum2(x,y+1) \\
pathSum2(x+1, y+1) \end{cases}$$

메모이제이션을 사용하였을때, 본 알고리즘의 시간 복잡도는 모든 가능한 좌표의 수인 $O(\frac{n^2}{2})$이고 마찬가지로 캐시의 공간복잡도도 $O(\frac{n^2}{2})$이다.

### 최적 부분구조(optimal substructure)

우리는 파라미터 $sum$이 앞으로 부분문제를 계산하는데 필요한지 생각해보았다. 최적화 할 수 있었던 이유는 $sum$이라는 정보가 $(x,y)$에서 맨 아래줄 까지 내려가는 문제를 해결하는데 아무상관이 없다는 사실 때문이다. 다시 말해 지금까지 어떤 경로로 부분 문제에 도착했건 남은 부분 문제는 계산과는 상관이 없다는 것이다. 이 조건은 효율적인 동적 프로그램을 적용하기 위해 아주 중요한 조건이다. 얼마나 중요할 정도냐면, 최적 부분구조(optimal substructure)라는 유식한 이름을 붙여서 이야기를 한다. 

최적 부분구조는 어떤 문제와 분할 방식에 성립하는 조건이다. 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어 낼수 있는 경우, 이 조건이 성립한다. 반면 부분문제의 최적해만으로 전체문제의 최적해를 구할수 없다면 그 문제는 최적 부분 구조가 존재하지 않는다. 

## [최장증가부분수열](https://algospot.com/judge/problem/read/LIS)(LIS; Longest Increasing Subsequence)

수학에서 수열(sequence)이란 정수를 원소로 가지는 리스트를 말한다. 길이가 $n$인 수열의 부분수열(subsequence)은 0개 이상의 숫자를 지운 수열을 말한다. 따라서 길이가 $n$인 수열의 경우, 모든 부분수열 $2^n$이을 얻다. 예를 들어 `10 7 4 9` 의 부분 수열에는 `7 4 9`, `10 4`, `10 9` 등이 있다. 단, `10 4 7` 은 원래 수열 순서와 다르므로 `10 7 4 9` 의 부분 수열이 아니다. 즉 부분 수열은 원래 수열의 순서를 지켜야 한다. 

다음으로 증가부분수열(increasing subsequence)이란 부분수열에 포함된 숫자들이 순증가(strictly increasing)하는 부분수열이다.

* 순 증가(strictly increasing)
	* 수열에서 모든 두 인접한 숫자 중 앞의 것이 항상 더 작다.
* 단조 증가(monotonically increasing)
	* 수열에서 모든 두 인접한 숫자가 같거나 작다.

결국 최장증가 부분수열 문제는 하나의 수열이 주어졌을때 얻을수 있는 증가부분수열 중 길이가 가장 길고 순증가하는 수열을 찾는 것이다. 아래는 수열이 주어졌을때, 가능한 최장증가부분수열을 나타낸 것이다. 
```
{1 2 3 4} => {1 2 3 4}
{5 4 3 2 1 6 7 8} => {5 6 7 8},{4 6 7 8},{3 6 7 8},{2 6 7 8},{1 6 7 8},
{5 6 7 8 1 2 3 4} => {5 6 7 8},{1 2 3 4}
```
최장증가부분수열을 구하기 위해 가장 간단한 전략은 $2^n$개의 부분수열을 모두 구하고 그 중에 가장 길면서 증가하는 부분수열을 찾으면 된다. 하지만 너무 계산량이 많으니 다른 전략을 생각해야 한다. 

먼저, 증가수열의 특성을 생각해보자. 증가수열에서 모든 원소는 자신보다 뒤에 있는 원소와 반드시 작거나 같아야 한다. 최장증가부분수열도 증가수열이기 때문에 특정한 위치에 원소는 반드시 뒤에 원소보다는 항상 작거나 같아야 한다. 예를 들어 $[5, 1, 10, 7]$이 주어졌을때 각 원소를 순회하면서 가능한 증가수열을 생각해보자. 

[5] -> [5], ~~[5, 1]~~, [5, 10], [5, 7], ~~[5, 1, 10]~~, ~~[5, 1, 7]~~, ~~[5, 10, 7]~~, ~~[5, 1, 10, 7]~~
[1] -> [1], [1, 10], [1, 7], ~~[1, 10, 7]~~
[10] -> [10], ~~[10, 7]~~
[7] -> [7]

증가수열은 순회의 기준이 되는 원소와 그 원소와 비교하여 같거나 큰 수들로 이루어진다. 따라서 기준 원소보다 작은 수들은 증가수열을 찾는과정에서 제외하여 검색량을 줄일 수 있다. 달리 말하면 기준 원소보다 같거나 큰 원소들로만 다음 재귀함수 호출시 사용하는 것이다. 이 전략을 사용해서 수도코드를 작성하면 아래와 같이 나타낼 수 있다. 
```
getLIS(sequence){
	List candidateIS; //증가수열 후보군
	for(int index=0; index < sequence.lenth; index++)
		target = sequence[index]; 		
		List numbers = getHigherOrEqualNumbers(sequence, ,target, index+1);
		//Given a sequence, from 'index+1' to end of the sequence, get a List of numbers, which has Higher than Or Equal to 'target'  
		
		candidateIS.add(target + getLIS(numbers));
	}
	return filterCandidateIS()
	//get LIS from candiateIS by the longest size;
}
```
메모이제이션을 사용하면 최대시간복잡도는 $O(n^2)$이다. 왜냐하면, 중복을 제외하면 함수 호출시 가능한 수열은 $n$가지가 되고 수열마다 증가부분수열을 구하기위해  $n$번의 추가 연산이 필요하기 때문이다. 또한 특정 수열에 대한 LIS를 계산하기 위해 과거에 연산증가수열을 찾으려면 맨 앞에 있는 숫자보다 큰 숫자들로만 만든 부분 수열들로 lis함수를 재귀 호출한다. 즉 현재 단계에 있는 수열은 과거에 있는 수열을 알 필요가 없다는 점에서 최적 부분 구조가 여기서도 성립한다. 

### 더 빠른 방법

보다 전략적인 다른 방법을 이용하면 $O(n log n)$만에 LIS의 길이를 찾는 것이 가능하다. 주의할 점은 LIS 수열 자체가 아니라 최장 길이를 계산할 수 있다는 점이다 주의하도록 하자. 가장완전 탐색을 이용시 캐시를 사용한다면 최대시간복잡도는 $O(n^2)$이다. 하지만 다른 방법을 이용하면 $O(n log n)$이 가능하다. 

 이 방법은 정렬된 리스트 L에 원소를 추가 또는 교체하면서 진행한다. 주어진 입력 수열의 원소들을 앞에서부터 순회하는데 특정 순회 차례의 원소를 t(target)이라고 하겠다. 이때 추가 또는 교체하는 조건은 아래와 같다. 

1. 추가(Adding) 
	* 리스트가 비어있거나, 현재 리스트의 마지막 원소보다 t가 클 경우, 리스트에 t를 추가한다. 
2. 교체(Replacing)
	* 추가 조건이 아니라면 리스트에서 t의 Loweround를 찾아 t로 교체한다.
	 
>LowerBound
>정렬된 리스트(L)에 어떤 입력값(t)을 삽입하려고 하는데 삽입 후에도 정렬된 상태를 유지하고자 한다. 이 때 **삽입 가능한 위치(index) 중에 가장 작은 위치**를 리스트(L)에서 입력값(t)에 대한 LowerBound라고 한다. 
 
[1, 3, 3, 6, 7] 이라는 배열에서 5의 owerund는 30 3의 Loweround는 1 의 lowerBound는 0이다. LowerBound를 찾는 연산은 최악의 경우 $O (log n)$이다.

자, 그러면 제안한 전략대로 하면 정말 LIS에 해당하는 길이를 계산할 수 있을까? 위 전략에서 정렬된 리스트는 과거의 입력값을 최대한 활용하여 **이번 입력값이 리스트에 추가되는 경우가 많도록 만들어진 리스트**이다. 교체 메커니즘은 정렬 리스트에서 가장 큰 수보다 입력값이 작은 경우, 그 작은 수로 기존 수열의 하나의 큰 수를 교체한다는 것을 말한다. 그 교체될 위치를 임의로 $i$라고 하자. $L[i]$가 t로 교체되면 결과적으로 $L[i+1] - L[i]$의 차이는 커지게 된다. 그리고 **$L[i+1] - L[i]$의 차이가 커진다는 것은 다음 LowerBound를 계산시 $i+1$이 나올 경우가 많아진다는 의미다.** 이런 식으로 입력 값에따라 LowerBound 보다 하나 큰 스트 L은 정렬되어 있다고 볼 수 있고, 위치의 값을 작은 값으로 바꾸어 최대한 입력 값이 추가되도록 노력한다.

>예제 1
정렬된 리스트 $1, 5, 10$가 주어지고, 순서대로 $7, 8$을 입력해보자. 그러면 7의 LowerBound는 2이기 때문에 10이 7로 교체된다. 다음에는 자연스럽게 8이 추가되는데 앞선 교체 과정으로 입력값이 위치 3에 추가되도록 교체했기 때문이과정으로만 리스트를 변형하면 다음 호출시 정렬된 상태가 깨지지 않는다. 계속해서 LowerBound를 찾는데 이진 탐색을 사용할 수 있다. 

>예제 2
>정렬된 리스트가 $1,7, 10$ 주어지고, 순서대로 $3, 5, 9$이 입력해보자. 3의 LowerBound는 1이기 때문에 $1,3, 10$가 되고 $L[2]-L[1]$의 차이가 커진다. 덕분에 5가 입력될때 LowerBound는 2가 되고 $1,3,5$가 된다. 따라서 9는 자연스럽게 추가가 된다.

그 밖에 다른 예제를 보고 싶다면, 아래 링크에서 확인하자. 
 [예제](https://jason9319.tistory.com/113)

마지막으로 거듭 강조하지만 위 알고리즘은 LIS의 **길이**를 $O(nlogn)$만에 찾는 알고리즘이다. 진정한 LIS를 찾는것이 아니다.

## 최장공통부분수열(LCS; Longest Common Subsequence)

LCS란 Longest Common Subsequence의 약자로  최장 공통 부분 수열을 말한다. 수학에서는 수열이란 정수 숫자만 가지지만 여기선 숫자뿐만 아니라 문자열도 가지도록 확장하겠다. 

LCS를 구하기 위해 2개의 정수 또는 문자열 리스트를 받는다. 공통 부분 수열(Common Subsequence)이란 각 리스트가 만들 수 있는 부분 수열 중 같은 수열을 말한다. 이러한 공통 부분수열 중에 길이가 가장 긴 최장공통부분수열을 찾는게 목표다. 

```
{"ABCDGH","AEDFHR"} => "ADH"
{"AGGTAB","GXTXAYB"} => "GTAB"
{"MZJAWXU","XMJYAUZ"} => "MJAU"
```

단순하게 생각해보자. 한 리스트에서 만들 수 있는 부분수열의 갯수는 $2^n$이다. 따라서 두 개의 리스트에 부분수열을 모두 구하기 위해 $2*2^n$이 소요된다. 게다가 공통부분수열을 찾기 위해 각 부분수열을 비교하는데 $2^n * 2^n$이 필요하다. 모든 부분수열을 계산하지 말고 두 리스트를 원소 단위로 하나씩 읽어 불필요한 계산을 하지 않도록 하는 방법을 생각해보자. 

첫 번째(F)와 두 번째(S) 입력리스트가 주어 졌을때, 최장공통 부분수열을 계산하는 재귀함수 $lcs$의 점화식은 아래와 같다.
$$lcs(F,S) = maxLenth  \begin{cases} F[i] +\text{lcs(sub(F, i), sub(S, j))} & \text{if } F[i] = S[j]\\
\text{lcs(sub(F, i), S)\  || \ lcs(F, sub(S, j))} &  \text{otherwise} \end{cases},\ \ \forall [i, j] ({i \in index(F), j \in index(S)}) $$

입력 리스트가 두 개이기 때문에 인덱스 $i$, $j$를 활용한다. $index(F)$와 $index(S)$는 리스트의 index집합이며, 인덱스 $i$, $j$가 가질수 있는 값의 범위는 ${0 \leq i <  |index(F)|,\ 0 \leq j <  |index(S)|}$이다. 따라서, 가능한 인덱스 조합은 총 $|index(F)| * |index(S)|$개 이다. 우리는 모든 인덱스 조합을 하나씩 점화식에 적용할 것이다. 

한 인덱스 조합$(i, j)$에 대해서 ...
>공통부분을 찾은 경우($F[i]$ = $S[j]$)
>  리스트 F에서 $i$번째 값과 리스트 S에서 $j$번째 값이 같은 경우를 말하며, 올바른 공통 부분을 찾은 것이다. 공통부분을 추가하고 다음 lcs함수 호출 시 입력값으로 $F, S$의 서브리스트 $sub(F, i), sub(S, j)$를 넣는다. 

> 공통부분을 찾지 못한 경우($F[i] \ne S[j]$)
> 공통부분을 찾지 못하면, $i,j$에 대해 각각 1씩 더하는 두 가지 경우를 모두 고려하여 재귀함수를 호출한다. 한 경우는 다음 입력값으로 리스트 $F$의 서브리스트($sub(F, i)$)와 리스트 $S$를 넣고, 다른 경우는 반대로 리스트 F는 그대로, 리스트 $S$의 서브리스트($sub(S, j)$)를 넣는 것이다. 

 메모이제이션을 사용시, 위 알고리즘의 복잡도를 생각해보자. 모든 인덱스 조합을 따져보기 때문에 $O(|index(F)| * |index(S)|)$가 소요된다.

기존 점화식에서는 만들 수 있는 인덱스의 조합을 모두 사용하여 재귀호출을 반복하였고, 중복되는 호출은 캐시를 사용하여 시간을 절약했다. ($\forall [i, j] ({i \in index(F), j \in index(S)})$)

하지만 더 간결한 점화식을 아래와 같이 나타낼수 있다. 
$$lcs(F,S) =  \begin{cases} F[0] +\text{lcs(sub(F, 0), sub(S, 0))} & \text{if } F[0] = S[0]\\ \text{maxLength}[
\text{lcs(sub(F, 0), S),\ lcs(F, sub(S, 0))}]&  \text{otherwise} \end{cases}$$

새로 제안한 점화식을 보면 두 가지가 변경되었다. 첫번째 변경점은 모든 인덱스 조합에 대해서($\forall [i, j] ({i \in index(F), j \in index(S)})$))가 삭제 되었다. 기존 점화식에서 불필요하게 일어나는 중복 호출을 제거한 것이다. 이 점화식에 따르면 재귀호출을 할때마다 두 리스트의 맨앞에 원소로 조건 분기를 타게 된다. 두번째 변경점은 $maxLength$가 $F[0] \neq S[0]$때만 고려를 한다는 점이다.  그 이유를 아래에서 설명하겠다.
임의의 인덱스 조합 $i,j$에 대해서, 조건에 따라 LCS 후보군의 최장 길이는 아래와 같이 표현된다. 

>$F[i]=S[j]$ 
>$1+ min(|F|-i-1, |S|-j-1)$

>$F[i] \neq S[j]$
>$min(|F|-i-1, |S|-j)\ || \ min(|F|-i, |S|-j-1)$

위의 식을 정리하면 아래식이 성립한다. 
$$1+ min(|F|-i-1, |S|-j-1) >= (min(|F|-i-1, |S|-j),\ min(|F|-i, |S|-j-1))$$
즉 $F[i]=S[j]$ 조건을 만족하는 인덱스 조합으로 만드는 LCS 후보군은 반드시 최장 후보군이 된다는 이야기다. 따라서 $F[i] \neq S[j]$ 조건의 경우만 최장길이를 가진 후보군을 걸러내면 된다.

새로운 점화식의 장점은 메모이제이션을 쓰지 않는다는 점과 maxLenth비교를 국소적으로 하여 성능향상이 된다는 점이다. 

## [원주율 외우기](https://algospot.com/judge/problem/read/PI)

원주율을 몇만 자리까지 외우는 신동들이 존재한다. 이들이 이 수를 외우기 위해 사용하는 방법 중 하나는 숫자를 몇자리씩 끊어서 외우는 것이지 않다. 다. 숫자 3~ 5자리로 끊어서 외우는데, 외우기 쉬운 조각들로 외운다. 조각들의 난이도는 아래와 같다.

|경우|예|난이도|
|--|--|--|
|모든숫자가 같을때|333,5555| 1|
|숫자가 1씩 단조증가 또는 감소할때|23456, 3210|2|
|두 개의 숫자가 번갈아가며 나타날때|323, 54545|4|
|숫자가 등차수열을 이룰때|147, 8642|5|
|이외의 모든 경우|17912, 331|10|

원주율의 일부가 입력으로 주어질때, 난이도의 합을 최소화하도록 숫자들을 세 자리에서 다섯 자리까지 끊어 읽고 싶다. 최소의 난이도를 계산하는 프로그램을 작성하자.

예제 
* 12341234 => 2+2 = 4
* 11111222 => 1 + 1 = 2
* 12122222 => 4 + 1 = 5
* 22222222 => 2
* 12673939 => 10+4

점화식을 만드는데 힌트는 아래와 같다.
* 길이 3인 조각의 난이도 + 나머지 수열에 대한 최적해
* 길이 4인 조각의 난이도 + 나머지 수열에 대한 최적해
* 길이 5인 조각의 난이도 + 나머지 수열에 대한 최적해

그리고 중요한 점은 앞의 부분 수열을 어떤 식으로 쪼개서 난이도를 계산했든 나머지 수열의 최적해의 최적해 계산에는 무관하다. 즉 최적 부분 구조가 성립한다. 

## [양자화](https://algospot.com/judge/problem/read/QUANTIZE)
양자화(Quantization)를 한마디로 표현하면 더 범주가 큰 값들을 범주가 작은 값들로 표현한다는 것이다. 다르게 말하면 원형의 정확한 자료를 손실 압축하는 것으로도 이해할 수 있다. 예를 들어, 키가 161, 164, 178인 학생을 160대 2명, 170대 1명이라고 표현하는 것도 양자화의 한 방법이다.

본 문제는 입력으로 1000이하의 자연수들(1~1000)로 구성된 수열 $L$과 자연수$s$가 주어진다.  $s$는 양자화에 사용할 숫자 집합의 크기를 말한다. 
우리의 목표는 크기 $s$인 숫자 집합으로 수열 $L$을 양자화하여 원래 수열($L$)과의 편차제곱합을 최소로하는 것이다. 

예를 들어, 수열 [12345]가 주어지고, 두 가지의 자연수 2와 3으로 양자화를 한다고 하자. 만약 양자화 결과가 [22333]이면 원래 수열과 숫자별 오차는 [-1, 0, 0, 1, 2]가 되고 편차제곱합은 $(-1)^2+0^2+0^2+1^2+2^2= 6$ 이다. 비슷하게 양자화 결과가 [23333]이면 숫자별 오차는 [-1, -1, 0, 1, 2]가 되고 편차제곱합은 $(-1)^2+(-1)^2+0^2+1^2+2^2= 7$이다. 따라서 우리가 찾고자 하는 결과는 편차제곱합이 작은 수열 [22333]이 된다.

여기서 주의할 점은 위 예시에선 양자화에 사용할 자연수 집합이 2와 3으로 주어졌지만, 실제 문제에서는 집합의 크기가 $s$인 집합이 주어지지 않는다. 그러면서 편차제곱합을 최소로 하는 양자화를 찾아야 한다.

### 하던대로 하면 안된다.

먼저 양자화에 사용할 집합 $S$를 구성해보자. 문제에서 가정한 수열값의 범위가 최소 1에서 최대 1000이기 때문에 집합 $S$의 크기는 $_{1000}\mathrm{C}_{s}$가 된다.  만약 값의 범위가 정해져 있지 않다면, 집합 $S$를 만드는것도 거의 불가능에 가깝다. 자 그러면 어떤 방법으로 문제를 풀어야 할까?

### 답의 형태 제한하기

최적의 양자화 수열을 찾기 위해선 흩어져있는 수열 값 중에서 값이 차이가 작은 값들로 묶어 한꺼번에 양자화 하는 것이 유리하다. 차이가 작은 값들로 묶는 방법은 다양하지만 가장 간단한 방법은 주어진 수열을 정렬하는 것이다. 정렬을 하면 같은 수로 양자화될 숫자들이 인접하게 된다. 아래 예를 보자.
$$1,6, 744, 4, 777, 890, 755, 902, 897$$
위 수열을 오름차순 정렬하고 3개의 묶음으로 임의로 묶으면 아래와 같은 수열이 될 수 있다.
$${(1,4,6)}[4], (744, 755, 777)[759], (890, 897, 902)[896]$$

**하나의 묶음에서 편차제곱합을 최소로하는 양자화수는 바로 묶음에 있는 수들의 평균이다.** 따라서 사실 양자화에 사용될 숫자는 묶음으로 묶인 값들의 평균으로 정해진다. 이제 우리는 주어진 수열을 $s$개의 묶음으로 묶는 것에만 집중하면 된다. 참고로 수열의 길이가 $n$일때 경우의 수는 $_{n-1}\mathrm{C}_{s-1}$이다. 

그런데 정말 위 방법으로 하면 최적의 최소 편차제곱합을 찾을 수 있을까? 이것을 증명하고 싶다면 반대로 최대한 비슷하지 않은 값들로 묶음을 만들어 비교를 해보자. 
$$1,6, 744, 4, 777, 890, 755, 902, 897$$
$${(1, 755, 902)}[553], (4, 777, 897)[559], (6, 744, 890)[547]$$
위의 수열은은 임의로 차이가 큰 값들로 묶어본 경우이다. 묶음에 있는 수열들의 값의 차이가 최대한 작아야 평균과의 편차가 최소가 되는 것을 쉽게 알 수 있다. 

정리하여 양자화 문제를 풀기위한 점화식은 아래와 같다.
$$quantize(L, s) = \min_{pivot=1}^{pivot = |L|-s+1} [Error(G.L) + quantize(R.L, s-1)]$$

$G.L$(Grouped List)은 이번 차례에서 묶인 수열을 뜻하며 주어진 수열($L$)의 처음부터 $pivot$까지를 묶어서 만든다. $R.L$(Remained List)은 이번차례에 묶인 수열($G.L$)을 제외한 나머지 수열을 말하며, 수열($L$)의 $pivot+1$부터 나머지를 묶어서 만든다.
매 함수호출마다 묶이게 되는 수열($G.L$)에 대한 편차제곱합을 구하고 다음 재귀함수로 구해진 최소편차제곱합과 합산하여 이번 호출에서 최소 편차제곱합을 반환한다. 

비교해야할 대상수는 총 $|L|-s+1$이다. 즉 $|L|-s+1$개의 묶음이 가능하다는 말인데, 예를 들어 $s$가 2이고 수열[1, 4, 6, 744, 755]이 주어지면 만들어 질 수 있는 묶음은 아래와 같다. (총 4개)
$(1), (1,4), (1,4,6), (1,4,6,744)$

본 알고리즘에서는 한 번 함수를 호출하면 $Error$함수에서 $O(n)$이 소요되고 함수를 가능한 부분문제의 수 $O(ns)$ 만큼 호출한다. 따라서 전체 복잡도는 $O(n^2s)$이 된다.

$Error$함수에서 평균을 구하는 작업은 기본적으로 $O(n)$이지만 부분 합 기법을 사용하면 $0(1)$에 계산도 가능하다.

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbODgyMDM1MDc0LDEyNjcxMzQ0MzgsMTkxOT
UyNDcyMiwtMTQ3MTAwMDc2NywxMDAxMzY1NjUzLC0xMzczNDYx
ODc1LC0xMTA1NDIzMDYsMTEyNTE0NDgzNSw3NzM5ODM3NTYsLT
E4MzY2NjQzOTcsMTI0MDY3NTMyOSwxNzU1NjEwMDEsLTc0MTI0
ODYyNiw0OTMyMTkzMDEsLTMwMTEzNTY4LC0xMDY4OTczNTkzLC
0yMjQ4ODE3OTMsMTMwNTgzNTMyNSwtMjg1Mzg4MTU0LC0xNjM3
NDEwNzMyXX0=
-->