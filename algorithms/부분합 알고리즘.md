# Overview

N명의 시험 성적을 내림차순으로 정렬해둔 배열 scores[]가 있다고 하자. 우리는 a등에서 b등까지의 평균 점수를 계산하고 싶다. 
간단한 방법은 scores[a] 부터 scores[b]까지 순회하면서 각 수를 더하고 이를 b-a+1로 나누어 평균 점수를 구하는 것이다. 평균 점수를 딱 한번만 구할 것이면 이것으로도 충분하지만 평균 점수를 여러번 다양하게 계산할거라면 비효율적일 것이다. 바로 이럴때 유용하게 사용하는 것인 부분합 또는 누적합이다. 

# 부분 합

1차원 배열에서는 부분 합이란 배열의 각 위치에 대해 배열의 시작부터 현재까지 원소의 합을 구해 넣어둔 배열이다. 수학적으로 표현하자면 ...
$$partialSum[i] = \sum_{j=0}^{N-1} scores[j]$$

partialSum을 각 i에 대해서 미리 구해두면 특정 구간 [a,b]에서 구간의 합을 $O(1)$에 구할 수 있다.

# 부분 합으로 분산 계산하기 

부분 합을 잘 이용하면 합 혹은 평균 외에도 다른 값들을 쉽게 계산 할 수 있다. 예로 분산을 계산해보도록 하자. 배열 A[]의 구간 A[a] A[b]의 분산은 아래와 같은 식으로 정의 된다.

$$variance = \frac{1}{b-a+1} \sum_{i=a}^{b} (A[i]- m_{a,b})^2$$$$= \frac{1}{b-a+1} \sum_{i=a}^{b} (A[i]^2 - 2A[i] m_{a,b}+ {m_{a,b}}^2)$$$$= \frac{1}{b-a+1}( \sum_{i=a}^{b} A[i]^2 - 2 m_{a,b}\sum_{i=a}^{b}A[i]+ (b-a+1){m_{a,b}}^2)$$

마지막 항에서 가운데항과 오른쪽 항은 부분합을 이용해서 간단히 구할 수 있다. 문제가 되는것은 $A[i]^2$에 해당하는 왼쪽 항인데, 이것 또한 부분합을 계산할때 제곱의 부분합을 미리 만들어 저장하면 간단하다. 

# 2차원으로 확장

부분합은 1차원 배열에서만 쓸 수 있는 것이 아니다. 2차원 배열 $A[][]$이 주어질때, $A[x_1, y_1]$에서 $A[x_2, y_2]$까지의 직사각형 구간의 합을 계산해야 한다고 하자. 아래와 같이 부분 합 배열을 사용해 빠르게 구할 수 있다.

$$partialSum[x,y] = \sum_{i=0}^x \sum_{j=0}^y A[i,j]$$

다시 말해 $psum[x,y]$는 (0,0)에서 (x,y)까지 2차원 공간의 포함된 원소들의 합이다. partialSum[][]을 미리 계산해두면 배열에서도 우리가 원하는 구간 합을 쉽게 구할 수 있다. 

처음인 $A[0,0]$부터가 아닌 $A[x_1, y_1]$부터 $A[x_2, y_2]$까지 구간의 합을 구하는 방법을 생각해보자. 이 구간의 합을 구하는 방법은 $A[x_2, y_2]$의 구간 합에서 $A[x_1-1, y_1]$ 과 $A[x_1, y_1-1]$ 을 한번씩 빼고 $A[x_1-1, y_1-1]$을 더해 주는 것이다. 


$$sum([x_1,y_1], [x_2,y_2])=psum[x_2,y_2] - psum[x_1-1,y_2] - psum[x_2,y_1-1] + psum[x_1 -1, y_1-1]$$

# 합이 0에 가장 가까운 구간

양수와 음수가 모두 포함된 배열 A[]가 주어졌을때, 그 합이 0에 가장 가까운 구간을 찾는 문제를 풀어보자. 

|i  | 0 | 1| 2|3|4|5|6|7|8|9
|--|--|--|--|--|--|--|--|--|--|--|
|A[i]|-14|7|2|3|-8|4|-6|8|9|11|

정답 먼저 밝히자면 가장 0에 가까운 구간은 $A[2]$ ~ $A[5]$의 구간이다. 이런 구간을 찾는 한 방법은 A에 존재하는 모둔 구간을 순회하면서 각각의 구간의 합을 계산하는 것이다. 그러면 $N$ 길이에 대해서 $O(N^2)$의 시간이 걸리게 된다.

더 좋은 방법은 부분합을 이용하는 것이다. 
$A[i]$ ~ $A[j]$ 구간의 합은 다음과 같이 표현할 수 있다.
$$\sum_{k=i}^j A[k]= psum[j] - psum[i-1]$$

이 값이 0에 가깝다는 말은 psum[]의 두값의 차이가 가장 작다는 의미다. 주어진 배열에서 가장 가까운 두 값을 찾기 위해 간단한 방법은 psum을 정렬한 뒤 인전한 원소를 확인하는 것이다. 정렬은 $O(NlogN)$ 이고, 부분합을 계산하고 인접한 원소들을 

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQ2MjMzMzM0MiwxNDQ1NzIxNzM0LC0xNz
Q0MTU0MjQzLDE1ODE5OTIwMjksMTYzMzIzNDgyMSwxMDc3NDgx
ODc3LC0xODI5MTc0NTgwLDE0NTA5NDM5MDAsNjE2MzgxMDk4LC
0yMTEwODgzOTc1LDE4MjcyODM1NDJdfQ==
-->