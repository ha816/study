# 16장 비트마스크

컴퓨터는 기본적으로 이진수를 이용하기 때문에, 가끔씩 우리도 이진법을 이용하면  더 좋은 이점을 가질 수 있다. 

정수의 이진수 표현을 자료 구조로 쓰는 기법을 비트마스크(bitmask)라 한다. 비트마스크는 엄밀히 말해 자료 구조라고 할 수는 없지만 굉장히 유용히 사용된다. 

더 빠른 수행시간
: 비트마스크 연산은 O(1)에 구현되는 것이 많기 때문에, 다른 자료 구조보다 훨씬 빨리 동작한다. 물론 비트마스크를 사용한다는 것은 원소의 수가 많지 않다는 뜻이라 엄청나게 큰 속도 향상을 기대할 수는 없지만, 같은 연산을 굉장히 여러 번 수행해야 할 경우에는 작은 최적화도 큰 속도 향상을 가져올 수 있다.

더 간결한 코드 
: 다양한 집합 연산들을 반목문 없이 한 줄에 쓰기 때문에 적절히 사용하면 짧은 코드를 작성할 수 있다. 

더 작은 메모리 사용
: 비트마스크 같은 코드를 이용하면 같은 데이터를 더 적은 메모리에 표현할 수 있다. 


## 비트마스크 사용법

### 비트 연산자

![enter image description here](https://lh3.googleusercontent.com/proxy/q2jrYrA9rjj-TgLZeL6RMbq9RGKuo1E_ws3N_K1GO6iJP4iW40e5wrmiafZWGmNkuZ4KJfA9n5vRQaWl9tuXO1VEXPLr-C-V72qPgVmrAOQhpzBJ7Wf9cawRZxDziEc0a9yaqqyjtD8bDUBfOwzk3IRxew)

### 시프트 연산자

비트 열을 좌우로 지시한 만큼 이동시키는(shift) 연산자를 말한다.

#### 왼쪽 시프트 연산자 (<<)

ex) 150 << 2; 150 의 이진값을 왼쪽으로 2칸 시프트 합니다.

1 0 0 1 0 1 1 0 : 150
1 0 0 1 0 1 1 0 0 0 : 600

위와 같은 결과. 왼쪽으로 두칸 밀면서, 비게 되는 오른쪽 두칸은 0으로 채운다.
만약 데이터를 담는 자료형이 byte 타입이었다면, (8bit) 왼쪽으로 밀린 2개의 비트는 삭제된다. 그 결과 다음과 같은 결과가 된다.
0 1 0 1 1 0 0 0 : 88

#### 오른쪽 시프트 연산자 >>

ex) 150 >> 2; 150의 이진값을 오른쪽으로 2칸 시프트 합니다.

1 0 0 1 0 1 1 0
1 1 1 0 0 1 0 1 1 0

오른쪽으로 2비트 이동 한 후, 비게되는 왼쪽의 2개 비트는 1로 채워지고, 오른쪽에서 2비트 넘어간 부분은 삭제된다. 마찬가지로 8bit가 제한이라면 아래 결과가 나온다.

1 1 1 0 0 1 0 1

주의점 : 무조건 왼쪽에 비는 부분이 1로 채워지는 것이 아니라 비트 연산을 하기전에 최상위 비트(MSB; most significant bit)의 값으로 채워진다. 
  
#### 논리 오른쪽 시프트 연산자 >>>

150 >>> 2; 오른쪽으로 2비트 시프트 합니다.

1 0 0 1 0 1 1 0
0 0 1 0 0 1 0 1 1 0

자바에 추가된 논리 시프트는 오른쪽으로 밀면서 비게되는 **앞쪽 비트를 무조건 0으로 채워넣는 것이다.** 마찬가지로 밀려난 밀려난 오른쪽 2개비트 1 0 은 삭제된다.

### 비트마스크를 이용한 집합 구현

비트 마스크에서 가장 중요한 사용 사례는 집합을 구현하는 것이다. 이 표현에서 N비트 정수 변수는 0 ~ N-1 까지 정수 원소를 가질 수 있는 집합이 된다. 이때 원소 i가 집합에 속해 있는지 여부는 $2^i$을 나타내는 비트가 켜져있는지 여부로 나타낸다. 

예를들어, {1, 4,5,6,7,9}집합을 나타내는 정수는 754이다. 
$2^1 + 2^4 + 2^5 + 2^6 + 2^7 +2^9 = 10 1111 0010_2 =754$ 

>
```
/*공집합 또는 꽉찬 집합 구하기*/
int emptySet = 0;
int noneEmptySet = (1 << N) - 1; // 1뒤에 N개의 0이 있다. 여기서 -1을 하면 N개의 0이 1이 된다.

/*p번째 원소를 추가*/
int bitmask |= (1 << p); // 1을 왼쪽으로 p번 움직이면, p만 켜진 정수가 된다. 이 값을 기존 bitmask와 OR 연산을 하면 반드시 해당 비트는 켜지게 된다.
/*p번째 원소를 삭제*/

int bitmask &= ~(1 << p); // 1을 왼쪽으로 p번 움직이면, p만 켜진 정수가 된다. 여기서 보수(NOT) 처리를 하면 p만 꺼지고 나머지는 모두 켜진 bitmask가 된다. 이 bitmask와 AND 연산을 하면 반드시 해당 비트는 꺼지게 된다.

/*p번째 원소가 1인지 0인지*/
boolean exist = bitmask & (1 << p)

/*p번째 원소 토글(Toggle)*/
int bitmask ^= (1 << p);

/*두집합 연산*/
int bitmask = a | b; // 합집합
int bitmask = a & b; // 교집합
int bitmask = a & (~b); // 차집합 a에서 b가 아닌것들 남기기
int bitmask = a ^ b; // a와 b 중 하나만 포함된 원소
```

## 에라토스테네스의 체



## 극대 안정 집합(maximal stable set)

## 졸업 학기

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4NjQ3MTk4MjMsNjExNzc1ODcwLC0xND
M4MTYzODIwLC0xODcwNTc3NDUzLC0yNzUxNDA4NzgsLTY0MjIx
NDk1LDQxMTQxOTQ5MSwyMjA2NzY2MCwtNzE1MzQyODIzLC0zND
M4MjA3MDksMTg2NTU5ODQ4MCw5OTk5OTA2MTMsLTE2Mzc5NTgz
MTJdfQ==
-->