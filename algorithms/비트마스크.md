# 16장 비트마스크

컴퓨터는 기본적으로 이진수를 이용하기 때문에, 가끔씩 우리도 이진법을 이용하면  더 좋은 이점을 가질 수 있다. 

정수의 이진수 표현을 자료 구조로 쓰는 기법을 비트마스크(bitmask)라 한다. 비트마스크는 엄밀히 말해 자료 구조라고 할 수는 없지만 굉장히 유용히 사용된다. 

더 빠른 수행시간
: 비트마스크 연산은 O(1)에 구현되는 것이 많기 때문에, 다른 자료 구조보다 훨씬 빨리 동작한다. 물론 비트마스크를 사용한다는 것은 원소의 수가 많지 않다는 뜻이라 엄청나게 큰 속도 향상을 기대할 수는 없지만, 같은 연산을 굉장히 여러 번 수행해야 할 경우에는 작은 최적화도 큰 속도 향상을 가져올 수 있다.

더 간결한 코드 
: 다양한 집합 연산들을 반목문 없이 한 줄에 쓰기 때문에 적절히 사용하면 짧은 코드를 작성할 수 있다. 

더 작은 메모리 사용
: 비트마스크 같은 코드를 이용하면 같은 데이터를 더 적은 메모리에 표현할 수 있다. 


## 비트마스크 사용법

### 비트 연산자

![enter image description here](https://lh3.googleusercontent.com/proxy/q2jrYrA9rjj-TgLZeL6RMbq9RGKuo1E_ws3N_K1GO6iJP4iW40e5wrmiafZWGmNkuZ4KJfA9n5vRQaWl9tuXO1VEXPLr-C-V72qPgVmrAOQhpzBJ7Wf9cawRZxDziEc0a9yaqqyjtD8bDUBfOwzk3IRxew)

### 시프트 연산자

비트 열을 좌우로 지시한 만큼 이동시키는(shift) 연산자를 말한다.

#### 왼쪽 시프트 연산자 (<<)

ex) 150 << 2; 150 의 이진값을 왼쪽으로 2칸 시프트 합니다.

1 0 0 1 0 1 1 0 : 150
1 0 0 1 0 1 1 0 0 0 : 600

위와 같은 결과. 왼쪽으로 두칸 밀면서, 비게 되는 오른쪽 두칸은 0으로 채운다.
만약 데이터를 담는 자료형이 byte 타입이었다면, (8bit) 왼쪽으로 밀린 2개의 비트는 삭제된다. 그 결과 다음과 같은 결과가 된다.
0 1 0 1 1 0 0 0 : 88

#### 오른쪽 시프트 연산자 >>

ex) 150 >> 2; 150의 이진값을 오른쪽으로 2칸 시프트 합니다.

1 0 0 1 0 1 1 0
1 1 1 0 0 1 0 1 1 0

오른쪽으로 2비트 이동 한 후, 비게되는 왼쪽의 2개 비트는 1로 채워지고, 오른쪽에서 2비트 넘어간 부분은 삭제된다. 마찬가지로 8bit가 제한이라면 아래 결과가 나온다.

1 1 1 0 0 1 0 1

주의점 : 무조건 왼쪽에 비는 부분이 1로 채워지는 것이 아니라 비트 연산을 하기전에 최상위 비트(MSB; most significant bit)의 값으로 채워진다. 
  
#### 논리 오른쪽 시프트 연산자 >>>

150 >>> 2; 오른쪽으로 2비트 시프트 합니다.

1 0 0 1 0 1 1 0
0 0 1 0 0 1 0 1 1 0

자바에 추가된 논리 시프트는 오른쪽으로 밀면서 비게되는 **앞쪽 비트를 무조건 0으로 채워넣는 것이다.** 마찬가지로 밀려난 밀려난 오른쪽 2개비트 1 0 은 삭제된다.


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNDExNDE5NDkxLDIyMDY3NjYwLC03MTUzND
I4MjMsLTM0MzgyMDcwOSwxODY1NTk4NDgwLDk5OTk5MDYxMywt
MTYzNzk1ODMxMl19
-->