# 5장 알고리즘의 정당성 증명

5장에서는 알고리즘의 증명을 위에 흔히 사용하는 기법들을 간략하게 배운다. 여기서 나오는 기법은 여러 알고리즘 증명에도 쓰이기 때문에 열심히 공부해두자!

## 5.1 도입

해결해야할 문제가 간단할때는 알고리즘 설계가 쉽다. 하지만 문제가 복잡해지면  알고리즘이 과제를 제대로 해결하는지 파악 조차 어렵다. 

물론 단위 테스트를 통해 테스트 조건 안에서는 알고리즘에 문제가 있음을 증명할 수 는 있어도지만 테스트 조건  문제가 없음 증명할 수는 없다

따라서알고리즘의 정 증명을하기위해서는 각종 수학적인 기법을 사용해야 한다. 

알고리즘 증명을 공부해야하는 이유는 증명이 알고리즘을 유도하는 데 결정적인 통찰을 담고 있기 때문이다.  과정에 숙달이 되면, 처음보는 알고리즘이 잘 동작할지, 어떻게 그것을 증명해야 할지 직관이 생긴다. 

## 5.2 수학적 귀납법과 반복문 불변식

> 귀납법
> '여태까지 그래왔고 앞으로도 계속'
> 연역 논증과 함께 논리학의 두축을 이룬다.

>  수학적 귀납법(Mathematical Induction)
>  반복적인 구조를 갖는 명제들을 증명하는데 유용한 증명 기법
 
귀납법 증명은 크게 세 단계로 나누어진다.

- 단계 나누기
	- 증명하고 싶은 내용을 여러 단계로 나눈다. 
	- 각 단계의 의미를  정의한다.
- 첫 단계 증명(basic step)
	- 가장 첫 단계가 증명하고 싶은 내용을 성립하는 것을 보인다.
- 귀납 증명(Induction step)
	- 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다. 

### 귀납법 증명의 예

#### 도미노 문제
N개의 도미노가 순서대로 세워져 있을때, 과연 첫번째 도미노를 밀어서 넘어트렸을때, 마지막 도미노가 넘어질까? 물론 한 도미노가 쓰러지면 다음 도미노 역시 반드시 넘어진다.

- 단계 나누기
	- 특정 도미노 i를 한 단계로 정의
- 첫 단계 증명 
	- 첫 번째 도미노를 넘어트리면 두 번째 도미노도 넘어간다.
- 귀납 증명
	- i번째 도미노를 넘어트리면 i+1번재 도미노도 넘어간다.
	- 따라서 첫번재 도미노를 넘어트리면 마지막 N번째 도미노도 넘어간다.

#### 사다리타기 문제
사다리 타기 게임에서 맨 위 선택지를 선택하면, 제일 아래 선택지가 언제나 1:1 대응이 되는것을 안다. 이것을 귀납법을 이요하면 쉽게 풀 수 있다

- 단계 나누기
	- 텅빈 N개의 새로줄에서 시작해서 원하는 사다리가 될때까지 하나씩 가로줄을 그어간다고 하자. 가로줄 하나를 긋는 것을 단계라고 정의.
- 첫 단계 증명
	- 아무 줄도 긋지 않으면 항상 맨위의 선택지가 아래 선택지로 1:1 대응이 된다.
- 귀납 증명 
	- 가로줄을 그어 두 세로줄을 연결했다면, 두 세로줄의 결과는 뒤바뀐다. 두 세로줄의 결과가 바뀌어도 1:1대응은 변하지 않는다.  즉 아무리 줄을 그어도 결과의 1:1대응은 변하지 않는다.

### 반복문 불변식

반복문 불변식이란 반복문의 내용이 한번 실행될때마다 중간 결과가 우리가 원하는 답으로 가는길 위에 잘 있는지를 명시한 조건이다. 마지막에 정답을 계산하기 위해서는 다. 중간 계산이 항상 불변식을 만족해야 한다. 즉 앞서 공부한 귀납증명법과 같은 방법이다.

귀납증명법과 같이 반복문 불변식으로 정당성을 증명하는 방법은 아래와 같다. 

1) 반복문 진입시 초기 불변식이 성립함을 보인다.
2) 반복되는 계산과정에서도 불변식이 성립함을 보인다. 
3) 반복문이 종료된 후에도 불변식이 성립함을 보이면서, 반복문의 정당성을 증명한다. 

2번과 3번 과정을 합쳐 아래와 같이 나타낼수도 있다. 

1.  초기 조건(불변식): 초기에 만든 조건이 충족하는가?
2.  유지 조건(불변식): 초기에 만든 조건이 반복문이 실행되는 중에도 충족하는가?

```
// (*) 여기서 초기 불변식은 성립해야 한다.
while() {
	//반복문 시작
	...
	//반복문 끝
	// * 반복되는에서도 불변식은 성립해야 한다.
}
```

이진 탐색 검색 예제를 통해 반복문 불변식 성립을 증명해보자.
``` 
int binsearch(const vector<int> &A, int x ) {
	int n = A.size();
	int low = -1, high = n;
	// 불변식 1: low < high;
	// 불변식 2: A[low] < x <= A[high]
	while( low + 1 < high) {
		int mid = (low + high) /2;
		if(A[mid] < x){
			low = mid;
		} else {
			high = mid;
		}
		// 반복 과정에서도 불변식 1,2 모두 성립해야 한다.
	}
	// 마찬가지로 불변식 1,2 모두 성립해야 한다.
}
```
불변식 1($low < high$) 초기에 -1 < n이기 때문에 불변식 성립한다. 
반복문 안에서 mid는 low와 high의 평균이 되고, low나 high가 결국 mid값으로 바뀐다. 즉 반복 과정에서도 low < high는 유지가 된다. 
반복문의 종료 조건은 low + 1 >= high이고 끝까지 low < high가 유지 되었기 때문에 두 식을 합치면 low < high <= low+1이 된다. 즉 반복문이 종료되면 high = low +1이다.

불변식 2($A[low] < x <= A[high]$)은 초기에 A행렬이 정렬되어 있고 찾고자 하는 답 x는 당연히 행렬 A에 포함되어 있기 때문에 불변식이 성립한다. 반복문 안에서 mid는 low와 high의 평균이 되고, low나 high가 결국 mid값으로 바뀐다. 즉 반복 과정에서도 $A[low] < x <= A[high]$는 유지가 된다. 앞서 불변식 1에서 반복문이 종료되면 high = low +1가 성립하기 때문에  $A[low] < x <= A[low+1]$이 되고 우리가 알고 싶어하던 값 x의 행렬 A에서 위치는 low + 1 이다. 

다음으로 삽입정렬 예제를 통해 반복문 불변식 성립을 증명해보자.
``` 
void insertionSort(vector<int>& A) {
	for(int i = 0; i < A.size(); ++i){
	// 불변식1 A는 i-1번째까지 정렬되어 있다.
		int j = i;
		while( j > 0 && A[j-1] > A[j]){				
			swap(A[j-1], A[j])
			--j;
			불변식 2. A[j+1 ...i]의 모든 원소는 A[j]보다 크다.
			불변식 3. A[0...i]의 구간은 A[j]를 제외하면 정렬되어 있다.	
		}
	}
} 
```
반복문(for문) 진입 전에는 어떠한 계산과정이 없기 때문에 여기서는 초기 불변식 성립을 증명하지 않아도 된다. 
for문 진입 후 불변식 1은 초기에 0(1-1)번 까지 정렬이 되어 있다. 반복문 안에서는 새로운 반복문(while문)을 통해 계산이 반복된다. while문을 통해 반복적으로 계산된 행렬 A가 불변식1을 만족하는지 증명해야 한다. 
A[i]는 이미 정렬된 행렬(0 부터 i-1)에 올바르게 넣어야 할 값이다. 초기에 j는 i의 값과 같다. while문은 $j > 0$ 이면서  $A[j-1] > A[j]$ 일때 진입하고 j-1에 있는 값과 j에 있는 두 값을 바꾼뒤 j 값을 1만큼 줄인다. swap(A[j-1], A[j])를 통해 값이 뒤바뀐 후에는, j+1 ~ i 까지의 모든 값은 A[j] 보다 크다.(불변식 2) 또한, 다음 단계에 A[j]에 대해서 A[j]를 제외하면 모든 행렬값은 정렬되어 있다.(불변식3)
while문이 종료되면 결과적으로 0 부터 i까지는 정렬이 되어 있다. 
다음 단계인 i+1에서도 정렬이 될것이고 마지막으로 for문이 종료되어서도 마찬가지일 것이므로, 삽입정렬 알고리즘의 정당성을 증명이 되었다.  

## 5.3 귀류법

원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됨을 밝혀내는 증명 기법.

> 귀류법(歸謬法, 돌아갈 귀, 어긋날 류)
 수학과 논리학의 증명법 중 하나.  
 어떤 명제가 틀렸다고 가정한 후 추론했을 때, 모순이 발생함을 이끌어내어 가정이 거짓임을, 즉 처음의 명제가 참임을 증명하는 방법이다. 
  
수학에서는 이를 간접 증명이라고도 부른다. 일상 언어 생활에서도 은근히 자주 볼 수 있는 방식인데, ''그래, 네 말이 맞는다고 치자. 그렇게 했는데 문제가 생겼네. 따라서 니말이 틀렸어"식의 말이 다름 아닌 귀류법으로 상대의 주장에 문제가 있음을 주장하는 방식이다.  

### 문제 책장 쌓기

책장을 여러개 쌓아올리려고 한다. 각 책장마다 버틸수 있는 최대 무게 $M_i$와 자신의 무게 $W_i$가 있다. 책장을 가장 높이 쌓는다면, 어떻게 해야 할까?

단 i번째 책장 위에 쌓은 모든 책장의 집합을 above(i)라고 했을때 아래 식이 성립해야 한다. 
$$∑_{j∈above(i)}W_j <= M_i$$

즉 i번째 책장위에 모든 책장(i번째 책장 스스로는 제외)의 무게의 합을 견딜 수 있어야 한다는 말이다.

문제를 풀기 위한 첫 발걸음은 책장의 순서를 결정하는 것. 직관적으로 무게가 무겁고 튼튼한 책장을 아래로 두는 것이 최고일것으로 보인다. 정답은 $M_i+W_i$가 큰것부터 아래로 두어야 한다는 것이다. 과연 그럴까? 귀류법으로 증명해보자.

-> $M_i+W_i$가 큰 책장을 아래로 두면 가장 많은 책장을 쌓을 수 있다.
-> 그래? $M_i+W_i$가 작은 책장을 아래로 두면?
-> $M_i+W_i$가 작은 책장을 아래에 두고 전개하니 모순이 발생하네!
-> 그래.  $M_i+W_i$가 큰 책장을 아래로 두어야 겠네.

임의의 책장 A와 B가 있다고 하자. 책장 A는 책장 B보다 튼튼해서 아래와 같은 식이 성립한다. $$M_A+W_A > M_B+W_B$$

주장(책장 A가 B보다 아래 있어야 한다)과는 반대로 책장 B를 책장 A보다 아래에 둔다고 가정해보자. 책장 B가 책장 A보다 아래에 있다는 것은 아래 식이 성립한다. $$M_B >= W_A + ∑_{j∈above(A)}W_j$$ 

위의 두식을 가지고 식을 추론해보자. 
$$ M_A + W_A > M_B + W_B $$
$$M_A > M_B + W_B - W_A $$
$$M_A > M_B + W_B - W_A >= (W_A +∑_{j∈above(A)}W_j) + W_B - W_A$$
따라서 $$M_A > ∑_{j∈above(A)}W_j + W_B$$

즉 책장 A가 책장 B의 무게를 포함하여 A위의 모든 상자들을 쌓을 수 있다는 말이다. 우리는 책장 B를 책장 A 아래에 둔다고 가정했지만, 가정과 다르게 책장 A가 B 아래에 있을수 있다는 것을 밝혔다. 
 귀류법으로 반대되는 상황을 가정했지만 그것이 잘못된 것을 밝혔기 때문에 원래의 주장 $M_i+W_i$가 큰 책장을 아래로 두면 가장 많은 책장을 쌓을 수 있다는 주장이 옳은 주장인 것을 밝혔다.

## 5.4 다른 기술들

### 비둘기집의 원리
비둘기집 원리는 간단하게 말해서  n+1개의 물건을  n개의 상자에 넣은 경우, 최소한 한 상자에는 그 물건이 반드시 두 개 이상 들어있다는 원리를 말한다. 보통 비둘기와 비둘기집의 형태로 비유되어 쓰이기 때문에, 비둘기 집의 원리라고 불린다.

* 어떤 집단에 367명(윤년의 2월 29일도 고려해야 하기 때문)이 있으면 생일이 같은 사람이 반드시 1쌍 이상 존재한다.


