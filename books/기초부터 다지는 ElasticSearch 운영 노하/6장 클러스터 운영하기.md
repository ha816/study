# Overview

클러스터 운영하기 

ES 클러스터를 구축한 후에는 안정적으로 운영하기 위한 운영 이슈들이 생겨난다. 예를 들면, ES 버전 업그레이드, 샤드 배치 방식 변경, 인덱스의 댜앙한 설정값 변경등이 있다. 이번 장에서는 이렇게 클러스터 운영과 관련한 다양한 주제들을 살펴보자. 이번 장에서 다룰 내용은 아래와 같다. 

* ES 클러스터 버전 업그레이드
* 인덱스의 샤드 배치 방식 변경
* 운영 중 온라인으로 클러스터나 인덱스 설정 변경하기 
* 인덱스 API 활용하기
* 템플릿 활용하기

# 버전 업그레이드

ES의 새로운 버전은 빠르게 공개된다. 새로운 기능이 추가되고 이전 버전의 버그도 수정된다. 운영 중이 ES의 치명적인 버그가 포함되어 있거나, 꼭 필요한 새로운 기능이 추가되었다면 버전 업그레이드가 필요하다. 

ES에서 버전 업르게리드를 하는 방법은 크게 두 가지가 있다. 

* Full Cluster Restart - 모든 노드를 동시에 재시작하는 방식이며, 다운 타임이 있지만 빠르게 버전 업그레이드가 가능하다.
* Rolling Start - 노드를 순차적으로 한대씩 재시작한다. 다운 타임은 없지만 노드 개수에 따라서 업그레이드에 소요되는 시간이 길어질 수 있다.

Rolling Start 방식은 아래와 같은 순서로 작업 순서를 따라가야 한다. 

* 클러스터내 샤드 할당 기능 비활성화
* 프라이머리 샤드와 레플리카 샤드 데이터 동기화
* 노드 한 대 버전 업그레이드 이후 클러스터 합류 확인
* 클러스터 내 샤드 할당 기능 활성화
* 클러스터 그린 확인

레플리카 샤드가 있는 상태에서 한대에 노드에 장애가 생겨서 클러스터에 제외가 되어도 해당 데이터 노드가 가지고 있던 샤드를 다른 데이터 노드에 재분배하는 것을 알 수 있다. 하지만 ES의 버전 업그레이드 작업은 장애가 아니라 의도적으로 노드를 클러스터에서 제외하는 것이기 때문에, 해당 노드가 클러스터에서 제외되어 있는 동안을 장애 상황으로 판단하고 샤드를 재분배해서는 안된다. 

업그레이드 때문에 클러스터에서 제외된 노드의 샤드를 다른 데이터 노드로 재분배하는 것은 네트워크 비용이나 디스크 I/O 측면에서 큰 낭비다. 

클러스터내에서 샤드가 많으면 많을 수록, 또 샤드의 크기가 크면 클 수록 더 심한 낭비가 된다. 이러한 불상사를 피하기 위해서 업그레이드를 진행하는 동안 클러스터 내 샤드 할당 기능을 비활성화해야 한다. 

## 클러스터 내 샤드 할당 기능 비활성화

아래와 같은 코드를 통해 클러스터 API 설정을 수정하여 진행한다.

```
curl -X PUT "localhost:9200/_cluster/settings?pretty" -H Content-Type application/json -d
{
	"persistent": {
		cluster.routing.allocation.enable: none
	}
},
{
	"acknowledged": true,
	"persistent": {
		"cluster": {
			"routing" : {
				"allocation" : {
					enable : none
				}
			}
		}
	}
}
```

클러스터 내의 샤드 할당과 관련된 설정은 cluster.routing.allocation.enable이다. 이 값을 none으로 설정하여 샤드를 재분배 하지 않도록 한다.

위와 같이 샤드 할당 기능을 비활성화하면 노드 프로세스를 중지하여 클러스터에서 제외되더라도 해당 노드에 포함된 샤드를 다른 노드로 재분배하지 않는다. 

두번 째로 현재 배치해 놓은 프라이머리 샤드와 레플리카 샤드간의 데이터를 똑같은 형태로 맞춘다. 두 샤드가 가지고 있는 문서가 완벽히 일치해야 클러스터에서 노드가 갑작스럽게 제외되더라도 데이터의 정합성을 보장할 수 있기 때문이다. 

# 샤드 배치 방식 변경

ElasticSearch는 대부분 자동으로 샤드를 배치하지만 경우에 따라서 샤드 배치 방식을 변경해야 할때가 있다. 예를 들어 특정 노드에 장애가 발생하여 생성된 unassigned 샤드들에 대한 재할당 작업이 5회이상 실패하거나 일정기간이 지난 오래된 인덱ㅅ의 샤드를 특정 노드에 강제로 배치해야하는 경우다. 

이번 절에서는 수동으로 샤드의 배치 방식을 변경하는 법을 알아보자. 

| 옵션|설명  |
|--|--|
|reroute  | 샤드 하나하나를 특정 노드에 배치할때 사용|
|allocation  | 클러스터 전체에 해당하는 샤드 배치 방식을 변경할때 사용|
|rebalance  | 클러스터 전체에 해당하는 샤드 재분배 방식을 변경할때 사용한다.|
|filtering | 특정 조건에 해당하는 샤드들을 특정 노드에 배치할때 사용한다.|

## reroute

먼저, reroute는 샤드 하나하나를 개별적으로 특정 노드에 배치할때 사용한다. 제어할 수 있는 동작은 샤드 이동, 샤드 이동 취소, 레플리카 샤드의 특정 노드 할당이다. 샤드 이동은 인덱스 내에 정상적으로 운영중인 샤드를 다른 노드로 이동할때 사용한다.

```
{
	"commands": [
		{
			"move": {
				"index": "user",
				"shard": 1,
				"from_node": "data-1.es.com",
				"to_node": "data-2.es.com",
			}
	]
}
```

위 명령어를 보면, 이동할 샤드가 속한 인덱스 이름이 user 인덱스 임을 알 수 있다. 인덱스 이름을 잘못 넣으면 잘못된 샤드가 넘어가니 조심해야 한다. 

shard 필드에는 이동할 샤드 번호를 넣는다. from_node에는 현재 이동할 샤드가 배치되어 있는 node를 나타내며, to_node는 최종적으로 이동될 node를 말한다. 

위에서 기입한 정보가 이상이 없다면 정상 처리가 된다.

책의 내용으로는 1번 샤드가 data-2.es.com으로 이동이 되지만 원래 data-2.es.com이 가지던 0번 샤드가 다시 자동적으로 data-1.es.com 노드로 이동한다. 이것은 디스크 사용량을 기준으로 샤드를 할당하는 기능이 기본으로 활성화되어 있기 때문이다.

Elasticsearch는 노드마다 균등하게 샤드를 배치하기 때문에 수작업으로 샤드를 이동시키면 균형을 맞추기 위해 자동으로 다른 샤드를 하나 디오시킨다. move 명령어를 사용할때 이부분을 유념하자. 


move 명령어 대신 cancel을 넣으면 재배치 중인 샤드의 이동을 취소할수도 있다. 

unassigned 샤드에 대해 allocate_replica 명령을 사용할 수도 있다. allocate_replica 명령은 레플리카 샤드를 배치하기 위한 명령이며 이 명령으로 unassgsigned 상태의 샤드들을 start로 변경할 수 있다. 

```
{
	"commands": [
		{
			"allocate_replica": {
				"index": "user",
				"shard": 1,
				"node": "data-1.es.com"
			}
	]
}
```

index는 레플리카 샤드를 배치할 대상 샤드가 속한 인덱스 이름이다. shard는 레플리카 샤드를 배치할 대상 샤드 번호이다. node는 레플리카 샤드를 배치할 노드 이름이다. 

allocate_replica 명령은 이미 배치된 레플리카 샤드에는 사용할 수 없고, 배치되지 않은 레플리카 샤드에 대해서만 사용이 가능하다. 

즉 unassgined 상태의 레플리카 샤드가 있는 경우만 사용할 수 있다. 이렇게 샤드가 배치되지 않은 상태로 unassgined 상태로 남아있다는 것은 클러스터내의 샤드를 배치할 수 없는 상황이 발생했다는 의미이다. 이런경우 샤드 배치 실패의 원인을 제거하고 위 명령을 진행하면 된다. 

그렇다면 어떤 경우에 실패하게 될까?

가장 빈번한 경우는 노드들의 디스크 사용량이 높아지는 경우다. 이런 경우 아무리 샤드 배치를 시도해도 배치할 수 있는 노드가 없기 때문에 실패한다. 이럴땐 불필요한 인덱스를 제거하거나 데이터 노드를 증성하여 용량을 확보하는것이 좋다. 

## allocation

앞서 다룬 reroute가 인덱스의 특정 샤드를 재배치한다면, allocation은 클러스터 전체에 적용된다. 

allocation은 클러스터 내의 샤드 배치 기능을 활성/비활성화 하는 기능이 가장 많이 쓰인다. 

```
{
	"persistent" : {
		"cluster,routing.allocation.enable:"none"
	}
}
```

자세한 옵션을 살펴보자. 

* nono
	* 모든 샤드 배치 작업을 비활성화한다.
* all
	* 모든 샤드의 배치를 허용하며 노드간 샤드 배치가 진행된다. 클러스터에 새로운 노드가 증설되면 기존 노드가 가지고 있는 샤드들을 프라이머리와 레플리카 샤드 구분없이 나눠준다. 또 노드 한대가 클러스터에서 제외가 되면, 제외된 노드가 가지던 샤드를 모두 다른 노드에 배치한다. 기본값이다.
* primaries
	* all과 유사하지만 배치 대상 샤드를 프라이머리로만 한정한다. 즉 레플리카 샤드는 한번 배치된 이후로 노드를 증설해도 재배치 되지 않는다.
* new_primaries
	* 새롭게 추가되는 인덱스의 프라이머리 샤드만 재배치한다. 새롭게 투입된 노드들에 기존 인득세들의 샤드가 배치되지 않으며, 투입 이후 새로운 추가되는 인덱스에 대해서만 프라이머리 샤드가 배치된다.
* null
	* 옵션을 초기값으로 재설정할 때 사용한다. 

## rebalance

allocation은 노드가 증설되거나 클러스터에서 노드가 이탈했을때 동작과 관련된 설정이다. rebalance는 클러스터 내의 샤드가 배치된 후에 특정 노드에 샤드가 많다거나 배치가 고르지 않을때 이동과 관련된 설정이다. 

reroute와 rebalance는 정상적으로 배치가 된 상태에서 노드간 샤드를 주고받는는다는 점에서는 유사한 동작이다. 

```
{
	"persistent": [
		
	]
}
```



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MDY0NjIzMTAsMjEzMTI1Mzk4LDEzMj
QzMDUwNjYsMTYzOTM4MDgwLDc2OTg3NDI1OSwtMTAyODA1NzEw
MiwtMTQwNDcwODg2MCwtMTE0MTk3NDY2OSwtNjQ1ODQyODkzLC
05NTY5ODg2MTgsMTA4NzEwNjI4Nyw3MzA5OTgxMTZdfQ==
-->