# Neo4j

Neo4j는 그래프 데이터베이스 관리 시스템이다. 

* 트랜잭션 처리 중심의 ACID 지원
	* Neo4j는 ACID를 만족한다.
* 온라인 트랜잭션 처리에 적합한 데이터베이스(OnLine Transaction Processing; OLTP) 
* 확장형으로 설계된 DB
	* Neo4j는 OLTP 작업을 처리하기 위해 중요한 확장성, 고가용성을 지원해야 한다. Neo4j는 데이터베이스 서버 인스턴스들로 클러스터를 구성하면 이런 고가용성을 만족할 수 있다.
* 선언적 질의어 - 사이퍼
	* 사이퍼는 Neo4j에서 제공하는 질의어이다. 사이퍼는 모든 데이터베이스 사용자가 데이터베이스 관리 시스템을 이해하고 실행할 수 있게 해주는 선언적 패턴 매칭 질의어이다.

> 온라인 트랜잭션 처리(OnLine Transaction Processing; OLTP)
> OLTP는 일반적인 비즈니스 작업 제어 및 실행에 적합하다. 
> 온라인 시스템 환경에서는 데이터베이스 관리 시스템로 질의가 웹 요청과 응답 시간의 차이가 밀리초 단위 사이로 이루어져야 한다.

>온라인 분석 처리(OnLine Analytical Processing; OLAP)
>집계와 관련된 복잡한 처리를 주로 하며 계획, 의사결정에 도움이 되는 시스템이다. 
>관련 데이터의 양에 따라 응답 속도가 다르다. 

# Basic Component

![enter image description here](http://dh.aks.ac.kr/Edu/wiki/images/8/88/Neo4j_model.JPG)

Nodes
: 일반적으로 개체 정보를 저장하는데 사용한다. 개체 정보는 properties로 key/value 쌍으로 이루어진다.

Relationships
: 노드간 명시적 연결을 나타내는데 사용한다. 관계는 유형, 시작 노드 및 종료 노드 그리고 방향이 있다. 
관계를 통해 엔터티를 구조화 할 수 있다. 관계형 데이터베이스에서는 미리 계산된 조인과 유사하다. 

Properties
: 노드와 관계 모두 속성을 담고 있는 컨테이너이며, 이름/값 쌍으로 구성된다. 속성은 관계의 세기, 강도 또는 품질을 검증하는데 사용되며, 찾고 있는 패턴을 평가하기 위해 질의/순회 중에 사용할 수 있다. 

Labels
: 레이블은 노드를 분류하는 방법이다. 라벨이 붙은 노드들은 이 노드들만의 하위 그래프를 구성하게 된다. 이렇게 레이블을 할당하여 사용자는 데이터 모델을 보다 직관적으로 만들 수 있다. 


# Graph DataBase Modeling

기존 관계형 시스템에서는 개체관계(ER ) 다이어그램을 통해 모뎅링을 했었다. 오늘날의 애자일 개발 방법론에서는 문제 또는 도메인 설명을 사용자 스토리라고 한다. 좀 더 나중에 해당 이야기는 다루어보겠다. 

기본적으로 ER 다이어 그램을 그릴때는 아래와 같은 규칙을 이용한다. 

* 명사적 설명으로 엔티티를 추출
* 형용사적 설명으로 속성을 추출
* 동사적 설명으로 관계를 추출

ER 다이어그램은 실세계의 모델에서 비즈니스 도메인 또는 사용자 요구를 추출하는 장점이 있다. 하지만 반대로 몇 가지 단점도 갖고 있다. 

ER 다이어그램을 이용해 관계를 명명할 수는 있지만, **개체 간의 방향성이 없는 관계만을 허용한다.** 그래프 데이터베이스에서는 개체간의 다양한 관계와 방향성을 허용하지만 관계형에서는 그렇지 않다.

관계형에서는  N:N 관계를 구현할 수 없기 때문에 두 테이블을 서로 연결하는 개체를 생성해야 한다. 이를 조인 테이블이라고 하면 N:N 관계를 연결하려는 모든 쿼리에서 불필요하게 발생한다. 이런 테이블은 개발자 입장에서 설계를 복잡하게 만든다.

## Good Pattern

### 질의 가능한 설계

Neo4j와 같은 그래프 데이터베이스 관리 시스템은 모델을 질의에 의해 구현할 수 있다. 모델링은 데이터에 대해 물어보고 싶은 질문에 따라 다르며, 이 질문이 디자인과 모델을 주도할 것이다. 가장 중요한 것은 사용자 이야기, 질문에 집중하는 것이다.

`내가 일하는 회사의 직원 중 누가 나와 비슷한 기술을 갖고, 지식을 교환할 수 있는지 알고 싶다.`

위 질문에서는 모델에 포함해야하는 엔티티와 엔티티간의 관계에 대해 이야기하고 있다. 직원과 기술이 엔티티가 될 수 있고 비슷한 기술이 관계가 될 수도 있다. 

### 사용 사례를 이용한 관계 정렬

질의 기능을 모델링하고 질의가 모델을 결정 수 있는 방법 중 하나는 다양한 사용 사례에 대해 노드 간에 가질 수 있는 서로 다른 관계 유형을 사용하는 것이다. 

사용 사례(use cases)는 여러 시나리오가 모인것으로, 개발자와 고객 사이에 요구를 이해하는 수단이다. 많은 훌륭한 데이터베이스 모델에서 **서로 다른 사용 사례에 대해서 2개의 동일한 노드사이에 복수 관계를 사용하고 있다.** 

왜냐하면 특정 사용 사례를 위해 두 노드 사이에 관계를 추가하는 것이 모델을 추가하는 복잡성에 비해 간단하기 때문이다. 추가 생성하거나 더 구체화해야하는 테이블이나 스키마가 없고, 추가될 조인도 없다. 

관계와 사용 사례를 조정할때 조심해야할 핵심 개념은 관계 유형의 네이밍 룰이다. 일반적은 권장 사항은 HAS_A나 IS_PART_OF와 같은 일반적인 이름을 사용하되, 보다 구체적으로 설명할 수 있는 이름을 사용하는 것이 좋다. 

### 다항 관계 찾기

어떤 경우에는 사용자 스토리를 처음 읽었을때 최적의 모델링 결과를 얻지 못하는 경우가 있다. 여러 이유가 있겠지만 흔히 보게 되는 것은 소위 다항 관계(n-ary)일때다. 

**다항관계는 특정한 하나의 개념을 하나 이상의 개념에 관계를 연결시키는 것이다. 이 관계들은 두 가지 이상(n개)의 사물이나 개념을 제공할 수 있기 때문에 다항 관계라고 한다.** 

```
Recod Company - finaces -> Song <- writes - Song author 
```

### 세밀한 노드

전형적인 그래프 모델링 패턴은 세밀한 패턴(granulate pattern)이라 불린다. 그래프 모델링에서는 관계형 모델에서 사용했던 것보다 훨씬 높은 수준의 세분화된 데이터 모델을 사용하는 경향이 있다. 

관계형 모델에서는 데이터베이스 정규화라는 프로세스로 세분화한다. 정규화 과정은 일반적으로 3차가 될때까지 작은 테이블 구조를 생성한다. IT 업계에서는 3차 정규형에 도달하면 표준화가 된것으로 간주한다. 

관계형 데이터 모델은 질의시 테이블 조인이 발생하고, 조인 연산에 많은 비용이 들 수도 있다. 이러한 이유 때문에 DBA는 데이터를 비정규화하는 경향이 있다. 하지만 비 정규화를 하게 되면 관리하기 까다로운 데이터 중복 문제가 발생한다. 

그래프 모델에서는 얇은 노드와 관계를 생성하는 경향을 볼 수 있는데, 이런 얇은 노드와 관계는 작은 속성을 갖는다. 즉, 노드와 관계는 매우 잘게 쪼개져 있고, 세분화 되어있다. 그렇기 때문에 그래프 모데링에서 수행하는 정규화는 악명 높은 조인 작업을 쉽게 수행하기 때문에 비용이 훨씬 적게 든다. 

패턴과 관련히 모델링 중 스스로에게 아래와 같은 질문을 던지게 된다.
```
이것을 속성으로 유지해야 하는가? 아니면 속성이 노드가 되어야 하는가?
```

비유를 들자면, 맥주의 알코올 비율을 맥주 브랜드의 속성으로 할지 아니면 알코올 비율을 노드로 분할할지 고민하는 것이다. 

```
BeerBrand	<- brews -	Brewery
{Name: Orval
Alcohol%: 6.2}
```

```
Alcohol%	<- has_alc_perct -	BeerBrand	<- brews -	Brewery
{Name: 6.2}						{Name: Orval
								Alcohol%: 6.2}
```

위 두 모델 중 어느것ㄷ이 맞는다고 생각해 본다면 둘다 맞다. 중요한 것은 어떤 모델이 적합한지 확인하기 위해서는 질의를 확인해보아야 한다는 것이다. 

* 그래프 탐색 중에 알코올 비율을 평가할 필요가 없다면, 노드의 속성으로 유지하는 것이 좋다. 이렇게 함으로써 모델을 좀더 단순히 유지할 수 있다. 그리고 모든 사람은 단순함을 높이 평가한다.
* 그래프 탐색 중에 특정 맥주 브랜드의 알코올 비율을 평가해야 하는 경웅에는 해당 브랜드를 노드 범주로 분리하는 것이 좋다. 노트를 탐색하는 것이 종종 모든 경로에서 속성을 평가하는 것보다 쉽고 빠르다. 

실제로는 색인을 사용해 접근법을 발전시켰다.

### 필요한 경우 그래프 색인 기능 사용하기

대부분 색인 기술이 그래프 / 트리 구조를 사용한다. 세밀한 패턴을 적용해 그래프 내부의 데이터 모델에 대해 자연스러운 인덱스를 만들 수 있다. 

맥주 알코올 비유로 들자면 알코올 비율 값들이 그래프 색인의 후보가 될 수 있다. 
```
Alcohol% -- precedes -> Alcohol% -> ... ->
{name: 6.1}			{name: 6.2}
```

이런 유형의 인덱스 구조는 그래프 구조에서 시계열 데이터를 처리하는데 자주 사용된다. 이 경우, 시간의 나열(timeline) 보다 시간 트리(time tree)를 더 많이 만든다. 그리고 모든 노드 또는 관계에서 시간을 속성으로 사용하는 대신, 그래프 데이터를 이 트리에 연결한다. 

## Bad Pattern

모든 유형의 데이터 베이스 모델링과 마찬가지로 그래프 데이터베이스도 피해야 하는 몇 가지 함정이 있다. 나쁜 모델링을 모두 알 수는 없지만, 나쁜 모델링을 이끌어낼 수 있는 유형의 실무 방식에 대해 감을 잡을 수 있다.

### 풍부한 속성 사용하기

그래프 데이터베이스 시스템에서는 매우 세분화된 모델을 사용하는 것이 가장 좋은 방법이다. 하나의 노드에서 너무 많은 속성을 가지고 있으면 좋지 않다. 

### 여러 가지 개념을 나타내는 노드

서로 다른 관심사나 개념이 모델에서 적절하게 분리되지 않는 경우다. 예를 들어, 국가, 언어, 통화와 같은 다수의 목잡한 개념을 가진 노드는 분리하는 것이 현명할 것입니다.

### 연결되지 않은 그래프

그래프는 엔티티간의 연결에 대한 것이고 그래프 데이터베이스의 강력함은 노드간 관계로 이루어지는 것이다. 관계가 없는 노드들은 아무 의미가 없다. 

### 고밀집 노드 패턴

데이터 세트에서 발생하는 매우 흥미로운 문제는 그래프의 일부가 모두 같은 노드에 연결되는 경우다. 고밀집 노드 도는 슈퍼 노드라 불리는 이러한 노드는 그래프 순회에서 문제가 된다.

**그래프 순회 관점에서 보면 많은 관계를 가지고 있는 슈퍼 노드는 다음 관계가 무엇인지를 결정하기 위해 그 노드에 연결된 모든 관계를 순서대로 평가해야 하기 때문에 성능상 문제가 될 수 있으며 반드시 피해야 한다.** 

Neo4j에서 고밀도 문제를 다루기 위해 여러 전략을 사용하고 있다. 하지만 대부분의 경우, 직접 적절한 모델을 적용함으로써 이러한 기술적 위험을 피하는게 좋다.

하나의 노드에 최대로 관계를 가질 수 있는 관계의 수를 제한하는 것을 팬 아웃(Fan-Out)이라 한다. 팬아웃을 구현하기 위해서 


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYxOTUzMjA0NCw0NDU0ODcwODAsMTI1NT
AzMTA1NSwtMTQ2Mjc2OTc2NywxMjkxMTM4MjYxLDE1MjY0Njk4
NDUsMjQyMzU2MDQyLC0xODk3Mzg2NTE4LDkzNjU5NjkzOCwxNj
g0NDY3NjIwLC0yMDYyODczMDM2LDEwODE5MzM5MjQsLTIwOTIw
MTEwMzAsLTQwMTE1MTc5Nyw1MDUxMDA4NzksMTkyNjQzMTMzMC
wtMjYxNjM1OTI3LDE2NDM3MjcxMTksLTE2MjcwODI2MzUsLTE4
ODI2NDI5MDFdfQ==
-->