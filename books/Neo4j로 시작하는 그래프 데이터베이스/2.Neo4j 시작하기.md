# Neo4j

Neo4j는 그래프 데이터베이스 관리 시스템이다. 

* 트랜잭션 처리 중심의 ACID 지원
	* Neo4j는 ACID를 만족한다.
* 온라인 트랜잭션 처리에 적합한 데이터베이스(OnLine Transaction Processing; OLTP) 
* 확장형으로 설계된 DB
	* Neo4j는 OLTP 작업을 처리하기 위해 중요한 확장성, 고가용성을 지원해야 한다. Neo4j는 데이터베이스 서버 인스턴스들로 클러스터를 구성하면 이런 고가용성을 만족할 수 있다.
* 선언적 질의어 - 사이퍼
	* 사이퍼는 Neo4j에서 제공하는 질의어이다. 사이퍼는 모든 데이터베이스 사용자가 데이터베이스 관리 시스템을 이해하고 실행할 수 있게 해주는 선언적 패턴 매칭 질의어이다.

> 온라인 트랜잭션 처리(OnLine Transaction Processing; OLTP)
> OLTP는 일반적인 비즈니스 작업 제어 및 실행에 적합하다. 
> 온라인 시스템 환경에서는 데이터베이스 관리 시스템로 질의가 웹 요청과 응답 시간의 차이가 밀리초 단위 사이로 이루어져야 한다.

>온라인 분석 처리(OnLine Analytical Processing; OLAP)
>집계와 관련된 복잡한 처리를 주로 하며 계획, 의사결정에 도움이 되는 시스템이다. 
>관련 데이터의 양에 따라 응답 속도가 다르다. 

# Data Modeling

## 기본 구조

![enter image description here](http://dh.aks.ac.kr/Edu/wiki/images/8/88/Neo4j_model.JPG)

Nodes
: 일반적으로 개체 정보를 저장하는데 사용한다. 개체 정보는 properties로 key/value 쌍으로 이루어진다.

Relationships
: 노드간 명시적 연결을 나타내는데 사용한다. 관계는 유형, 시작 노드 및 종료 노드 그리고 방향이 있다. 
관계를 통해 엔터티를 구조화 할 수 있다. 관계형 데이터베이스에서는 미리 계산된 조인과 유사하다. 

Properties
: 노드와 관계 모두 속성을 담고 있는 컨테이너이며, 이름/값 쌍으로 구성된다. 속성은 관계의 세기, 강도 또는 품질을 검증하는데 사용되며, 찾고 있는 패턴을 평가하기 위해 질의/순회 중에 사용할 수 있다. 

Labels
: 레이블은 노드를 분류하는 방법이다. 라벨이 붙은 노드들은 이 노드들만의 하위 그래프를 구성하게 된다. 이렇게 레이블을 할당하여 사용자는 데이터 모델을 보다 직관적으로 만들 수 있다. 

## 그래프 데이터베이스 모델링

기존 관계형 시스템에서는 개체관계(ER ) 다이어그램을 통해 모뎅링을 했었다. 오늘날의 애자일 개발 방법론에서는 문제 또는 도메인 설명을 사용자 스토리라고 한다. 좀 더 나중에 해당 이야기는 다루어보겠다. 

기본적으로 ER 다이어 그램을 그릴때는 아래와 같은 규칙을 이용한다. 

* 명사적 설명으로 엔티티를 추출
* 형용사적 설명으로 속성을 추출
* 동사적 설명으로 관계를 추출

ER 다이어그램은 실세계의 모델에서 비즈니스 도메인 또는 사용자 요구를 추출하는 장점이 있다. 하지만 반대로 몇 가지 단점도 갖고 있다. 

ER 다이어그램을 이용해 관계를 명명할 수는 있지만, **개체 간의 방향성이 없는 관계만을 허용한다.** 그래프 데이터베이스에서는 개체간의 다양한 관계와 방향성을 허용하지만 관계형에서는 그렇지 않다.

관계형에서는  N:N 관계를 구현할 수 없기 때문에 두 테이블을 서로 연결하는 개체를 생성해야 한다. 이를 조인 테이블이라고 하면 N:N 관계를 연결하려는 모든 쿼리에서 불필요하게 발생한다. 이런 테이블은 개발자 입장에서 설계를 복잡하게 만든다.

### 질의 가능한 설계

Neo4j와 같은 그래프 데이터베이스 관리 시스템은 모델을 질의에 의해 구현할 수 있다. 모델링은 데이터에 대해 물어보고 싶은 질문에 따라 다르며, 이 질문이 디자인과 모델을 주도할 것이다. 가장 중요한 것은 사용자 이야기, 질문에 집중하는 것이다.

`내가 일하는 회사의 직원 중 누가 나와 비슷한 기술을 갖고, 지식을 교환할 수 있는지 알고 싶다.`

위 질문에서는 모델에 포함해야하는 엔티티와 엔티티간의 관계에 대해 이야기하고 있다. 직원과 기술이 엔티티가 될 수 있고 비슷한 기술이 관계가 될 수도 있다. 

### 사용 사례를 이용한 관계 정렬

질의 기능을 모델링하고 질의가 모델을 결정 수 있는 방법 중 하나는 다양한 사용 사례에 대해 노드 간에 가질 수 있는 서로 다른 관계 유형을 사용하는 것이다. 

사용 사례(use cases)는 여러 시나리오가 모인것으로, 개발자와 고객 사이에 요구를 이해하는 수단이다. 많은 훌륭한 데이터베이스 모델에서 **서로 다른 사용 사례에 대해서 2개의 동일한 노드사이에 복수 관계를 사용하고 있다.** 

왜냐하면 특정 사용 사례를 위해 두 노드 사이에 관계를 추가하는 것이 모델을 추가하는 복잡성에 비해 간단하기 때문이다. 추가 생성하거나 더 구체화해야하는 테이블이나 스키마가 없고, 추가될 조인도 없다. 

관계와 사용 사례를 조정할때 조심해야할 핵심 개념은 관계 유형의 네이밍 룰이다. 일반적은 권장 사항은 HAS_A나 IS_PART_OF와 같은 일반적인 이름을 사용하되, 보다 구체적으로 설명할 수 있는 이름을 사용하는 것이 좋다. 

### 다항 관계 찾기

어떤 경우에는 사용자 스토리를 처음 읽었을때 최적의 모델링 결과를 얻지 못하는 경우가 있다. 여러 이유가 있겠지만 흔히 보게 되는 것은 소위 다항 관계(n-ary)일때다. 

**다항관계는 특정한 하나의 개념을 하나 이상의 개념에 관계를 연결시키는 것이다. 이 관계들은 두 가지 이상(n개)의 사물이나 개념을 제공할 수 있기 때문에 다항 관계라고 한다.** 

```
Recod Company - finaces -> Song <- writes - Song author 
```

### 세밀한 노드

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5MTYyOTkzOTYsNTA1MTAwODc5LDE5Mj
Y0MzEzMzAsLTI2MTYzNTkyNywxNjQzNzI3MTE5LC0xNjI3MDgy
NjM1LC0xODgyNjQyOTAxLC0xODUyODU4NTE2LC0zMjI5NDY1MD
IsNTU0NjU5MTYxLDE2MjA4Nzk2ODEsLTMwODI2MTExNyw4Mzcw
NDIxMTQsLTYxMDg1NzA4NCwtMTQ2NDA2NDg3Ml19
-->