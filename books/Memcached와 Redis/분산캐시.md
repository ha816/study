# 분산캐시


## 배경

대규모 트래픽 처리의 성능 이슈 
트위터, 페이스북 등 대형 서비스는 대부분 데이터를 저장하고 읽는 동작을 제공한다. 이때 병목이 발생하는 부분은 대부분 데이터 스토어다. 

여기서 말하는 데이터 스토어는 일반적인 관계형 데이터베이스 관리 시스템(RDBMS)일 수도 있고, NoSQL일 수도 있다. 

--- 
NoSQL(Not Only SQL)
일반적인 DBMS로 처리하기에 비용이 많거나 비효율적인 부분을 해결할 목적으로 개발되었다. 

크게 세 가지 범주인 Key-Value Store, Column Oriented Store, Document Oriented Store가 있다. 

Key-Value Store에는 책에서 소개하는 Memcached, Redis와 같은 캐시 솔루션이 있으며 해시 데이터 구조를 사용한다 

Column Oriented Store는 일반적인 Record단위로 데이터를 저장하는게 아닌 컬럼별로 정보를 모아 저장하는 형태로 HBase, Cassandra가 있다. 

Document Oriented Store는 데이터를 JSON 형태로 저장하는 구조로, 스키마를 바꾸기가 쉬우며 MongoDB, CouchDB등이 있다.

--- 
서비스를 시작하고 어느 시점이 지나면, DB 부하가 높이지는 것을 볼 수 있다. 여기서 서비스 이용패턴 분석이 필요하며, 일반적인 서비스에서 DB의 Read/Write 비율을 분석해보면 대략 7:3 또는 8:2라고 한다. DB 부하를 낮추기 위해 결론적으로 Read를 분산시키는게 좋습니다. 

### Read가 많으면 Read와 Write를 분리하자

즉 One Master, Multi slave 구성으로 Read와 Write를 다른 DB 서버로 분리하면 성능을 향상시킬수 있다. 
Read 성능이 필요할때 마다 Read용 DB를 추가하여 DB 서버의 부하를 낮추고 DB 전체 부하를 줄 일 수 있다. 

Read를 분산 시켰을때 문제점과 Eventual Consistency
: Read를 분리하는 것이 성능 향상에 도움이 되지만 항상 적용 가능한 것은 아니다. 특히 데이터의 일관성이 중요한 경우에는 큰 문제가 될 수 있다.
일반적인 DB 리플리케이션 방식은 동기, 비동기자 있다.
동기식은 슬레이브가 데이터를 복제한 다음에 클라이언트에게 응답을 주는 방식, 그래서 마스터와 슬래이브의 데이터는 같지만, 속도가 느리다. 반대로 비동기 식은 속도는 빠르지만, 마스터와 슬래이브간에 데이터 불일치가 발생할 수 있다. 이런식으로 불일치가 발생할수 있지만 시간이 지나면, 결국 모든 데이터는 같아집니다. 이것을 Eventual Consisteny라고 한다. 

### Write가 증가하면 파티셔닝 하자

슬레이브 DB를 추가해 Read를 나눌수록 성능이 올라가야 하는데, Write Request가 많아지면 어느 시점 부터 장비가 추가되더라도 성능이 높아지지 않게 된다. 

왜냐하면, 장비 하나의 I/O 성능은 정해져 있기 때문이다. 

I/O 성능 = Read 성능 + Write 성능

