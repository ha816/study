# 3장 카프카 설치

이번 장에서는 카프카 배포안인 컨플루언트 플랫폼을 이용한 카프카 클러스터 구축 방법을 소개한다. 

http://www.osckorea.com/solution/confluent

카프카 클러스터는 1대 이상의 브로커로 구성되는 점을 고려하여 서버를 1대만 사용하는 경우와 여러대를 사용하는 경우 각각에 대한 구축법을 알아보자. 여기서 만든 클러스터는 이후 4장 이후의 예제로 사용된다. 

# 카프카 클러스터 환경 구축

## 클러스터 구성

카프카는 1대 이상의 브로커로 이루어진 카프카 클러스터, 프로듀서, 컨슈머와 카프카 클러스터를 실행하는 카프카 클라이언트로 구성된다. 

* 브로커들의 집단이 카프카 클러스터
* 카프카 클러스터를 실행 및 관리하는 카프카 클라이언트
* 프로듀서와 컨슈머

카프카 클라이언트는 클러스터의 상태 관리 및 운영에 필요한 다양한 조각을 제공한다. 이번 장의 구축예로 클러스터 3대 서버, 클러스터 1대 모두 단계를 알아보자. 

## 소프트웨어 구성

카프카 클러스터는 1대 이상의 브로커와 주키퍼로 구성되어 있다. 이장에서 구축할 카프카 클러스터는 브로커와 주키퍼를 동일 서버에 함께 설치하는 구성으로 한다. 또한 프로듀서, 컨슈머, 카프카 클라이언트에는 동작에 필요한 라이브러리와 도구를 설치한다. 

여기선 클러스터를 구성하는 각 서버에 카프카 브로커와 주키퍼를 함께 짝을 지어 설치한다. 주키퍼는 지속적인 서비스를 위해 과반수가 동작하고 있어야 한다. 이러한 환경에서 주키퍼는 홀수의 노드 수가 바람직하다. 

실제 사용시 브로커와 주키퍼를 동일 서버에 함께 설치할지 여부는 시스템 요구에 따라 달라진다. 필요한 서버 수를 줄이기 위해서 동일한 서버에 함께 설치하거나, 하둡과 같은 다른 미들웨어와 공유하기 위해 별도로 구축하는 등 각각의 사정을 고려하여 결정한다.

카프카클라이언트 서버에는 클러스터 조작에 필요한 도구를 설치한다. 프로듀서와 컨슈머는 실행 애플리케이션에 따라 카프카 라이브러리를 필요로 하는 경우도 있어 미리 설치하면 좋다.

**주키퍼**

주키퍼는(Zookeeper)는 분산 코디네이션 서비스를 제공하는 오픈소스 프로젝트입니다. 주키퍼의 아키텍처는 znode를 제공하기 위한 안정적인 분산 시스템을 구현하기 위해 설계되었습니다. 

![](https://t1.daumcdn.net/cfile/tistory/9993623A5BF7B2CD28)

클라이언트들은 주키퍼 서버들로 이루어진 앙상블(Ensemble)에 접근하여 znode의 데이터를 읽거나 데이터를 업데이트 합니다. 앙상블안의 주키퍼 서버들은 조율된 상태이며 항상 동일한 데이터를 가지고 있습니다. 따라서 어느 서버에서 데이터를 읽어도 똑같죠.

만일 주키퍼 서버에 쓰기 동작을 할 경우에, 클라이언트는 특정 서버에 접속하여 그 서버의 데이터를 업데이트 합니다. 그리고 업데이트 된 서버는 leader의 역할을 맡은 주키퍼 서버에 그 데이터를 알리고 업데이트하죠. 이 업데이트를 감지한 leader 서버는 그 정보를 다른 곳에 브로드캐스트(Broadcast) 형식으로 알리게 됩니다. 그 업데이트 정보를 받은 나머지 Follower 주키퍼 서버들은 그 내용을 갱신하여 전체 서버들의 데이터들이 일관된 상태로 유지된 상태로 있게 됩니다.

## 카프카 패키지와 배포판

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA4MzMzMTQ3MSwtOTg4MzgzMDk3LDg5Mz
YxNDQ1NSwtMTA3NjExNDc5MywtMzYzNTkyMDgzXX0=
-->