# Overview

지금까지 여러 카프카 사례와 예제를 소개했다. 하지만 지금까지 이야기 말고도 중요한 내용이 몇가지 있다. 

* 컨슈머 그룹(Consumer Group)
* 오프셋 커밋(Offset Commit)
* 파티션 재비치(Partition Reassignment)
* 파티션 수 결정에 참고사항
* 복제본 수(Replication-Factor) 결정 참고사항


# 컨슈머 그룹

## 컨슈머 그룹이란?

카프카에서는 컨슈머가 카프카 클러스터에서 메세지를 얻어 처리한다. 이때 컨슈머는 컨슈머 그룹이라 불리는 **하나 이상의 컨슈머로 이루어진 그룹을 형성하여 메세지**를 얻는다. 

컨슈머 그룹은 Group ID라는 ID로 구분된다. 이 **Group ID는 KafkaConsumer를 생성할때 지정하는 옵션으로 group.id라는 파라미터로 지정**한다. 

**컨슈머 그룹은 동일한 Group ID를 가지는 컨슈머들로 형셩**된다. 참고로 특정 컨슈머는 여러 컨슈머 그룹에 속하지 않고 항상 하나의 컨슈머 그룹에 속한다. 

카프카 클러스터에서 수신할 메시지는 컨슈머 그룹안에서 어느 하나의 컨슈머가 수신한다. 바꿔말하면, 카프카 클러스터에서 수신할 메시지를 동일 컨슈머 그룹에 속한 컨슈머 사이에서 분산하여 수신한다. 

컨슈머 그룹은 하나의 데이터 처리를 여러 컨슈머에서 분산처리하기 위해 사용된다. 

## 컨슈머에서 파티션 할당

어떤 메세지를 컨슈머 그룹의 어느 컨슈머에서 수신하는가에 대한 할당은 수신할 토픽에 존재하는 파티션과 그룹 내 컨슈머를 매핑함으로써 가능하다. 

카프카 클러스터에서 다루는 메시지는 특정 토픽 중에 특정 파티션에 반드시 포함된다. 메시지는 컨슈머 그룹에서 각 파티션에 매핑되는 컨슈머가 수신하게 된다. 

컨슈머와 파티션의 매핑에서 각 파티션에 반드시 하나의 컨슈머가 매핑되어 있다. 반대로 파티션 수에 따라 하나의 컨슈머에는 동시에 여러 파티션이 할당될 수 도 있다. 

특정 파티션에 기록된 메시지는 반드시 매핑된 특정 컨슈머가 처리하도록 고정되어 있다. 따라서 메시지를 수신하는 토픽의 파티션 보다 컨슈머 쪽이 많은 경우에는 파티션이 매핑이 되지 않은 컨슈머가 발생할 수도 있다. 

각 파티션을 컨슈머 그룹 내에 있는 어떤 컨슈머에 매핑할 것인가에 대해서는 컨슈머 그룹에 새로운 컨슈머가 가입되는 경우등 필요에 따라 변경된다. 이 결정 정책은 컨슈머가 설정되어 있는 Assignor 로직을 따른다. 

|Assignor| Class  | 할당법|
|--|--|--|
|RoundRobin| RoundRobinAssignor  | 매핑할 파티션을 컨슈머에 하나씩 차례대로 매핑|
|Range| RangeAssignor  | 매핑할 파티션을 나열하고 컨슈머 수로 영역을 분할하여 할당|
|Sticky| StickyAssignor  | 최대한 균형있게 할당하고 재할당 시에는 원래의 매핑에서 변경되지 않도록 할당한다. |

# Offset Commit

## Offset Commit이란?

카프카를 사용하는 시스템에서 컨슈머가 카프카 클러스터에서 메시지를 얻어 처리한다. 이때 컨슈머는 어느 메시지 까지 처리를 완료했는지 카프카 클러스터에 기록을 남길 수 있다. 정확히는 **다음 수신 및 처리해야 할 메시지의 오프셋을 기록한다. 이러한 기록을 남기는 처리를 오프셋 커밋**이라고 한다. 

이 오프셋은 커밋은 각 컨슈머가 카프카 클러스터에 기록을 요청함으로써 실행한다. 오프셋 커밋의 기록은 컨슈머 그룹 단위로 이루어진다. 컨슈머 그룹마다 각 토픽의 파티션에서 어느 오프셋까지 처리했는지 정보를 기록한다. 

오프셋 커밋은 처리완료 여부를 메시지 마다 기록하는 것이 아니라 처리를 완료한 메시지 중에서 최대의 오프셋을 기록하는 형태다. 이것은 카프카가 임의로 메시지를 처리하는 것이 아니라 파티션 안의 메시지를 연속적으로 처리하기 때문에 가능하다.

오프셋 커밋 정보에 의해서 컨슈머는 카프카에서의 메시지 수신 처리를 재개할때 어떤 메시지부터 재개해야하는 지 알 수 있다. 여기에는 유지보수 등 계획된 정지 뿐만아니라 장애에 의한 비정상적인 정지의 재개도 포함된다. 

재개후에 새로운 메시지만이 처리되어 불필요한 메시지를 재처리하는 것  같은 그 영향을 줄일 수 있다. 

커밋된 오프셋 정보는 __consumer_offsets라는 전용 토픽에 기록된다. 이 토픽은 일반 토픽처럼 파티션과 복제본 구조를 하고 있다. 카프카 클러스터는 오프셋 커밋 처리를 분산할 수 있으며, 여러 대의 브로커가 정지해도 데이터 손실 없이 처리 가능하다. 

참고로 오프셋 커밋 방버에는 Auto Offset Commit과 Manual Offset Commit이 있다. 각각 장단점이 있어 어느것을 사용할지는 요구사항에 따라 달라진다.

### Auto Offset Commit

자동 오프셋 커밋은 일정 간격으로 자동 오프셋 커밋을 하는 방식이다. 컨슈머의 옵션은 enable.auto.commit을 true로 하면 된다. 일정 간격은 KafkaConsumer 옵션의 auto.commit.interval.ms로 지정할 수 있으며, 기본 값은 5초다. 

자동 오프셋 커밋에는 설정된 타이밍에 카프카 클러스터에서 완료된 메시지에 대해 오프셋 커밋을 실행한다. 

자동 오프셋 커밋의 장점은 컨슈머 어플리케이션에서 오프셋 커밋을 명시적으로 하지 않아도 된다는 점이다. 즉 컨슈머 애플리케이션이 간결해진다. 

반면에 컨슈머에 장애가 발생했을때 메시지가 손실되거나 여러 메시지의 재처리 (메시지 중복)가 발생할 수 있다는 단점이 있다. 

이 방잇





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQwODk3MjE4NiwtMjEwOTQzNjAzLDIwNT
kzOTk4MzMsNjM0ODA2NDg4LC0zODY3NjYzODYsMTI3Mjc0NDU2
MF19
-->