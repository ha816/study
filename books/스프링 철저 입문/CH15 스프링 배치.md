# Spring Batch

흔히 말하는 엔터프라이즈 시스템에서는 사용자와 직접 상호작용하는 웹 애플리케이션 뿐만 아니라 사용자와 무관하게 일정 주기마다 실행되야 하는 배치 애플리케이션도 필요하다. 

## Batch

일반적인 배치 처리는 두 가지 특징을 가진다.
* 일정량의 데이터를 모아서 한번에 처리
* 일정한 순서에 따라 처리가 수행된다.

배치 처리는 응답성보다 시간당 처리량을 우선시 하는 처리 방식이다. 말 그대로 수천건의 달하는 대량의 데이터를 단시간에 처리하는 모습을 보인다.

일반적인 배치는 여러 다양한 기술을 조합해서 사용하는 경우가 많은데 일반적으로 아래 기술들을 많이 쓴다.

잡 스케쥴러
: 배치처리에서 하나의 실행 단위를 잡(JOB)이라 한다. 보통 수백에서 수천개의 잡이 관리되는데, 이러한 잡을 원할이 실행되기 위해서는 연관관계를 정의하거나 실행 스케쥴을 관리하는 기능이 필요하다.

셀 스크립트
: 셀 스크립트로 하나의 잡을 처리할 수도 있다. 비교적 간단한 처리를 하는데 쓰이지만 복잡한 잡은 상당히 만들기 어렵다.

자바와 같은 프로그래밍 언어
:  프로그래밍 언어로 별도의 애플리케이션을 개발해 잡을 처리 할 수도 있다.  비교적 복잡한 비즈니스 로직을 처리한다거나 파일이나 데이터베이스 데이터 가공 처리등에 활용된다. 

그러면 배치 처리 방식이 반드시 지켜야할 요건은 무엇일까? 물론 시스템에 따라 달라지겠지만 아래것이 대표적인 요건이다.  

* 대량의 데이터를 제한된 리소스로 효율적으로 처리해야한다.
	* 시간당 처리량과도 관련이 있지만 대량의 데이터를 모아 처리하면 처리 시간을 줄일 수 있다. 일정량 내용을 모아서 처리할때는 트랜잭션 처리 역시 일정량 단위로 시작 및 종료할 수 있어야 한다. 또 데이터가 너무 많으면 일정 단위나 건수로 분할하여 멀티 스레드 방식으로 다중 처리를 하던가 입출력을 최대한 자제하는 등 다양한 노력을 기울여야 한다.
* 가능한 한 중단된 작업을 다시 계속할 수 있어야 한다.
	* 대량의 데이터를 처리하는 동안 입력 데이터의 오류가 있거나 시스템 자체의 이상이 발생했을때 대비한 방어 대책도 생각해 둬야 한다. 데이터가 많으면 당연히 처리가 오래걸리는데 중단되고 복구가 될때 까지는 얼마나 시간이 걸릴지 모른다. 따라서 부작용을 줄이기 위해 작업을 이어서 처리하거나 처리 자체를 처음부터 재처리할 수 있도록 만들 필요가 있다. 
* 다양한 실행 조건을 지원해야 한다
	* 특정 시간이 되면 잡 스케줄러가 배치처리를 위한 프로세스를 기동하고, 완료되면 프로세스를 종료시킨다거나, 프로세스를 항상 상주시켜 놓은 상태에서 수시로 배치처리를 기동하는 등 다양한 실행 방식을 수용해야 한다.
* 다양한 입출력 인터페이스를 다룰 수 있어야 한다.
	* 외부 시스템과 연계할 때는 DB는 물론 CSV나 XML과 같은 다양한 파일도 지원해야 한다. 다양한 입출력을 다룰 수 있는 구조라면 배치 처리가 훨씬 쉬워진다.

> delayed batch, on-line batch?

지연된 배치(delayed batch)는 배치처리가 적은 빈도로 실행되고 보통 대량의 데이터를 취급하는 일반적인 배치.
온라인 배치(on-line batch)는 상당히 높은 빈도로  배치 처리해야하는 경우에 많이 쓰인다. 가령 온라인 애플리케이션과 연관되어 웹 화면에서 특정 업무의 상세 보고서를 출력해야 하는 상황이라면 온라인 처리에서는 사용자의 보고서 출력 요청만 접수하고 실제 보고서 생성 내부 동작은 배치러이에 위임해서 처리하게 된다. 이런 조합은 응답 속도, 처리 성능면 모두 좋다. 

## Spring Batch

> Spring Batch?

스프링 배치는 **배치 애플리케이션 프레임워크**이다. 스프링이 가지고 있던 DI 컨테이너나 AOP, 트랜잭션 관리 기능은 기본으로 가지고 있다. 더욱이 앞서 이야기한 배치 처리를 위한 각종 요건을 이미 갖추고 있다. 

* 처리 흐름을 정형화 
	* 단순한 형태의 Tasklet 방식
		* SQL을 한번 실행하거나, 명령을 실행하는 수준의 단순한 처리에 적합
	* 대량의 데이터를 처리하는 청크(Chunk) 방식
			* 데이터의 수집, 가공, 출력과 같은 처리 흐름을 정형화 해서 필요한 부분만 구현한다. 일정 건수가 되었을때 처리하는 트랜잭션은 스프링 배치가 처리한다.
* 다양한 실행 방법을 제공한다.
	* 명령행 실행, 서블릿에서 실행 등 다양한 실행법
* 다양한 데이터 형식으로 입출려할 수 있다.
	* 파일, DB, 메세지 큐 같은 데이터 소스의 입출력을 간단히 처리할 수 있다.
* 배치 처리를 효율적으로 수행할 수 있다.
	* 다중 실행, 병렬 실행, 조건 분기등의 처리방식으로 상황에 맞는 효율적인 처리방법을 선택
* 잡을 관리 할 수 있다
	* 잡이 실행되던 상황을 저장하거나 재시작 할 수 있다.

## Spring Batch의 기본 구조


![enter image description here](https://t1.daumcdn.net/cfile/tistory/99E54D385AE6E8CD08)

JobLauncher
: 배치 애플리케이션 기동을 위한 인터페이스. 모든 배치 애플리케이션은 이 클래스를 통해 실행된다. 

Job 
: 배치 애플리케이션에서 일련의 처리과정을 하나로 묶어 만든 실행단위.

Step
: Job을 구성하는 세부 처리 단위다. 하나의 잡은 다수의 Step으로 구성될 수 있다. 한 잡 처리를 여러 스텝으로 분할하면 세부 처리를 재사용하거나 병렬처리를 적용할 수 있고 조건 분기에 따른 제어도 가능하게 된다. Step은 청크방식이나 태스크릿 방식 중 한가지로 실행된다. Chunk 방식은 일정량의 데이터를 한번에 몰아서 입력, 가공, 출력하는 방식을 말한다. 반면 태스크릿 방식은 처리 방법을 자유롭게 기술할 수 있는 방식을 말한다.

ItemReader, ItemProcessor, ItemWriter
: 스텝을 데이터의 입력, 가공, 출력 세 가지 패턴 처리로 분할하기 위한 인터페이스이다. 배치 애플리케이션의 대부분이 이 세가지 패턴으로 구성된다는 점에 착안에 Chunk방식을 구현할때 이 세 가지 패턴을 사용한다. 

JobRepository 
: 잡이나 스텝의 상태를 관리한다. 이 정보들은 스프링 배치가 정의한 테이블 스키마 형태로 데이터 베이스에 저장된다. 

## Spring Batch의 아키텍처

### 구성요소

일반적인 엔터프라이즈 환경의 시스템에서는 다수의 잡을 실행할때 선행/후행 관계에 따라 잡을 실행하는데 이때 배치 처리의 실행을 관리하는것일 잡 스케줄러이다. 잡 스케줄러는 아래와 같은 기능을 제공한다.

* 잡 플로우(Job Flow)
	* 선행 잡의 처리 결과를 보고 후행 잡의 실행 여부를 결정한다거나 여러개의 잡을 병행 처리하는 등의 유연한 처리 흐름을 정의할 수 있다.
* 스케줄링
	* 잡의 실행 시간이나 실행 주기를 정의할 수 있다.
* 실행관리
	* 정상 종료한 잡의 실행 이력을 확인하거나 비정상적으로 종료한 잡을 재처리할 수 있다.

잡 스케줄러가 잡을 실행할때는 매번 잡을 실행할 때마다 자바 프로스세스를 기동하고, 처리가 완료되면 그 프로세스를 종료하는 방식
으로 동작한다. 

스프링 배치에서 스텝과 일반적인 잡 스케줄러의 잡을 비교해보면, 스프링 배치가 잡 스케줄러의 역할을 하고 스프링 배치의 스텝이 잡과 비슷한 역할을 한다. 스브링 배치가 스텝의 흐름제어(flow control)을 하거나 스텝 단위로 실행관리를 하고 있어서 마치 스케줄러의 기능을 대신하는것으로 보이기 때문이다. 


![enter image description here](https://terasoluna-batch.github.io/guideline/5.0.0.RELEASE/en/images/ch02/SpringBatchArchitecture/Ch02_SpringBatchArchitecture_Architecture_ProcessFlow.png) 

|구성요소|역할|
|--|--|
|JobInstacne|JobInstance는 잡을 논리적인 실행형태로 본 개념이다. 예를 들어 하나의 잡을 실행 후 다시 같은 잡을 실행하면 앞에 실행한 잡과 뒤에 실행한 잡은 서로 다른 JobInstance이다. 한편 하나의 잡을 실행하던 도중에 오류가 발생하여 처리가 중단 되었고, 이후 같은 잡을 다시 재처리하는 경우는 앞뒤 잡을 똑같은 JobInstacne라고 본다.|
|JobExcution ExcutionContext|JobExcution은 잡을 물리적인 실행 형태로 본 개념이다. JobInstance와 차이점은 같은 잡을 다시 한번 재처리하는 경우 첫번째 JobInstacne와 두번째 JobInstance는 같지만 JobExcution은 다르다. ExcutionContext는 같은 JobExcution안에서 배치 처리의 진척 상태 같은 메타데이터를 공유할때 사용하는 영역으로, 주로 스프링 배치 프레임워크가 상태를 기록할때 사용하고 애플리케이션에서도 이 영역을 활용할 수 있다.|
|StepExecution ExcutionContext|StepExecution은 스텝을 물리적인 실행 형태로 본 개념이다. JobExecution과 마찬가지로 StepExecution에서도 ExcutionContext는 같은 StepExecution안에서 데이터를 공유하기 위한 영역이 있다. 데이터의 성격상 굳이 JobExecution안에 공유할 내용이 아닌 경우라면 StepExcution에서 공유하는 것이 정보은닉의 관점에서 유리할 수 있다.|
|JobRepository|JobExecution이나 StepExecution의 배치 처리 결과나 상태를 관리하고 저장하는 기능을 제공한다. 배치는 작업 처리후 결과나 상태를 유지해야 하는데 이를 위해 메모리뿐만 아니라 데이터베이스에도 저장해야 한다. 데이터 베이스에 저장하기 위해서 JobExecution과 StepExecution을 담을 수 있는 테이블이나 시퀀스등 데이터베이스 오브젝트를 필요로 한다. 그래서 스프링 배치가 제공하는 스키마 정보를 참고하여 데이터베이스 오브젝트를 미리 만들어 둬야 한다.|

스프링 배치가 이렇게 까지 메타 데이터를 관리하는 이유는 배치 작업 재처리를 위해 이전에 실행한 상태에 대한 스냅샷이 필요하기 때문이다.  메타 데이터와 JobRepository는 그러한 정보를 남기기 위해 기반이 되는 메커니즘이다. 

### 잡 기동

일반적인 방식으로는 셀 스크립트를 만들고 그 안에서 자바를 실행하도록 하는 것이 가낭 일반적일 것이다. 특히 스프링 배치가 제공하는 CommandLineJobRunner를 쓰면 사용자가 정의한 스프링 배치의 잡을 쉽게 기동할 수 있다. 잡을 실행할때 잡의 이름을 지정할 수 있는데 이름은 DI 컨테이너에 등록된 빈의 이름과 같아야 하고 Job 인터페이스를 구현한 클래스여야 한다. 

```
$ java -cp ${CLASSPATH} org.springframework.batch.core.launch.support.CommandLineJobRunner <Config.class> <JobName> <JobParameter1>=<value1> ...
```

CommandLineJobRunner는 실행할 Job의 이름뿐만 아니라 인수 값도 입력받는데 모든 인수는 입력값 검증을 마친 후에 JobExecution에 JobParameters로 변환되어 들어간다. 

**스프링 배치는 잡의 인수에 특별한 의미를 부여하는데 바로 잡의 이름과 인수가 같다면  같은 Job Instance로 간주하는 것이다.**

Job Instance는 논리적인 실행 단위이기 때문에, 잡의 이름과 인수가 같다면 똑같은 Job Instance로 식별한다. 만약 이전 잡이 실행 도중에 실패했고, 재처리를 지원한다면 스프링 배치는 오류가 발생해서 중단됬던 잡을 다시 실행해 재처리를 하게 된다. 

만약 재처리를 지원하지 않거나 이전에 실행된 잡이 정상적으로 종료된 상태라면 뒤에 실행한 잡에서는 예외가 발생한다. 예를들어 같은 잡 이름과 같은 인수를 가진 잡이 이전에 정상적으로 종료되었다면, 재처리 잡 실행시 JobInstanceAlreadyCompleteException이 발생한다. 

이러한 이유로 매일 반복해서 실행하는 배치에서는 스프링 배치가 잡을 고유한 잡으로 인식하도록 고유한 인수를 부여하는 기법이 필요하다. 

> -next 옵션
>  CommnadLineJobRunner를 동작할때 -next 옵션을 쓰면 같은 잡과 인수를 넣어도 내부적으로 고유한 인수를 생성하기 때문에 같은 잡 인스턴스를 피하도록 처리가 가능하다. 

### 비즈니스 로직 처리

스프링 배치에서는 step이라는 실행 단위가 있어

![enter image description here](https://terasoluna-batch.github.io/guideline/5.0.0.RELEASE/en/images/ch02/SpringBatchArchitecture/Ch02_SpringBatchArchitecture_Architecture_StepTaskletFlow.png)









> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI5OTc1NDM4OSwtMjExMjg4MDk4NCwtMT
ExMTY2MTkxNCw5OTUwODQxNjEsMTg0MTQ3NzE0LC03OTk3NzEw
NTQsLTE0NTM1NjM3MTUsLTgxOTM5MjI0MywxNjk0MDI1NjY5LD
cwMDkyMzYzMywxNjA4MjY5NCwtMzgyMTA2ODk0LDE0MzQzNTIx
NTYsMjkxODkxMjgyLC0xNzMxMTM4NzQ5LDg1OTU1NTQ2Myw4OD
g5Nzc2MDddfQ==
-->