# 원시타입

> 몇 가지 자바 원시 타입의 이름을 말하고 이 타입이  JVM에서 어떻게 처리되는지 설명하라.

원시타입(primitive type)은 Null이 될수 없다. 즉 언제나 값을 가지는 상태다. 

int, long 원시타입은 숫자 값 뒤에 L을 붙이면 long이다.  안붙이면 자연스럽게 int이다. 비슷하게 float, double도 숫자값 뒤에 D를 붙이면 double, F를 붙이면 float이다.

원시 타입의 크기

| type| 크기(bit)  |
|--|--|
|boolean | 1bit |
|char | **16(2byte)** |
|short | 16(2byte) |
|int | 32(4byte) |
|long | 64(8byte) |
|float | 32(4byte) |
|double | 64(8byte) |

char는 unsigned이므로 0 ~ 65535 까지 담을수 있다. 

> 왜 Integer.MIN_VALUES에 대응하는 양수가 없는가?
> Integer값은 $2^{32}$가지의 값을 표현할수 있다. 그리고 signed이기 때문에 절반 만큼은 음수를 위해 써야한다.  그런데 0도 양수의 표현해야하기 때문에 $2^{31}-1$만큼은 양수로 나머지는 음수로 표현한다.

> 오토 박싱이란?

오토 박싱(Auto Boxing)은 원시 타입을 원시타입에 대응하는 참조 타입으로 자동 변경하는 것이다. 

자바 5이전에는 수동으로 원시 타입을 참조 타입으로 바꿧는데 이를 박싱(Boxing)이라고 한다. 반대로 언박싱(Unboxing)은 참조 타입을 대응하는 원시 타입으로 바꾼다. 

# 자바 변수

## 저장 형태의 따른 분류

기본형 변수
: 자료의 실제값을 저장한다.

참조형 변수
:  값이 저장되어 있는 주소값을 가진다.

## 선언 위치에 따른 분류



# 객체 이용하기

원시 타입을 제외하면 자바 언어의 모든 변수들은 참조 타입이다. 이것들은 객체로 원시타입과 차이점은 빈객체를 의미하는 null 표현이 존재한다는 것이다.

원시 타입은 값을 메모리에 그대로 저장한다. 그에 반해 참조 값은 객체가 할당된 메모리의 주소(위치)를 저장한다. 표면적으로 둘다 비슷하게 동작하는 것으로 보이지만 실제로는 그렇지 않다. 

> 자바에서는 배열을 어떻게 표현하는가?

중요한 점은 자바에서 배열을 객체로 취급한다는 것이다. 배열은 toString()을 호출할수 있고 다양한 방법으로 이용이 가능하다. 또 배열이 객체라는 의미는 참조로 전달될 수 있다는 뜻이다. 따라서 해당 객체는 참조하는 모든 것에 의해서 변경이 발생할 수 있다. 따라서 사용에 주의해야 한다. 

> final 키워드는 객체 참조에 어떤 영향을 미치는가?

객체에 선언하는 final 키워드는 원시타입에 선언하는 final 키워드와 동일하다. 즉 메모리 변수에 값이나 메모리 주소가 할당되면 그 값과 메모리 주소는 변하지 않는다. 변수에 할당된 메모리 주소는 변경하지 못하지만 객체 자체는 당연히 수정이 가능하다.

> 객체의 가시성 수정자(visibility modifier)는 어떻게 작동하는가? 

가시성 수정자는 객체의 정보은닉에 도움을 준다. 필드나 메서드, 중첩 클래스(nested class), 중첩 인터페이스(nested interface) 같은  멤버(필드, 메서드)의 접근 권한은 크게 4가지 종류가 있다. 

| 접근 권한 수정자 | 설명 |
|--|--|
|private| 선언된 멤버는 선언된 같은 클래스에서만 접근가능 |
|package-private| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능; 기본 접근 권한으로 알려져 있음 |
|protected| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능할 뿐만 아니라 (다른 패키지에서) 선언된 클래스를 확장하는 하위 클래스에서도 접근가능|
|public| 선언된 멤버는 어디서도 접근가능|

private의 일반적인 오해는 private으로 선언한 변수는 해당 인스턴스만 접근할 수 있다고 생각하는 것이다. 같은 인스턴스는 아니지만 같은 타입의 모든 인스턴스가 private 멤버 변수에 접근이 가능하다. 

> 메서드와 변수에 사용되는 static 키워드의 역할은 무엇인가?

static은 정적 변수와 메서드를 만드는데 사용하느 키워드이다. 정적이란 인스턴스가 생성되기 전에 이미 존재하는걸 의미하는데, 대개 특정 인스턴스 보다는 클래스 이름을 통해 정적 메서드와 정적 변수에 접근한다. 정적변수 또는 정적메서드는 그 클래스를 통틀어서 하나만 공통으로 사용한다.

> 다형성과 상속이란 무엇인가

다형성(polymorphism)과 상속은 객체 지향 개발의 두가지 핵심 개념이다. 
다형성은 하나의 클래스가 수많은 클래스가 되도록 한다.
상속은 부모클래스에서 행동과 정의를 가져와 사용할 수 있게 해준다. 이전 클래스의 행동과 정의를 가져와 새로운 행동을 추가하거나 기존 행동을 재정의(오버라이드)해서 사용이 가능하다. 

> 객체의 일부 메서드가 오버라이드되었을 때 어떻게 사용되는지 설명하라. 

JVM에서 실행되는 모든 클래스는 Object를 상속하므로 final 메서드를 제외한 public, protected 메서드는 오버라이드 할 수 있다. 

hashCode와 equals 메서드 관계에서 반드시 지켜야하는 규칙은 두 메서드 중 하나를 오버라이딩 할때 반드시 둘다 함께 오버라이드 해야한다. 왜냐하면 HashSet 같은 경우, equals 메서드가 구현되어 있지 않아서, 그냥 쓰면 객체 참조 값만 비교 한다. 

> @Override 애노테이션은 어떤 역할을 하는가? 

컴파일러에게 상위 클래스의 메서드가 오버라이드 되었다는 것을 알려주므로 컴파일 할때 유용하다. 일반적으로 메서드를 오버라이딩 할때 이 애노테이션으로 실수하지 않게 하는 용도로 쓰인다. 만약 상위 클래스에 일치하는 메서드 시그니처가 없으면 에러가 발생한다. 

# String 이용하기

>String은 메모리에 어떻게 저장되는가?

String 클래스는 자바 라이브러리에 간단히 저장된 클래스지만 매우 중요하고 광범위하게 사용된다. JVM과 컴파일러는 특정 상황에서 특별한 방법으로 String 객체를 처리한다. 

String 객체는 원시 타입처러 취급된다. String 리터털이 원시 타입처럼 취급되는 String 객체다. String 릴터럴을 생성 할때 new 키워드를 사용할 필요가 없다. 실제 컴파일할때 쌍따옴표로 표현된 String 리터럴은 모두 객체로 생성된다. 

> String 객체의 값을 변경할 수 있는가?

String 클래스에서 String 객체 값을 변경하는 것처럼 보이는 모든 메서드가 실제로는  String 인스턴스를 반환한다. 

**String 값은 절대 변하지 않으며 바꿀수 없다**

이러한 불변성은 많은 장점이 있다. 하나는 스레드에 안전하다는 것이다. 참고로 String 뿐만 아니라 Integer, Double, Charactrer, BigInteger와 같은 모든 숫자형 클래스도 불변형이다. 

> 인터닝이란 무엇인가?

String 리터럴은 실행할때 JVM이 특별히 관리를 한다. 클래스가 JVM에 로드되면 모든 리터럴이 상수 풀에 위치한다. 그리고 **String 리터럴의 모든 반복은 풀안의 같은 상수를 참조하는데 이를 String Interning(인터닝) 이라 한다.**

String 인턴 풀은 컴파일 할때 단지 String 리터럴을 가져오는게 아니라 intern메서드로 모든 String 인스턴스를 풀에 추가한다. intern메서드는 해제에는 사용할 수 없다. String이 힙에 저장되어 있지 않더라도 어딘가에 저장되어야 하는데, 저장 장소는 PermGem이다.

String 상수 풀은 플라이 웨이트 패턴을 구현한것으로 Integer.valueOf와 비슷하다. 

# 제네릭 이해하기

> 컬렉션 API에서 제네릭을 어떻게 사용하는지 설명하라. 

제네릭은 `매개변수화된 타입`이라고도 알려져 있다. 즉 매개변수로 어떤 타입을 입력받은 타입을 말한다. 만약 컬렉션 클래스에서 매개변수로 특정 타입을 입력 받으면 컴파일러는 그 특정 타입만 포함될 수 있게 컬렉션을 제한한다. 

컬렉션 API에 있는 모든 클래스는 제네리릭을 사용해서 만들었다. List인터페이스와 그 구현은 한 가지 타입의 매개변수만 받는다. Map인터페이스는 두가지 타입 매개변수를 받는다. 

> 타입의 변화는 제네릭에 어떤 영향을 미치는가? 

클래스 B가 A를 확장하면 B는 A의 하위 타입이다. 하지만 `List<B>`는 `List<A>`의 하위 타입이 아니다. 공분산이라 알려진 자바의 제네릭 시스템이는 이에 관한 모델링 방법이 없다. 

제네릭 타입을 다룰때는 때때로 클래스의 하위타입을 받아들여야 하는 경우도 있다. 이럴때 `?`인 와이들 카드를 사용한다. 

예를들어 List<? extends A>는 컴파일러에게 A 클래스를 확장한 모든 인스턴스를 List원소로가지는 매개변수 타입이다.  

> 구상화한다는 건 어떤 의미인가? 

본래 구상화 (reified)는 것은 실행 시에 이용할 수 있다는 것이다. **기본적으로 자바의 제네릭 타입은 구상화가 아니다.** 왜냐하면 .class 파일 정의의 일부가 아닌, 제네릭 매개변수를 직접 사용하는 구현 코드의 모든 타입 정보를 컴파일러가 확인하기 때문이다. 

실제 제네릭을 사용한 코드로 만든 실행 코드를 자바 디컴파일러인 JAD를 이용해서 디컴파일하면 모든 제네릭 타입 정보가 사라진다. 

# 명명규칙 이해하기

클래스의 첫글자는 대문자이고 카멜 케이스를 따른다. 변수와 메서드는 첫 글자는 항상 소문자이고 카멜케이스를 따른다. 상수는 변경불가한 상수로 모두 대문자에 사이는 밑줄로 연결한다. 

# 예외처리 하기

자바의 예외처리 구조를 이루는 주요 클래스를 설명하라. 

Error와 Exception은 모두 Throwable하다. 
Error는 프로그램이 실행을 멈추게 되는 치명적이 오류로 대표적으로는 RunTimeError, OutOfMemoryError 등이 있다. Exception은 유연하게 프로그래머가 처리 가능한 예외로 nullPointerException등 이 있다. 

예외는 확인해야하는 명시적 예외(Checked Exception)와 그것이 아닌 예외(Runtime Exception)가 있다. 명시적 예외로 처리된 메서드는 반드시 해당 예외를 try구문으로 처리해야 한다. 

>런타임 예외와 명시적 예외 중 어떤것이 더 좋은가?

명시적 예외에서는 코드에서 무엇이 잘못되었는지 직접 예외 처리를 해줘야 한다. 이때 어떤 동작이 잘못되었는지 정확한 예외를 던져줘야 한다. 

```
public String getHostName() throws Exception
```
위와 같은 명시는 예외가 발생했을때 무엇인 잘못되었는지 단서를 찾을 수 없다. 

런타임 예외의 경우 예외를 정의하는 것이나 다시 처리하는것 모두 선택 사항이다. 

필자는 일반적으로 런타임 예외를 선호한다. 하지만 클라이언트가 해당 메서드를 호출했을때 어떤 예외가 발생하는지를 문서에 꼭 남긴다. 런타임 예외를 선호하는 이유는 명시적 예외에서는 try문을 기본 코드에 추가해야 할 뿐만 아니라 유지보수가 어려워지기 때문이다. 

> try-with resource는 무엇인가?

자바 7에서 추가된 try-with resource는 기존 try-catch-finally를 대체한다. try 뒤에 붙은 자원은 반드시 자원종료를 해주기 때문에 finally를 붙여 구구절절 처리를 해주지 않아도 된다. 

# 표준 라이브러리 사용하기 

> 왜 private인 필드가 변하지 않도록 하기 위해 final 키워드를 선언해야 하는가?

그런데 자바 relection을 쓰면 private 메서드도 사용이 가능하고 private 필드도 접근이 되고 심지어 final로 지정되어 값을 수정할 수 있다.

> 다른 모든 컬렉션 API에서 상속되는 클래스는 어떤것이 있나?

자바 컬렉션은 java.util 패키지에 포함된다. 자바 컬렉션 구조는 크게 Collection과 Map인터페이스가 있다. Collection에는 List인터페이스와 Set인터페이스가 있다. 

그러나 Collection과 Map은 서로 연결되어 있다 Map 인터페이스에는 Collection 인터페이스에서 Map 구성요소를 접근할 수 있는 entrySet, keySet 메서드가 있다. 

# Comparable과 Comparator 인터페이스

자바는 정렬 순서를 정하기 위해서 두 가지 인터페이스를 제공한다. 
Comparable은 비교하려는 객체간의 자연스러운 순서로 정렬할때 사용하고 Comparator는 원하는 대로 정렬 순서를 정하고 싶을 때 사용한다. 

Arrays.sort, Collections.sort 등 정렬 메서드를 사용할때는 정렬할 객체들이 Comparable 인터페이스를 구현해야 한다. 만약 구현하지 않으면 ClassCastException이 발생한다. 


일반적인 순서에 반대되는것 같이 원하는 순서를 정의하고 싶으면 sort 메서드에서 사용할 Comparator 인터페이스에 compare 메서드를  구현해줘야 한다. 

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1OTM2NzM1OTldfQ==
-->