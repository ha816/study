# 배열

> 배열의 특성은 무엇인가?

* 배열은 정의할때 크기를 지정해야 한다. 
* 배열에 특정 원소에 인덱스 값으로 접근하는 것을 랜덤 접근(Random Access)이라 하며 굉장히 빠르다. 
* 배열 전체를 사용 중일때 원소를 추가하려면 더 큰 배열을 만들고 현재 배열에 있는 원소를 모두 복사하는 방식으로 새 배열을 만든다. 
* 자바의 내장 컬렉션으로 존재한다.

# 리스트(LIST)

> ArrayList와 LinkedList의 차이는?
> 나의 답


List 
: 원소들이 선형 나열된 자료구조이다. 자바에서는 일반적으로 ArrayList나 LinkedList 클래스를 사용한다. ArrayList와 LinkedList는 상황에 따라 성능의 차이가 있다. 리스트는 자바의 내장 컬렉션인 배열하고 다르다. 리스트는 크기 지정에 한계가 없으므로 리스트를 사용하기 전에 크기를 지정할 필요가 없다. 

ArrayList
: 내부적으로 배열을 사용하는 리스트이다. 즉 배열의 특징을 그대로 가져간다.(랜덤 접근, 전체 복사) 배열의 시작 위치나 중간 위치에 새로운 원소를 추가하려고 하면, 그 뒤에 있는 원소들은 모두 이동해야 한다. 또한, 많은 원소를 삭제해도 차지하는 배열의 크기는 줄어들지 않는다. 

LinkedList
: 원소들을 배열에 저장하지 않고, 리스트 안에서 다음 원소를 가리키는 내부 참조를 이용하는 리스트이다. LinkedList를 참조하는 변수는 리스트의 첫 원소인 Head를  참조한다. 그리고 각 원소는 다음 원소를 참조하는 next 변수를 가진다. LinkedList는 원소 추가, 삭제도 간단하며, 크기도 즉각 줄어든다. 

* ArrayList의 경우, 일반적으로 빠른 속도로 특정 인덱스에 접근하거나 리스트의 크기가 클수록 좋다. 또한, 첫 부분이나 중간에 원소를 추가/삭제 해야하는 경우가 적으면 더 좋다. 
* LinkedList는 첫 부분이나 중간에 원소를 추가/삭제 할일이 많을때 사용하는 것이 좋다. 혹시 스택처럼 특수한 자료구조를 만들었다면 LinkedList를 쓰는게 좋은데 어떤 위치든 원소를 넣고 빼기가 간단하기 때문이다. 

Queue
: **FIFO(first-in first-out) 자료구조를 구현한 자바 인터페이스**. 구조의 가장 끝(최근)에 추가하는 add 메서드, 가장 앞(오래된) 원소를 제거하고 반환하는 remove 메서드, 반환만 하는 peek 메서드를 가진다.

Deque(덱)
: Queue 인터페이스의 확장으로 자료구조의 양 끝에 원소를 추가하고 삭제할 수 있다. 

# 트리(TREE)

트리는 루트에서 부터 시작하여 자식이라 불리는 서로 다른 원소를 많이 나열할 수 있는 자료구조다. 대표적으로 이진트리가 있는데 최대 두개의 자식을 가질 수 있는 트리를 말한다. 

## 이진트리(Binary Tree)

이진 트리를 활용하는 구현체로 이진 검색 트리가 있다. 이진 검색 트리의 효율은 트리의 균형에서 나온다. 균형 있는 트리를 만들기 위해 다양한 트리 기법이 있고 대표적으로는 AVL 트리가 있다. 일반적으로 트리의 균형이 맞을때는 검색, 삽입, 삭제시 $O(log n)$의 처리시간이 소요된다.

> AVL 트리란?

## 이진힙(Binary Heap)

이진 트리의 또 다른 응용법으로 Binary Heap이 있다. 참고로 Heap의 사전적 의미는 더미, 무더기라는 의미이다. 힙은 여러 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다. 최대값을 빠르게 찾아내는 힙을 최대힙(max heap), 최소값을 빠르게 찾아내는 힙을 최소힙(min heap)이라고 한다.

Binary Heap의 두 가지 중요한 특성
1. Complete Binary Tree 
3. Max Heap일 경우, 부모는 자식 보다 큰 값을 가진다. 반대로 Min Heap에선, 부모가 자식보다 작은 값을 가진다. 

완전이진트리(Complete Binary Tree ) 
: 가장 아래 두 레벨에 있는 노드들을 제외한 모든 노드들이 두개의 자식 노드를 가진다. 그리고 가장 아래 레벨에서 노드는 왼쪽에서 오른쪽으로  채워져야 한다. 

# Map

> HashMap의 성능? 언제나 좋은 성능을 보이는가? 해시 함수는 무엇인가? 대안은 없는가?
> HashMap과 ConcurrentHashMap의 차이는?
> HashMap과 LinkedHashMap, TreeMap과의 차이는?

**맵은 키-값 형태로 데이터를 저장하는 자료구조다.** 맵을 구현할 때는 Map  인터페이스를 구현하지만 Collection 인터페이스를 구현하지는 않는다. 맵의 키는 유니크하다. 

## HashMap

HashMap 클래스는 해시 테이블을 자바로 구현한 것으로, 클래스 구현에는 키-값 쌍을 나타내는 Entry라는 내부 클래스가 있다. 

해시 테이블의 실제 데이터를 저장하는 공간과 인덱스로 구성된다. 해시 테이블 인덱스는 특정 키가 테이블 어디에 위치하는 지를 말한다. 

### hashCode
원론적으로 해시 함수(Hash Function)은 어떤 키를 입력으로 받으면 적당한 값을 반환하는 함수이다. 여기서 적당한이란 말은 서로 독립적인 두 개의 키를 넣어도 같은 값이 반환될 수 있다는 이야기다. 또 해시함수의 동작 시간은 $O(C)$이어야 한다. 

이러한 해시함수를 자바에서 구현한것이 바로 Object 클래스에 정의된 hashCode 메서드이다. 이 메서드를 호출한 객체의 내부 메모리 주소를 integer값으로 반환한다. 짚고 넘어 갈것은 해시함수의 `적당한`이란 의미에 맞게 분명히 두 객체가 다른 메모리 주소를 가져도 같은 integer값이 반환될 수 있다는 점이다. 

hashCode는 두 객체의 메모리 주소가 완전히 같다면 같은 값을 반환해야  하지만 같은 hashCode값을 가진다고 해서 두 객체의 메모리 주소가 같은 것은 아니다. 

> Hash Collision? 해쉬 충돌이란?

서로 다른 객체가 같은 해시 테이블 공간에 들어가는 상황을 해쉬 충돌이라고 한다. 

해쉬 충돌을 해결하기 위한 한 방법은 두 번째 해시함수를 갖는 것이다. 두 번째 해시함수는 값을 삽입하려고 할때 테이블에 이미 다른 값이 있으면 오프셋 방식으로 해당 값이 삽입될 위치를 다시 계산한다. 하지만 이는 단지 충돌을 미룰 뿐이다. 또 다른 방법으로는 같은 특정 해시함수 값으로 삽입시 원소 자체를 저장하는게 아니라 리스를 두고 그 리스트에 원소를 저장하는 방식이 있다.

해시 충돌이 일어나는 얼마나 자주 일어날것인지는 해시 테이블의 크기와 밀접한 연관이 있다. HashMap은 객체를 생성할 때 0에서 1의 값을 가지는 부하계수를 명시할 수 있다. 그리고 이 부하 계수를 다 채우게 되면 테이블의 크기를 두배로 늘린다. 이때 기존 테이블의 원소를 재배치하는데, 가능한 hashCode 값을 늘어난 해시 테이블 인덱스에 맞게 재할당한다. 많은 원소가 있는 테이블에서 재할당하는건 많이 자원이 투입되므로 처음부터 적당히 큰 테이블로 만드는 것이 좋다. 

## TreeMap

**TreeMap은 Map 인터페이스를 구현하는데 이진 트리 구조를 이용한다.**  즉 트리의 각 노드가 키-값 쌍(Entry)가 된다. TreeMap은 키를 정렬가능한 순서에 따라 저장하기 때문에 HashCode는 전혀 사용되지 않는다. TreeMap클래스는 균형을 맞춘 트리 구조로 구성되기 때문에 검색, 추가, 삭제 같은 모든 동작이 항상 $O(log n)$에 처리된다. 

## LinkedHashMap

LinkedHashMap은 기본적으로 HashMap가 같은 방식으로 동작한다. 하지만 키를 반복해서 찾을 때 **삽입한 했던 순서를 유지하는 특성**이 있다. 

```
LinkedHashMap map
map.put(4, "four");
map.put(3, "four")
map.put(2, "four")
Iterator keys = map.keySet().iterator();
print(keys.next); //4
print(keys.next); //3
print(keys.next); //2
```

## ConcurrentHashMap

하나의 맵 인스턴스를 많은 쓰레드에서 공유하고자 한다면 ConcurrentHashMap을 쓰자. 이름에서 보듯 쓰레드 세이프(Thread Safe)한다. 
ConcurrentHashMap 클래스의 구조는 원본 Map과 비교해서 약간 차이가 있는데 Size 메서드가 맵의 예상 크기를 반환한다. 현재 수행중인 모든 쓰기 작업을 고려하지 않기 때문이다.

> 

# Set(집합)

집합은 중복을 허용하지 않고 순서가 없는 객체들의 모임이다. Set은 Collection 인터페이스를 확장한다. 


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4NjcyODg2NDgsLTIwNDQ3NDYzNTcsLT
E2NDYzMzAyNl19
-->