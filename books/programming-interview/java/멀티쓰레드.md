# 쓰레드 이용하기 

모든 애플리케이션은 최소한 하나의 스레드는 가지고 있어야 한다. 
직접 스레드를 만들 수 도 있는데 새로운 스레드를 만들때 마다 코드는 해당 스레드에서 즉시 실행된다. 

새로운 스레드를 생성할때는 새로운 Thread객체를 생성해야 한다. 이 객체는 Runnable 인터페이스의 객체를 전달받는다. 또한 Runnable 인터페이스는 public void run()이란 메세드가 있는데, **스레드를 실행할때 이 run()메서드를 직접 호출하면 안된다.** 

Thead 객체의 start메서드를 호출한 후에는 run 멧더를 호출해서 JVM에서 코드를 실행하는데 필요한 새로운 스레드를 생성한다. 

Thread 클래스는 병렬 실행이 가능한 스레드를 만들 수 있도록 JVM을 호출한다는 점이 특별하다. start 메서드를 소스 코드에서 확인할 수 있다면 네이티브 메서드인 start0으로 호출하는 private 메서드 역시 확인할 수 있다.Thread 수행 순서를 결정하는 것은 전적으로  JVM이다. 

## Executor Framework

자바 4에서 도입된 동시성 프레임워크(Executor Framework)는 동시성을 위한 클래스들을 제공했는데 자바의 스레드 모델을 이용하는데 큰 도움을 주었다. Executor 프레임웍은 다음과 같은 특징을 지닌다.

-   쓰레드 풀을 사용(무거운 쓰레드는 미리 할당 가능)
-   태스크와 쓰레드를 생성하고 관리하는 것을 분리
	- 태스크(task == Runnable 한 구현체)
-   쓰레드 풀안의 쓰레드는 한번에 하나씩 여러 태스크를 실행
-   태스크 큐를 이용해 태스크 관리
-   Executor Service를 더이상 필요 없으면 중지
-   Executor Service가 멈추면 모든 쓰레드도 중지

Executor 인터페이스
: 주어진 Runnable객체(태스크)의 실행을 execute 메서드로 추상화 정의
```
void execute(Runnable task);
```
Executor Service
: Executor 인터페이스를 확장하며 쓰레드 라이프 사이클을 제어

Executors 클래스
: 다양한 Executor Service 인스턴스를 생성하는 Excecutor Service의  Factory 클래스.

```
public static ExecutorService newFixedThreadPool(int nThreads);
public static ExecutorService newCachedThreadPool();
public static ExecutorService newSingleThreadExecutor();
public static ExecutorService newSingleThreadScheduledExecutor();
```
예제
```
ExecutorService execService = Executors.newFixedThreadPool(2); 
execService.execute(new MyThreadTask());
execService.execute(new MyThreadTask());
execService.shutdown();
```

자바에서 Thread 생성은 시스템 자원이 많이 드는 연산이므로 운영체제는 애플리케이션에서 실행되는 스레드 갯수를 제한하게 된다. Thread pool을 이용함으로써 새로운 스레드를 이용하기 보다는 재사용을 하게 된다. 

자바 동시성 프레임워크는 일반적인 경우에 사용하는 스레드 풀을 제공하며 이를 확장해서 쓸수 있다. 
동시성 프레임 워크에서 제공하는 Excutor 클래스는 병렬 컴퓨팅에 추상화이고 동시에 실행될 코드를 관리할 수 있다. 이 Excutor 클래스의 인터페이스는 void execute(Runnable)이다. 모든 구현은 특정 Runnable을 실행하는 스레드를 관리할 수 있다. 

Excutors 클래스의 생성된 풀을 이용하면 Exectuor 객체 대신에 ExcutorService 객체를 반환한다. ExcutorService 객체는 Excutor 객체와는 달리 코드 실행을 중단시킬 수 있는 기능이 있다.
 
동시성 코드가 짜기 어려운 이유는 쓰레드가 동시 다발적으로 실행되기 때문이다. 하나의 공유 자원에 대해서 다른 쓰레드가 자원의 상태를 읽거나 수정을 하는 동안에는 해당 상태가 변경되지 않도록 공유를 잠궈둬야 한다. 

모든 자바 객체는 스스로 락을 유지할 수 있는 능력이 있다. 따라서 synchronized(object) 코드를 감싸서 한번에 스레드 하나만 코드 블록 안에서 실행 할수 있도록 한다. 물론 이런 락에는 성능이 느려진다. 스레드는 잠겨 있는 동안 다른 작업을 기다려야 함으로 성능이 떨어진다. 그러므로 읽고 쓸 필요가 없으면 최대한 빨리 락을 해제하는 것이 좋다.

> Atomic 클래스는 무엇을 제공하는가? 

자바 동시성 프레임 워크에는 모든 기본 타입을 Wrapping하는 Atomic 클래스가 있다. 이 클래스들은 모든 원자 연산을 보장한다. 즉 다른 쓰레드는 **모두 메서드 호출이 완료될때까지 이 클래스의 참조가 수정되지 않는다.** 즉 Atomic한 클래스의 객체는 메서드가 값을 읽고 쓰는 동안 변경되지 않는 것을 보장해주기 때문에 synchronized 메서드가 불필요 하다. 

>왜 불변 객체를 써야하는가? 

불변객체는 값이 변하지 않기 때문에 스레드에서 락을 사용하지 않아도 된다. 이는 동기화된 코드 블록 사이에서 값 하나를 이용할 수 있을때까지 대기하는 시간을 아낄 수 있다는 말이다.  불변 객체의 값을 수정해야할 경우 수정된 새로운 객체를 만들어야 한다. 





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMzODk1MzQ0MF19
-->