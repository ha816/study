# JVM 

> JVM?

JVM은 Java Virtual Machine의 약자로 Java 프로그램이 실행되는 플랫폼이다.  운영체제와 애플리케이션 사이에 위치하면서 애플리케이션이 특정 플랫폼에 상관없이 독립적으로 실행되도록 한다. 
그리고 JVM은 메모리 관리를 위해 GC를 수행한다. 

## JVM과 Java간 상호작용

JVM에서 가장 먼저 해야할 일은 컴파일이다. 컴파일을 하면 .class확장자를 가진 바이트 코드가 생성된다. 이러한 바이트코드를 실행 준인 JVM의 메모리로 가져오는 걸 클래스 로딩이라고 한다. 이것을 클래스 로더가 한다. 이 클래스 로더는 클래스 파일을 추상화해 디스크, 네트워크, JAR같은 것들을 메모리로 불러 올 수 있다. 

로드가 되면 JVM은 바이트코드가 유효한지 검증한다. 검증이 되면 JVM은 코드가 실행되는 아키텍쳐와 운영체제에 맞는 명령어로 바이트 코드를 해석할 수 있다.

> native 메서드란 무엇인가?

자바에서는 C나 C++의 잘 정의된 헤더를 사용할 수 있는 native 메서드를 사용할 수 있다. 코드가 JVM에 로드됐을때 고유(native) 코드를 등록해야 한다 그래야 메서드 호출시 코드를 실행하는데 정확히 필요한 것을 알 수 있다. 

# GC(Garbage Collection)

> GC(가비지 컬렉션)이란 무엇인가?

가비지 컬렉션은 기존에 할당된 메모리를 재사용하는 메커니즘으로, 나중에 메모리를 할당할때 재사용할 수 있다. 대부분의 프로그래밍 언어는 가비지 컬렉션을 자동으로 실행한다. 가비지 컬렉션을 쓰면 메모리를 직접 해제할 필요가 없다. 

가비지 컬렉션 알고리즘은 몇 가지가 있다. 모두 작동 중인 코드에서 더 이상 참조하지 않는 메모리를 찾은 후 메모리를 할당할 때 이용할 수 있도록 반환한다는 공통점이 있다. 전통적인 방법은 mark-and-sweep방식이다. 실행 중인 코드에서 참조하는 객체는 live로 표시되고 참조하는 것도 live로 한다. 

이 과정이 끝나면 live로 표시되지 않는 메모리르 할당할 수 있게 만든다. 이때 메모리를 재배치하려고 JVM의 모든 쓰레드가 정지되는데 이를 stop-the-world라고 한다. 

자바 6에는 G1(Garbage First)라는 새로운 알고리즘이 투입되었다. 

결국 가비지 컬렉션은 다른 제너레이션으로의 이동과 가능한 한 많은 여유 공간을 남겨두려는 목적으로 메모리에서 객체들을 옮기고 자주 접근되는 객체들을 묶어두는등 연산을 수행한다. 이러한 연산들을 컴팩션(compaction)이라고 한다. 컴패션은 live로 표시한 객체들을 다른 물리적인 메모리 위치로 옮김으로써 JVM이 stop-the-world인 메모리 공간을 확보한다. 





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM3NDgyMjk3MywtMTU1ODg2MTI4NSwtMT
Y2OTI5ODAxOSwtMTQxOTczOTIyMSwxMjY4NjYyMTg4XX0=
-->