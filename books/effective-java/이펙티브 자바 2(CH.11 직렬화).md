## 직렬화 

객체 직렬화(object serialization) API를 살펴본다. 
이 API는 객체를 바이트 스트림(byte stream)으로 인코딩(encoding) 하거나 바이트 스트림을 객체로 복원하는 프레임워크다. 
객체를 바이트스트림으로 전환하는것을 직렬화(serialization)
그 반대는 역직렬화(deserialization)이라 한다. 

직렬화는 연격지 컴퓨터와 통신하기 위한 표준적 객체 인코딩을 제공하며, 자바빈(javaBeans) 컴포넌트 아키텍처 표준적 지속성 데이터 형식도 제공한다. 

특히 직렬화 프락시 패턴(serialization proxy pattern)은 주목할만한 내용이고 객체 직렬화 과정에서 발생할 수 있는 많은 문제를 피하도록 도와준다. 

### 74. Serializable 인터페이스를 구현할 때는 신중하라. 

간단히 implements Serializable을 붙여 직렬화 가능한 객체를 만들 수 도 있다. 
사실 간단해서 프로그래머가 할일이 별로 없다라는 잘못된 믿음이 있다. 

**Serializable 구현과 관련된 가장 큰 문제는 일단 클래스를 릴리스 하고 나면 클래스 구현을 유연하게 바꾸기 어려워진다는 것이다.** 

Serializable을 구현하면, 해당 클래스의 바이트 스트림 인코딩(직렬화 형식 {serialized form})도 공개 API의 일부가 된다. 
배포된 클래스의 직렬화 형식은 일반적으로 영원히 지원해야 한다. 

사용자 정의 직렬화 형식을 설계하지 않고 기본형식(default)를 그대로 이용하면, 직렬화 형식은 영원히 클래스의 원래 내부 표현방식에 종속된다. 
즉 기본 직렬화를 사용하면, private과 packge-private 객체 필드도 공개 API가 된다는 것이다. 정보 은닉 원칙이 효력을 잃는다. 

기본 직렬화 형식을 선택한 상태에서 클래스 내부 표현을 바꾸면, 직렬화 형식에 호환 불가능한 변화가 생길 수 있다.  
예를 들어, 옛날 버전에 만든 객체 직렬화를 새로운 버전 클래스 객체로 역직렬화하려고 하면 오류가 발생할 것이다. 

그렇기 때문에 오랫동안 사용할 수 있는 고품질 직렬화 형식을 주의 깊게 설계해야 한다. 비록 초기 개발 비용은 증가하겠지만 가치는 충분하다. 

직렬 버젼(UID; serial version)이라는 이름으로 더 잘알려져 있는 스트림 고유 식별자(stream unique identifer)는 직렬화가 어떻게 클래스의 진화를 가로막는지 보여주는 사례다. 모든 직렬화 가능 클래스에는 고유한 식별 번호가 붙는다. 
필드를 명시적으로 선언하지 않으면, 시스템이 알아서 식별번호를 생성한뒤에 클래스에 붙인다. 

**Serializable을 구현시, 두번째 문제는 버그나 보안 취약점이 발생할 가능성이 높아진다는 것.** 

직렬화는 언어 외적인(extralinguistic) 객체 생성 메커니즘이다. 기본동작(default behavior)을 받아들이건 재정의(override)하건 간에, 역직렬화는 생정자와 동일한 이슈를 갖는 숨은 생성자이다. 

기본 직렬화를 그대로 사용하는 경우, 객체는 불변식 훼손 또는 불법 접근 문제에 쉽게 노출된다. 

**Serializable을 구현시 세 번째 문제는 새 버전 클래스를 내기 위한 테스트 부담이 커진다는 것이다.**

직렬화 가능 클래스 수정시, 새 릴리스를만들고 직렬화한 객체를 예전 릴리스에서 역직렬화가 가능한지 예전 릴리스에서 직렬화 하고 새 릴리스에서 역직렬화가 가능한지 검사가 중요. 
=> 필요한 테스트의 양은 직렬화 가능 클래스의 수 * 릴리스 수 
=> 확인해야할것은 이진 호환성(binary compatibility) 뿐만 아니라 의미 호환성(semantic compatibility)도 필요하다. 이진호완성 : 직렬화 - 역직렬화가 정상적으로 동작하는지 확인, 의미 호완성 : 직렬화- 역직렬화의 결과의 객체가 원래 객체에 충실한지도 의미적으로 확인. 

**Serializable 인터페이스를 구현한다는 것은 가볍이 볼 수 없는 결정이다.** 

직렬화를 통해 객체를 전송하거나 지속성 매체에 저장하는 프레임워크에 사용할 클래스라면 Serializable은 필수다. 그러나 가볍이 생각하면 안되고, 클래스 설계마다 득과 실을 저울질 해라. 
기본적인 규칙은 대부분의 클래스와 마찬가지로 Date나 BigInterger 같은 값 클래스는 Serializble로 구현해야 한다. 

**계승을 염두에 두고 설계하는 클래스는 Serializable을 구현하지 않는 것이 바람직하다. 또한 인터페이스는 가급적 Serializable을 계승하지 말아야 한다.** 

보통 이 규칙을 어기면 구현하는 개발자는 많은 부담을 안게 된다. 그치만 규칙을 어기는게 바람직할때도 있다. 
예를들어, Serializable을 구현한 객체만 참여가 가능한 프레임워크가 있다면, 클래스나 인터페이스가 Serializable을 구현한거나 계승하도록 해야 한다. 
=> 계승을 고려해서 설계된 클래스 가운데 Serializable을 구현하는 것은 Throwable, Component, HttpServelet이 있다. 
Throwable : 원격 메서드 호출시 발생하는 예외를 서버에서 클라이언트로 전달하기 위한것
Component : GUI를 전송,보관 복원할수 있도록.
HttpServelet : 세션상태를 캐시하기 위해서 사용

객체 필드를 갖는 클래스를 직렬화 가능하고 계승 가능한 클래스로 구현할때는 반드시 조심해야 할것이 있다. 객체 필드가 기본값으로 초기화 될때 위배되는 불변식이 있는 경우, readObjectNoDate 메서드를 클래스에 반드시 추가해야한다. 

```
private void readObjectNoData()throws InvalidObjectException(){
	throw new InvalidObjectException("Stream data required")
}
```

readObjectNoDate 는 기존 직렬화 가능 클래스에 새로운 직렬화 가능 클래스를 상위 클래스로 추가하는 드문 경우를 지원하기 위해 사용

Serializable을 구현하지 않기로 결정할때 주의할 점  :
계승을 고려하였지만 직렬화는 불가한 클래스에 대해선 직렬화 가능 하위 클래스 생성이 불가할수도 있다. 상위 클래스에 무인자 생성자가 없으면 직렬화 가능 하위 클래스 구현을 불가하다. **따라서 계승을 고려한 직렬화 불가능 클래스에는 무인자 생성자를 제공하는 것이 어떨지 따져봐야 한다.**
계승을 고려해서 만든 많은 클래스는 상태정보가 없으므로 무인자 생성자 구현이 어렵지는 않을것이나 꼭 그렇지는 않다. 

클라이언트가 제공하는 데이터가 있어야 불변식 충족이 가능하면 무인자 생성자는 사용이 불가하다 . 그러니까 무인자 생성자를 추가하고, 별도로 초기화 메서도도 클래스에 추가한다고 하자. 다른 생성자는 불변식을 충족하는 객체를 만들도록 구현되어 있다고 하자. 
무인자 생성자와 다른 생성자가 있어 상태공간(state space) 객체의 데이터가 복잡해지고 오류발생 가능성은 높아진다. 

이런 문제를 피하고 직렬화 불가능하지만 계승 가능 클래스에 생성자를 추가하는 방법이 있다. 

``` 
// 직렬화가 불가능한 상태유지 클래스, 하지만 직렬화가 가능한 하위 클래스를 만들수 있다.
public abstract class AbstractFoo {
	private int x,y;
	protected AbstractFoo() // 무인자 생성자
	public AbstractFoo(initialize(x,y)) // 불변식 충족 생성자
	protected final void initialize(int x, int y){
		...
	}
}
```

```
//직렬화 불가능 상태 유지 클래스의 직렬화 가능 하위 클래스
public class Foo extends AbstractFoo implements Serializable {

	public Foo(int x,int y) {super(x,y)} //상위클래스 생성자 호출
	private void readObject(){
		...
		initialize(x,y) // 상위 클래스에 initialize 메서드
	}
}
```

**내부 클래스는 Serializable을 구현하면 안된다.**
내부 클래스에서는 바깥 객체에 대한 참조를 보관하고 바깥 유효범위에 지역변수 값을 보관하기 위해 컴파일러가 자동으로 생성하는 인위 생성 필드(synthetic field)가 있다. 익명 클래스나 지역 클래스 처럼, 언어 명세서에는 이런 필드가 클래스 정의에 어떻게 들어 맞는지 나와 있지 않다. 따라서 **내부 클래스의 기본 직렬화 형식은 정의될 수 없다.**  
하지만 정적 멤버 클래스는 Serializable을 구현해도 된다.

요약하자면, Serializable을 구현하기 쉽다는 것은 사실이 아니다. 
잠깐 쓸게 아니라면 심각하게 Serializable을 구현해야 한다. 
계승을 고려하여 설계하는 클래스의 경우 조심해야 한다. 
완전히 Serializable을 구현하고 싶지는 않지만, 그렇다고 하위클래스의 Serializable구현을 막고 싶지도 않다면, 무인자 생성자를 제공하는 것이 방법이다. 
그래서 하위 클래스에서 Serializable을 구현할지 말지 선택할 수 있다. 

### 75. 사용자 지정 직렬화 형식을 사용하면 좋을지 따져보라

클래스 구현을 언제까지 끝내야하는 압박이 심할땐, 보통 최선의 API를 설계하는데 집중하는것이 바람직하다. 그러다 보면 다음 릴리스에 버릴 구현을 릴리스 하게 되는 일이 있는데, 만약 Serializaable을 구현한 클래스를 만들면서 기본 직렬화 형식을 그대로 이용하면, 기존 구현을 내버리기는 불가능해진다. 
-> 기본 직렬화 형식에 그대로 갇혀버리게 된다. 

**어떤 직렬화 형식이 적절할지 따져보지도 않고 기본 직렬화 형식을 그대로 받아들이지 마라**

그 인코딩의 유연성, 성능 그리고 정확성 관점에서 판단.

기본 직렬화 형식은 해당 객체가 루트(root)인 객체 그래프의 물리적 표현을 나름 효과적으로 인코딩한것이다. 

그런데 어떤 객체의 가장 효과적인 직렬화 형식은 해당 객체가 나타내는 논리적 데이터만 담아야 하며 물리적 표현과는 무관해야 한다. 

**기본 직렬화 형식은 그 객체의 물리적 표현이 논리적 내용과 동일할 때만 적절하다.**

논리적으로, 사람의 이름은 성, 이름, 중간이름으로 나누어 표현하는것이 논리적으로 옳고 기본 직렬화 형식을 써도 괜찮다. 

**설사 기본 직렬화 형식이 만족스럽다 하더라도 불변식이나 보안 조건을 만족시키기 위해서는 readObject 메서드를 구현해야 마땅한 경우도 많다.** 
예를들어, 특정 Name의 경우, null이 될 수 없다는 조건을 만족해야 한다. 

다음으로 네임과 다른 클래스도 하나 예를 들어보자. 
문자열의 리스트를 나타나내는 클래스 

논리적으로 말해서 이 클래스는 문자열 리스트를 표현한다. 
물리적으로는 이중 연결 리스트다. 
기본 직렬화 형태를 받아들이면 모든 연결 리스트 항목간 항목간 양방향 연결 구조가 직렬화 형식에 그대로 반영된다. 

객체의 물리젹 표현과 논리적 표현이 많이 다른경우, 기본 직렬화 형식 사용시 네 가지 문제가 발생. 


* 공개 API가 현재 내부 표현 형태에 영원히 종속 :
	* private으로 선언된 StringList.Entry 클래스는 public API의 일부분이 된다. 다음 릴리스에는 다른 내부 표현 방식을 채택해도 StringList 클래스느 여전히 연결 리스트 표현을 입력으로 사용해서 객체를 생성할 수 있어야 한다. 그래서 영원히 연결 리스트 항목 처리에서 코드제거는 불가하다.
*  너무 많은 공간을 차지하는 문제가 발생할 여지 있음 : 
	* 기본 직렬화 형식에는 리스트 항목 상이의 모든 연결정보가 쓸데없이 들어가 있다. 이런 정보는 구현 세부사항에 해당하는 정보로, 직렬화 형식에 포함시킬 가치는 없다. 
* 너무 많은 시간을 소비하는 문제가 발생 여지 
	* 기본 직렬화 로직은 객체 그래프 토폴로지 정보를 이해하지 못하므로, 많은 양의 그래프 순회를 해야 한다. 그런데 위 예제에서는 next를 참조로 따라 가는것만으로도 충분하다.  
* 스택 오버플로 문제가 발생할 여지 존재 
	* 기본 직렬화 절차는 재귀적인 객체 그래프 순회가 필요, 설사 객체 그래프가 크지 않더라 하더라도 과정에서 오버플로 문제가 발생할 수 있다. 

StringList의 적절한 직렬화 형식은 리스트에 담기는 문자열의 수 다음에 실제 문자열이 오는 형태. StringList의 논리적 데이터 형태만 나타내는 형식으로, 물리적 표현 형태에 대한 세부사항은 제거. 

수정자(modifier) transient는 클래스의 기본 직렬화 형식에 포함되지 않은 객체 필드임을 나타냄.

내 생각 에는 

```
public StringList implements Serializable

	private static class Entry implements Serializable

		...
```
StringList를 직렬화를 하면 , 그런데 불필요한 부분이 많다.

스트링 리스트  1 {
	Entry 1 { data: '문자열1', next: '주소1', prev:'주소2'},
	Entry 2 {...},
	...
}, ...
그냥 아래와 같이 하면 편하다.
스트링 리스트  : {
	'문자열1',
	'문자열2',
	...
}

책의 예제에서 기본 직렬화는 유연성도 떨어지고 성능도 별로지만 직렬화하고 역직렬화 했을때 나오는 객체가 충실한 사본이로 정확하다는 것은 맞다. 
하지만 특정 구현 세부사항에 종속된 불변식이 있는 객체라면 다르다. 

예를 들어, 해시 테이블을 생각하자면 ... 
키-값 쌍들이 들어 있는 해시 버킷이 쭉 나열된것이 해시 테이블의 물리... 
어떤 쌍이 어느 버킷에 들어갈지는 해시 코드에 따라 결정되는데 이 코드는 일반적으로 JVM에 따라 달라진다. 따라서 해시테이블에 기본 직렬화를 쓰면 심각한 버그가 발생 한다. 

기본 직렬화 형식을 사용하건 말건, transient로 선언되지 않은 모든 객체 필드는 defaultWriteObject 메서드가 호출될 때 직렬화된다. 따라서 transient로 선언할 수 있는 모든 객체 필드는 그렇게 선언해야 한다. 캐시된 해시 값처럼 기본 데이터 필드에서 계산될 수 있는 값을 담는 중복필드에도 transient를 붙여야 한다. 

JVM이 실행될때 마다 달라지는 값을 갖는 필드에도 마찬가지이다.  

**객체의 논리적 상태를 구성하는 값이라는 확신이 들기전에는 비-transient필드로 만들어야 겠다는 결정을 내리지 마라.** 

사용자 정의 직렬화 형식을 이용할때는 앞서 보았던 StringList처럼 객체 대부분을 
transient 해야 한다. 

기본 직렬화 형식을 사용하는 경우, transient가 붙은 필드들은 역직렬화가 되었을때, 기본 값으로 초기화가 된다. transient 필드에 초기화 값이 붙으면 안되는 경우, defaultReadObject를 호출하여 적절히 복구 시켜줘야 한다. 

기본 직렬화 형식 사용 여부에 상관 없이, **객체를 직렬화 할때는 객체의 상태 전부를 읽는 메서드에 적용할 동기화 수단을 반드시 적용해야 한다.** 

모든 메서드를 동기화해서 스레드 안정성을 달성하는 객체가 있다고 하고 기본 직렬화 형식을 사용하기로 했다면, writeObject 메서드에 synchronized 키워드를 붙여야 한다. 

 어떤 직렬화 형식을 사용하건 , 직렬화 가능 클래스를 구현할때는 직렬 버전(UID serial version UID)를 명시적으로 선언해야 한다. 
 그렇게 하면 직렬 버전때문에 생기는 잠재적 호완성 문제가 사라진다. 그리고 성능이 조금 개선되는 효과도 있다. UID를 명시하지 않으면 실행시간에 UID를 만든다고 시간이 많이 걸리는 계산을 하게 된다. 
```
private static final long serialVersionUID = 무작위로 고른 Long 값
```

새 클래스를 만드는 경우에는 어떤 값을 넣건 상관 없다. 클래스에 serialver 유틸리티를 돌려서 얻은 값을 넣어도 되고 아무값이나 하나 넣어도 된다. 
 하지만 직렬 버전 UID를 명시적으로 선언하지 않은 기존 클래스를 수정하되 이미 직렬화된 기존 객체까지 수용하고 싶다면 반드시 자동 생성된 기존 UID를 사용해야 한다. 

기존 버전과 호환되지 않는 새로운 클래스를 만들어도 상관 없다면 그냥 직렬 버전 UID 선언부의 값을 바꾸면 된다. 그 상태에서 기존 버전의 객체를 역직렬화 하면 InvalidClassException이 뜬다. 

요약하자면, 직렬화 가능 클래스를 만들기로 했다면, 직렬화 형식에 대해서도 심각하게 고민해야 한다. 기본 직렬화 형식은 그 형태가 객체의 논리적 상태에 부합할때만 사용해라. 아니라면, 객체의 논리적 상태를 적절히 표현하는 사용자 정의 직렬화 형식을 만들라. 외부로 공개되는 메서드를 설계하는데 많은 시간을 쓰는 것처럼, 직렬화 형식을 설계할때도 그만한 시간을 써라. 
일단 공개화된 메서드는 향후 버전에서 제거할 수 없듯이 
직렬화 형식에 포함시킨 필드는 나중에 제거할 수 없다. 직렬화 호완성을 보장하기 위해서이다. 직렬화 형식을 잘못 선택하면, 클래스의 복잡성과 성능 측면에 돌이킬수 없는 악영향을 미친다.
 


> Written with [StackEdit](https://stackedit.io/).
> 
