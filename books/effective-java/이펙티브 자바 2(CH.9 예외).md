
## 예외 

잘만 활용하면 예외는 프로그램의 가독성, 안정성 유지보수성을 모두 향상 시킨다. 반대의 효과도 내는데 이번장에서는 예외를 효과적으로 활용하기 위한 지침을 살펴본다.

### 57. 예외는 예외적 상황에서만 사용하라

try {
int i =0;
while(true) {
	range[i++].climb();
}
} catch( ArrayIndexOutOfBoundsException e){}

배열 범위 밖에 있는 첫번째 요소를 참조하는 순간 발생하는 예외를 보고 이를 무시하는 코드.

* 예외는 예외적 상황을 위해 고안된 것이기 때문에, JVM을 구현하는 사람 입장에서 보면 명시적 테스트만큼 빠르게 만들 필요가 없다. 
* try-catch 브록 안에 넣어둔 코드에는 최선 JVM이 사용하는 최적화 기법 가운데 일부가 적용 되지 않는다.
* 배열을 순회하는 표준숙어(standard idom)이 중복 검사를 하지는 않는다. 

최신 JVM을 돌려보면 예외를 통해 구현한 순환문이 표준적 순호나문보다 훨씬 느리다. 


예외는 예외적 상황에서만 사용하고 평상시 제어 흐름에서는 쓰지 말자
-> 굳이 에외처리를 해야하는 상황이 아닌데 예외처리를 하는게 사실 웃긴데 ㅋㅋ

### 58. 복구 가능 상태에는 점검 지정 예외를 사용하고, 프로그래밍 오류에는 실행지점 예외를 이용하라 

자바의 세 가지 Throwable 메서드. 

점검지정 예외(checked exception)
실행시점 예외(runtime exception)
오류(error)

[Throwable이란?](http://www.nextree.co.kr/p3239/)

점검지정 예외 VS 무점검 예외 
-> 누구를 사용하지?! 
-> 호출 측에서 복구할 상황을 통제한 다면 점검지정 예외를 이용해야 한다. 

API 사용자에게 점검 지정 예외를 준다는 것 == 잘못된 상태를 복구할 권한을 준다는 뜻 

무점검 예외는 실행 시점 예외와 오류 두가지가 있다. 
만약 무점검 예외나 오류가 던져지면 복구가 불가능 하다는 뜻으로 더 진행해봐야 실이 크다. 

프로그래밍 오류를 표현할때에는 실행시점 예외를 사용해라. 

자바언어의 명세는 아니지만, 보통 오류는 JVM이 자원 부족이나 불변식 위반등, 더 이상 프로개름을 실행할수 없을때 사용한다.
그리고 Error의 하위클래스는 만들지 않는 것이 최선. 

### 불필요한 점검 지정 예외 사용은 피하라

점검 지정 예외는 프로그래머로 하여금 예외적 상황을 처리하도록 강제하여 안정성으 ㄹ높인다. 
그런데 이렇게 예외를 받아 처리하는 할수도 있고 외부로 전파되도록 할 수도 있다. 프로그래머 입장에서는 번거롭다. 

그래서 리팩토링으로 상태검사 메서드를 새로 메서드를 만든다던가 ...

### 표준 예외를 사용하라

일반적으로 많이 재사용되는 예외들을 알아보자!

| 예외 | 용례  |
|--|--|
| IllegalArgumnetException | null이 아니고 인자의 값이 잘못되엇을시 |
| IllegalStateException| 객체 상태가 메서드 호출을 처리할 수 없을시  |
| NullPointerException| null이 값을 받으면 안되는 인자에 null이 전달시 |
| IndexOutOfboundsException | 인자로 주어진 첨자가 허용 범위를 넘었을시 |
| ConcurrentModificationException| 병렬적 사용이 금지된 객체에 병렬적 접근시|
| UnsupportedOperationException| 객체가 해당 메서드를 지원 하지 않을시|


### 추상화 수준에 맞는 예외를 던져라 

상위 계층에서 하취 계층에서 발생하는 예외를 받아 상위 계층 추상화 수준에 맞는 예외로 바꿔야 한다. 예외 변환

**예외 변환(exception transalation)**

// 예외변환(하위계층 -> 알맞은 상위계층)
try {
//낮은 수준의 추상화 계층
...
} catch (LowerLevelException e) {
	throw new HigherLevelException(...);
}

AbstractSequentialList 클래스에서 가져온 예외 변환 예제

**예외 연결(exception chaining)**
예외 변환의 특별한 사례
하위 계층에서 발생한 예제 정보가 상취 계층 예외를 발생시킨 문제를 디버깅하는데 사용
하위 계층 예외는 상위 계층 예외로 전달되는데, 상위 계층 예외에 있는 접근자 메서드를 호출하면 해당 정보를 볼 수 있다. 

//예외 연결
try {
... //낮은 수준의 추상화 계층 이용
} catch (LowerLevelException cause) {
	throw new HigherLevelException( cause );
}
즉 낮은 수준 추상화에서 발생한 cause를 상위 계층 예외 클래스의 생성자로 인자를 넘긴다. 

대부분의 표준 예외들은 예외 연결을 위한 생성자를 구비하고 있다. 
이를 통해서 최초에 발생한 예외의 스택 추적정보를 상취 계층 예외에 통합 할수 있다. 

요약하자면 최선은 예외가 발생하지 않도록 하는것이다!
다음으로 하위 계층 메서드가 예외 발생하는걸 막을 수 없다면, 어떻게든 하위계층에서 처리를 하자, 추가로 여기선 분석을 위해 log와 같은 기능을 활용하는게 좋다. 
마지막으로 예외를 막거나 처리를 할 수 없다면, 상위 계층에 보여주기 곤란한 예외는 예외 변한으로 처리를 하자 
-> 예외 변환을 통해 적절한 상위 계층 예외도 보여주고 하위계층 문제도 확인하고 오류 분석이 좋다! 

### 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라

점검지정 예외 문서화는 아주 중요하고 점검 지정예외는 독립적으로 선언하고 예외가 발생하는 상황은 javadoc @throws 태그를 사용해서 정확히 밝혀라

메서드가 던질 가능성이 있는 모든 무점검예외는 선언한 필요는 없으나 점검지정 예외와 같이 문서로 남겨놓으면 좋다. 

특히 인터페이스 메서드 문서에서 각 메서드는 발생할 수 있는 무점검 예외를 밝혀야 한다. 

요약하자면, 메서드가 던질 가능성이 있는 모든 예외를 문서로 남겨라. 점검 지정 예외뿐만 아니라 무점검 예외도 문서를 남겨라. 
점검 지정 예외는 메서드의 throws 절에 나열 
무점검 예외는 throws 절에 적지 마라. 

### 어떤 오류인지 드러내는 정보를 상세한 메세지에 담아라

무점검 예외시 프로그램이 죽으면 시스템은 예외 스택의 추적 정보(stack trace)를 출력한다. 
이 정보는 예외 객체의 toString 메서드. 따라서 toString 메서드가 반환하는 문자열에 오류원인 정보를 최대한 많이 담는것이 좋다,.

오류 정보를 포착하기 우해선, 오류 상세 메세지에 예외에 관계된 모든 인자와 필드의 값을 포함시켜야 한다. 

스택추적 정보에는 보통 예외가 발생한 지점의 파일이과 행번호가 담긴다. 
어떤 오류인지 주구장창 이야기 하는것 보다 소스 코드를 읽으면 필요한 정보를 얻을수 있다. 


사용자 레벨의 오류 메세지는 최종 사용자가 이애할 수있어야 하지만, 예외에 대한 상세 메세지는 프로그래머나 서비스 담장자가 오류 분석을 위한 것이므로 내용이 훨씬 중요하다.

예를들어
IndexOutOfBoundsException(int lowerBound, int upperBound, in index){
	
	super("Lower bound" + lowerBound +
		"Upper Bound" + upperBound +
		"Index " + index
	)
} 
불행이도 자바 플랫폼에서느 위에 숙어를 많이 활용하진 않지만 추천할만한 기법이다. 

### 실패 원자성 달성을 위해 노력하다

예외를 던지고 난 뒤에도 객체 상태가 잘 정의돈, 사용가능한 상태로 남으면 좋다 

실패 원자성(failure atomicity) : 메서드가 가지는 특징으로 지키면 좋은 특징. **메서드 호출이 정상적으로 처리되지 못한 객체의 상태는 메서드 전의 상태와 동일해야 한다.
** 

실패 원자성을 가지기 위해서 가장 간단한 방법은 변경 불가능 객체로 설계하는것
-> 왜냐하면 객체가 만들어지고 나면 상태 변경이 불가하기 때문에

변경 가능한 객체는 연산을 시작하기 전에 인자 유효성을 검사하는것이 가장 보편적
-> 실패할 가능성이 있는 코드를 전부 객체 상태를 바꾸는 코드 앞에 배치하자! 

다음으로는, 복구코드를 작성하는 것!
roll back과 같이 연산이 시작되기 전 객체 상태로 돌리기

마지막, 객체의 임시 복사본상에서 필요한 연산을 하고, 연산이 끝난 다음에 복사본의 내용으로 객체 상태를 바꾸는것  
-> 데이터를 임시 구조에 복사한 다음 신속하게 실행 할수 있는 연산이라면 좋다. 

요약하자면, 실패 원자성은 일반적으로 권장되지만 항상 이룰 수 있는것은 아니다. 
멀티스레드가 상황에서 ...
또한 예외와는 달리 오류는 복구가 불가 함으로 실패 원자성 지키려 할 필요 없다. 

### 예외를 무시하지 마라

catch 블록을 작성하고선 무시하지 마라

빈 catch 블록은 예외를 선언한 목적 그러니까 예외적 상황을 반드시 한다는 암묵적인 선언이다. 

예외가 발생해도 무시하는 것은 불이 났는데 불이 났는지 알수 없는것 ㅋㅋ

최소한 적어도 catch 블록안에는 예외를 무시해도 되는 이유라도 남겨야 한다. 








> Written with [StackEdit](https://stackedit.io/).
