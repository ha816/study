## 메서드

주요 포인트 
 1. 인자와 반환값은 어떻게 다루는 것이 좋은가? 
 2. 메서드 시그니처는 어떻게 설계할 것인가?
 3. 메서드 문서는 어떻게 만드는것이 바람직한가?

좋은 메서드의 관점은 세 가지
사용성(usability)
안정성(robustness)
유연성(flexibility)

### 38. 인자의 유효성을 검사하라

대부분의 메서드와 생성자는 인자로 사용하는 값을 제한한다. 

최대한 잘못된 메서드는 빨리 탐지하는게 좋고 메서드 시작부분에서 검사해야 한다.

public 메서드라면, 인자 유효성이 위반될 경우 발생하는 예외를 javadoc의 @throws 태그를 사용해서 문서화 해라

/**
*
* @throws ArithmeticException 
*/

public이 아닌 메서드라면, 패키지 개발자가 메서드가 호출되는 상황을 통제 할수 있으므로 유효한 인자가 전달될것을 생각 가능. 
따라서 public이 아닌 메서드는 인자 유효성을 검사할때 확증문(assertion)을 사용한다. 

메서드나 생성자를 구현할 때는 반을 수 있는 인자에 대한 제한이 있는지 따져봐야 한다.
그리고 제한이 있다면, 그 사실을 문서에 남기고 메서드 앞부분에서 검사해야 한다. 

### 39. 필요하다면 방어적 복사본을 만들라 

자바가 사용하기 편한 것은, 안전한 언어(safe language)이기 때문이다. 

만드는 클래스의 클라이언트가 불변식을 망가뜨리기 위해 최선을 다할것으로 가정하고 방어적으로 프로그래밍 하자

생성자 
생성자 메서드로 공격을 할때 특정 객체의 내부(필드)를 보호하려면 생성자로 전달되는 변경 가능 객체를 반드시 방어적으로 복사해서 활용!

인자 유효성 검사하기 전에 방어적 복사본을 만들고 복사본에 대해 유효성 검사를 한다. 
-> 이상한데
-> 인자를 검사한 직후 복사본이 만들어기 전까지의 구간 : 취약구간(window of vulnerability) 
-> 취약구간 동안에 다른 스레드가 인자를 변경해버리는 일을 막기 위한 것

인자로 전달된 객체의 자료형이 제 3자가 계승할수 있는 경우,  방어적 본사본 생성시 clone을 사용하지 말자. 
-> 특별히 설계된 하위 클래스에서 새로 만들어진 객체에 대한 참조가 가능

접근자
접근자의 경우 변경 가능 배부 필드에 대한 방어적 복사본을 반환 하도록 접근자를 수정해야 한다.

public Date start(){
	return new Date(start.getTime())
}
생성자 때와 달리 접근자에서는 clone메서드를 사용해도 된다. 
-> 왜냐하면 공격을 위해 설계된 클래스가 아니기 때문에 

클라이언트에게 내부 컴포넌트를 반환하기전에 만드는 클래스가 변경 가능이건 불가능이건 컴포넌트에 대한 참조를 반환할때는 고민해야 한다.

길이가 0이 아닌 배열은 항상 변경이 가능하다. 물론 변경 불가능한 배열인 뷰를 활용해도 된다.

객체의 컴포넌트는 가능하다면 변경 불가능 객체를 사용해야한다! -> 사실 그래야 방어적 복사본에 대해 신경쓸 필요가 없다 

### 40. 매서드 시그니처는 신중하게 설계하라.

 #### 메서드 이름은 신중하게 골라라.
 모든 이름은 표준 작명 관습(standard naming convention)을 따르자.

최우선 목표는 이해하기 쉬우면서 같은 패키지 안에서 일관성 있는 이름 유지할것

두번째 목표는 널리 합의된 관습에 맞는 이름을 고르자, 예를 들면 자바 라이브러리 API의 이름들

#### 편의 메서드(convenience method)를 제공하는데 너무 공들이지 마라라

모든 메서드는 맡은 일이 명확하고 거기 충실해야 한다. 
한 클래스에 메서드가 많으면 다양한 측면에서 어렵다. 
단축 메서드는 자주 쓰일때만 추가하자 잘 모르겠으면 일단 빼버려라

#### 인자 리스트(parameter list)를 길게 만들지 마라. 

최대한 줄여 4개 이하가 되도록 노력하자.
-> 인자 리스트가 길어지면 순서, 의미, 기억을 제대로 못함. 

긴 인자 리스트를 줄이는 방법은 크게 세 가지

 ##### 많은 인자를 여러 메서드로 나누자
 각각의 메서드는 원래 인자 리스트의 일부만 처리한다.	물론 메서드가 많아질수 있지만 제대로만 하면 오히려 줄일 수 있다.
 ##### 도움 클래스(helper class)를 만들어 인자들을 그룹별로 나누자
자주 등장하는 일련의 인자들을 묶어 하나의 별도 개체로 나타낼때 쓰면 좋다.
##### 모든 인자를 표현하는 객체를 만들자. 
앞선 두 가지 방법을 결합한 방법.
세터 메서드를 구현하여 값을 저장한다.
execute 메서드로 최종적 유효성 검사를 실행하고 실제 처리를 함.

#### 인자의 자료형으로는 클래스보다 인터페이스가 좋다

당연한 말이지만 인자를 정의한 인터페이스가 있다면, 인터페이스 구현 클래스 대신 인터페이스를 인자 자료형으로 쓰자

#### 인자 자료형으로는 boolean을 쓰기 보다, 원소가 2개인 enum을 쓰는것이 낫다.

추후 상수 추가에도 유리하고 일기에도 편안한 코드가 완성 된다.

### 오버로딩할땐 주의해라

재정의(overriden)가 일반적인 규범(norm)이라면 오버로딩(overloading)은 예외에 해당한다. 
norm : 일반적인 규범

오버로딩된 메서드 가운데 어떤 메서드가 호출될지는 컴파일 시점에서 결정된다. 
		
Collection<?>[] collections = { 
new HashSet<String>(),
new ArrayList<BigInteger>()
} ; 

public static String classify(Set<?> s){}
public static String classify(List<?> l){}
public static String classify(Collection<?><?> c){}

collections의 각 원소로 classify를 호출하면 세번째 classify 메서드가 실행된다. 
-> 컴파일 시점에서는 collections에 원소는 전부 단순히 Collection이다. 

즉 오버로딩된 메서드는 정적(static)으로 선택되지만, 재정의된 메서드는 동적(dynamic)으로 선택된다. 

따라서 오버로딩을 사용할때는 혼란스럽지 않게 주의하자. 
좋은 방법 : 같은 수의 인자를 갖는 오버로딩 메서를 최대한 만들지 말자. 만약 같은 수의 오버로딩 메서드가 많다고 해도 주어진 인자에 따라 어떤 오버로딩 메서드가 사용될게 확실하다면 문제가 없다. 두 오버로딩 메서드를 비교했을때 그 형식 인자 가운데 적어도 하나가 서로 형변환을 할 수 없다면 확실히 인자가 다르다는것(radically different)

### varargs는 신중히 사용하라

varargs 메서드 : 자바 1.5부터 추가된 메서드로, 공식적으로는 가변 인자 메서드(variable arity method)라 한다.
지정된 자료형의 인자를 0개 이상 받을 수 있다. 
전달한 인자의 수에 맞는 배열이 생성되고, 해당 배열에 인자가 대입되고, 메서드에 인자로 반환된다. 

public int sum(int... args){

varargs는 임의 갯수의 인자를 처리하는 메서드를 만들어야 할때 효과적
printf 메서드와 리플렉션에서 varargs를 엄청 사용

int[] digits = {1,2,3,4,5}
System.out.println(Arrrays.asList(digits));
자바 1.4전에서는 
Object[] -> int[]로 변환을 못해서 컴파일이 안되었지만 varargs 덕분에 1.5이후부터는 잘된다. 

마지막 인자가 배열이라고 해서 무조건 뜯어 고치진 말자, varargs는 정말로 임의 개수의 인자를 처리할 수 있는 메서드를 만들어야 할때만 사용하라. 

varargs는 항상 이자만큼 배열을 만들고 초기화 하기때문에 성능의 이슈가 있을 수 있다. 
메서드를 호출하는 빈도가 n개 이하의 라고 하면 n까지의 인자를 받는 오버로딩된 메서드를 만들면 성능에 도움이 된다.

public void foo() //n == 2
public void foo(int a1)
public void foo(int a1, int a2)
public void foo(int a1, int a2, int... rest)

### 43. null 대신 빈 배열이나 컬렉션을 반환해라

if( arr1 != null && Arrays.asList(arr1).contatin()){
}
null도 반환을 하게 되면 추가적으로 null처리를 위한 코드가 삽입되어야 한다. 게다가 클라이언트가 null처리를 잊을 수도 있다. 

컬렉션이나 빈 배열을 반환하면 배열 할당 비용이 드니까 null이 낫지 않냐
-> 낫기는 하겠지만 그런 수준정도로 성능을 걱정하는 것은 바람직하지 않다.
길이가 0인 배열은 변경이 불가능하므로 재약없이 재사용이 가능하다. 즉 만들어 둔 값을 그대로 호출해서 쓰면 된다.
private static final int[] emptyList = new Integer[0]; 

결론 : null 대신에 빈 배열이나 빈 컬렉션을 반환해라! 

### 44. 모든 API 요소에 문서화 주석을 달라

자바에는 javadoc이라는 유틸리티가 포함되어, 문서작업을 쉽게 할 수 있다. 

JavaDoc은 문서화 주석(documentation commnet)이라는 특별한 주석을 통해, 소스 코드로부터 API문서를 자동 생성한다. 

문서화 주석에는 해당 메서드의 모든 선행조건(precondition)과 후행조건(postcondition)을 나열해야 한다. 

클래스나 메서드의 스레드 안정성도 문서로 남겨야 한다. 

@param
@return
@throws

오라클의 How to Write Doc Comments를 꼭 읽어보자 










arity : 함수에 들어가는 인자 또는 연산자의 갯수를 말함 








예외적으로, 생성자 메서드는 주의할게 없다 
-> 생성자 메서드는 재정의(오버라이딩)가 불가하다. 










