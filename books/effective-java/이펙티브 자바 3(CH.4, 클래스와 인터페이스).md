# 클래스와 인터페이스

## Item13. 클래스와 멤버의 접근 권한은 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로 부터 얼마나 잘 숨겼느냐이다. 정보은닉 (information hiding), 혹은 캡슐화(capsulation)으로 불리는 이 개념은 소프트웨어 설계의 근간이 되는 원리다. 
 - 정보 은닉(information hiding)의 장점
	 - 의존성을 낮추어 여러 컴포넌트를 병렬적으로 개발, 테스트가 가능
	 - 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체 부담도 적다.
	 - 정보 은닉 자체가 성능을 높이지는 않지만, 성능 최적화에 도움을 준다.
	 - 재사용성을 높인다. 외부에 의존하지 않고 독자적으로 동작하는 컴포넌트라면 낯선 환경에서도 유용하게 쓰실 가능성이 크다.
	 - 큰 시스템의 제작 난이도를 낮춰준다. 시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.

자바는 정보 은닉을 위한 다양한 장치를 제공하는데, 그 중 접근 제어 매커니즘으로 클래스, 인터페이스, 멤버의 접근성(접근 허용 범위)을 명시하고 있다. 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자(access modifier)로 정해진다. 이 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다. 

기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.** 소프트웨어가 올바르게 동작하는 한 항상 가장 낮은 수준을 부여해야 한다는 뜻이다. 

(가장 바깥이라는 의미의) **탑 클래스와 인터페이스에 부여할 수 있는 접근 수준**은 크게 package-private과 public 두가지이다. public으로 선언하면 공개 API가 되고, package-private으로 하면 해당 패키지내에서만 사용할 수 있다. 원칙에 따라 패키지 내부에서 쓰이는게 아니라면 package-private으로 선언하자. 그러면 이들은 API가 아닌 내부 구현이 되어 언제든 수정이 가능하다. 즉 클라이언트에 수정이 없이 다음 릴리스에 언제든 수정이 가능하다. 반면 public은 API가 되므로 하위 호완을 위해 영원히 관리해줘야 한다. 

| 접근 권한 수정자 | 설명 |
|--|--|
|package-private| 해당 패키지 내에서만 유효한 개체 |
|public| 전역적 개체|

멤버의 접근 권한(필드, 메서드, 중첩 클래스(nested class), 중첩 인터페이스(nested interface)은 총 네가지 종류가 있다.

| 접근 권한 수정자 | 설명 |
|--|--|
|private| 선언된 멤버는 선언된 같은 클래스에서만 접근가능 |
|package-private(default)| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능; 기본 접근 권한으로 알려져 있음 |
|protected| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능할 뿐만 아니라 (다른 패키지에서) 선언된 클래스를 확장하는 하위 클래스에서도 접근가능|
|public| 선언된 멤버는 어디서도 접근가능|

private의 일반적인 오해는 private으로 선언한 변수는 해당 인스턴스만 접근할 수 있다고 생각하는 것이다. 같은 인스턴스는 아니지만 같은 타입의 모든 인스턴스가 private 멤버 변수에 접근이 가능하다. 

그 밖에 일반적으로 지켜야할 규칙은 아래와 같다. 
 - 객체 필드(instance field)는 public으로 선언하면 안된다.
	 - 필드에 저장될 값을 제한할 수 없다; 불변식을 강제하는게 불가하다.
	 - 변경가능한 필드를 가진 클래스는 다중 스레드에 안전하지 않다.
- 예외적으로 public static final은 사용 가능하나 참조하는 객체는 변경 불가능 객체로 만들어야 한다.

>핵심정리
>프로그램 요소의 접근성은 가능한 최소로 하자.(접근 제한이 최대한 강하게) 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다. public 클래스는 상수용 public static finall 필드외에는 어떠한 public 필드도 가져선 안된다. public static final 필드가 참조하는 객체가 불변인지 확인하라. 

### Item14. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라!

 private 필드와 public 접근자 메서드(getter, setter)를 사용하자. 패키지 바깥에서 접근할때 사용하려는 클래스의 접근자를 사용하여도록 하자. (예를 들면, getter) 그러면 사용되는 클래스 내부 표현 방식을 언제든 바꿀 수 있게 된다. 반면에 public 클래스의 데이터 필드를 공게하게 되면, 이를 직접 사용해서 가공하는 다수의 클라이언트가 생겨날 것이므로, 내부 표현 방식을 변경할 수가 없다. 

하지만 package-private 클래스나 private 중첩 클래스는 데이터 필드를 노출해도 하등 문제가 없다. 왜냐하면 패키지 내부에서만 쓰이는 코드이기 때문에 바깥의 코드는 아무 영향을 받지 않는다.

자바 플랫폼 라이브러리에도 public 클래스의 필드를 직접 노출하지 말라는 규칙을 어기는 사례가 종종 있다. 대표적으로는 java.awt.package의 Point와 Dimension클래스다. 이 **클래스들은 절대 흉내내지 말자.**

public 클래스의 필드가 만약 불변이라도 결코 좋은 생각이 아니다. API르

### 15. 변경 가능성을 최소화 하라

변경 불가능(immutable) 클래스는 그 객체를 수정할 수 없는 클래스

변경 불가능 클래스의 5가지 규칙
 1. 객체 상태를 변경하는 메서드(수정자 메서드등)을 제공하지 않는다.
 2. 계승할수 없도록 한다. 
 3. 모든 필드를 fianl로 선언한다. 
 4. 모든 필드를 private으로 선언한다.
 5. 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다(getter 메서드)
	 이경님 어록 : 변경가능한 필드에 대해서는 외부에서 수정할 수 없도록 하기위해서, 생성자나 접근자, readObject 메소드 안에 ‘방어적 복사본’ 을 만들어야 한다.
 
 immutable  클래스의 장점  
 1. 단순함
 2. 스레드에 안전
 3. 변경 불가능 객체는 자유롭게 공유가 가능
 4. 변경 불가능한 객체는 그 내부도 공유할 수 있다.
 5. 변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다. 
 6. 변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점

###16. 계승하는 대신 구성하라

composite than extends 
이 장에서는 자바의 extends를 말한다.

메서드 호출과 달리, 계승은 캡슐화 원칙을 위반하다.
왜? 하위 클래스가 동작하려면 상위 클래스에 의존적이다.
따라서 상위 클래스가 변경되면 하위클래스도 변경된다. 

여러 문제들이 존재


다행이도 이러한 문제를 해결할 방법이 존재
계승 하는 대신에 새로운 클래스에 기존 클래스 객체를 참조하는 private필드를 하나 두는것! = 이러한 설계 기법을 composite 기법이라고 한다. 

기존 클래스가 새 클래스의 일부(component)가 되기 때문이다. 
새로운 클래스에 포함된 각 메서드는 기존 클래스에서 필요한 것을 호출해서 결과를 활용한다. 이런 구현 기법을 전달(forwarding) 전달 기법을 사용해 구현한 메서드를 전달 메서드라고 부른다.  

wrapper(decorator) 클래스 : 계승 대신 구성을 사용하는 클래스
forwarding 클래스 : 재사용 가능한 전달 클래스

계승은 하위클래스가 상위 클래스의 하위 자료형이 확실한 경우에 쓰도록 합시다. is - a 관계

###17. 계승을 위한 설계와 문서를 갖추거나, 그럴수 없다면 계승을 금지해라

계승을 위한 설계와 문서를 갖춘다는 것은?
-> 매서드를 재정의하면 무슨일이 생기는지 문서로 남겨야 한다.
다시 말해, 재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남기라는것이다. 

계층을 위해 설계한 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는 것이다. 

계승 허용시 추가 제약사항
1. 생성자는 재정의 가능 메서드를 호출해선 안된다
2. clonable이나 serializable을 구현한다면 clone이나 readObject 메서드 안에서 재정의 가능한 메서드를 호출하지 말아야 한다.
3. Serializable 인터에스를 구현하는 클래스에 readResolve와 writeReplace 메서드가 있다면, protected로 선언해야 한다. 

이경 님 왈: Serializable을 구현한 클래스는 직렬화가 가능하다. 
### 18. 추상 클래스 대신 인터페이스를 사용해라

자바 언어에는 여러 구현을 허용하는 자료형을 만드는 방법이 두가지 -> 인터페이스와 추상 클래스(abstract class)

추상 클래스는 구현된 메서드를 포함 할 수 있다. 또한 추상 클래스가 규정하는 자료형 구현을 위해서 추상 클래스를 계승해야 한다. 

인터페이스의 장점
이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하기가 간단. -> implements로 구현
인터페이스는 믹스인을 정의하는데 이상적
-> 클래스가 주자료형 이외에 추가로 구현 자료형 가능한 자료형

비 계층적인 자료형 프레임워크를 만들수 있다. 
-> 꼭 자료형 계층으로 맞지 않는 것도 있다. 

포장 클래스 숙어(wrapper class idiom)를 통해 안전하면서 강력한 기능 개선 가능
-> 인터페이스 안에는 메서드 구현을 둘수 없지만, 추상 골격 구현 클래스(abstract skeletal implementation)를 중요 인터페이스마다 두면 인터페이스의 장점과 추상클래스의 장점을 얻을 수 있다. 인터페이스로는 자료형을 정의하고, 구현하는일은 골격 클래스가 한다. 
-> 관습적으로 이런 골격 클래스는 abstractInterface로 명명한다. 
-> HashSet은 abstractSet을 계승해서 쓰고 있다.

### 19. 인터페이스는 자료형을 정의할 때만 사용하라

 - 인터페이스는 골격, 즉 기능을 정의할때만 사용해라. 
 - 상수 인터페이스 패턴은 인터페이스를 잘못 사용하는 것이다.
 - 상수는 ENUM 으로 빼도록 하자

### 20. 태그 달린 클래스 대신 클래스 계층을 활용하라.

태그가 달린 클래스란? 
-> 두 가지 이상의 기능을 가지고 그 중 어떤 기능을 제공하는지 표시하는 태그가 달린 클래스

단점 
 1. 서로 다른 기능을 위한 코드가 모여 있어 가독성 하락
 2. 객체를 만들때마다 필요없응 기능을 위한 필드도 생성되어 메모리 추가 요구
 3. 객체의 자료형만봐서는 무슨 기능을 제공하는지 알수가 없다

결국 태그 기반 클래스 사용은 쓰지 말자

### 21. 전략을 표현하고 싶을때는 함수 객체를 사용해라 

함수 포인터, 대리자, 람다표현식 처럼 특정 함수를 호출 가능한 능력을 가지는 것들이 있다. 보틍은 함수의 인자로 함수를 전달하기 위해서 사용.

자바는 함수 포인터를 지원하지 않지만, 객체 참조를 통해 비슷하게 구현이 가능. 이런 객체를 함수 객체라고 한다. 

### 22. 멤버 클래스는 가능하면 static으로 선언하라.

중첩 클래스(nested class): 클래스 안에 정의된 클래스이다. 
중첩 클래스는 해당 클래스가 속한 클래스 안에서만 사용된다. 그렇지 않으면 중첩 클래스로 만들면 안된다.

 1. 정적 멤버 클래스 
 2. 비정적 멤버 클래스 
 3. 익명 클래스 
 4. 로컬 클래스
정적 멤버 클래스를 제외하면 모두 내부 클래스(inner class) 이다.

정적 멤버 클래스는 가장 간단한 중첩 클래스다. 정적 멤버 클래스는 바깥 클래스의 정적 멤버이며, 다른 정적 멤버와 동일한 접근 권한 규칙을 따른다.

비정적 멤버 클래스는 어댑터를 정의할때 많이 쓰인다. 바깥 클래스 객체를 다른 클래스 객체인것 처처럼 보이게 쓰인다. 

바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할때는 항상 선언문 앞에 static을 붙여서 비-정적 멤버 클래스 대신 정적 멤버 클래스로 만들자. 



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzgzODQwNTg1LDE5NzY5OTgzMDMsLTE2MD
Q5Njc0MTUsLTEyOTg1MTI4OTcsMTM3MTY3MTc3MSwxMzcxNjcx
NzcxLC0xMjU0NTE3NiwxMzcxNjcxNzcxLDMwNDEyMzc1MCwxND
c2Mjg3MTg3LDg2OTgzMzY3MSwxMzMzOTg5MTU1LC0yMDY4NjUx
NDIyLC0xNzcyNDIzNzMyLC0xNTgzNDMyMzIzXX0=
-->