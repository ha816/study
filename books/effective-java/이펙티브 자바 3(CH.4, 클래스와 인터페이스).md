# 클래스와 인터페이스

## Item15. 클래스와 멤버의 접근 권한은 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로 부터 얼마나 잘 숨겼느냐이다. 정보은닉 (information hiding), 혹은 캡슐화(capsulation)으로 불리는 이 개념은 소프트웨어 설계의 근간이 되는 원리다. 

정보은닉 -> 컴포넌트간 의존성을 낮춘다. 개발 관리 비용, 개발 난이도 하락 등등

 - 정보 은닉(information hiding)의 장점
	 - 의존성을 낮추어 여러 컴포넌트를 병렬적으로 개발, 테스트가 가능
	 - 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체 부담도 적다.
	 - 정보 은닉 자체가 성능을 높이지는 않지만, 성능 최적화에 도움을 준다.
	 - 재사용성을 높인다. 외부에 의존하지 않고 독자적으로 동작하는 컴포넌트라면 낯선 환경에서도 유용하게 쓰실 가능성이 크다.
	 - 큰 시스템의 제작 난이도를 낮춰준다. 시스템 전체가 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.

자바는 정보 은닉을 위한 다양한 장치를 제공하는데, 그 중 접근 제어 매커니즘으로 클래스, 인터페이스, 멤버의 접근성(접근 허용 범위)을 명시하고 있다. 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자(access modifier)로 정해진다. 이 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다. 

기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.** 소프트웨어가 올바르게 동작하는 한 항상 가장 낮은 수준을 부여해야 한다는 뜻이다. 

(가장 바깥이라는 의미의) **탑 클래스와 인터페이스에 부여할 수 있는 접근 수준**은 크게 package-private과 public 두가지이다.public으로 선언하면 공개 API가 되고, package-private으로 하면 해당 패키지내에서만 사용할 수 있다. 원칙에 따라 패키지 내부에서 쓰이는게 아니라면 package-private으로 선언하자. 그러면 이들은 API가 아닌  구현이 되어 언제든 수정이 가능하다. 즉 클라이언트에 수정이 없이 다음 릴리스에 언제든 수정이 가능하다. 반면 public은 API가 되므로 하위 호완을 위해 영원히 관리해줘야 한다. 

| 접근 권한 수정자 | 설명 |
|--|--|
|package-private| 해당 패키지 내에서만 유효한 개체 |
|public| 전역적 개체|필드, 메서드, 중첩 클래스(nested class), 중첩 인터페이스(nested interface)은 총 네가지 종류가 있다.

| 접근 권한 수정자 | 설명 |
|--|--|
|private| 선언된 멤버는 선언된 같은 클래스에서만 접근가능 |
|package-private(default)| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능; 기본 접근 권한으로 알려져 있음 |
|protected| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능할 뿐만 아니라 (다른 패키지에서) 선언된 클래스를 확장하는 하위 클래스에서도 접근가능|
|public| 선언된 멤버는 어디서도 접근가능|

private의 일반적인 오해는 private으로 선언한 변수는 해당 인스턴스만 접근할 수 있다고 생각하는 것이다. 같은 인스턴스는 아니지만 같은 타입의 모든 인스턴스가 private 멤버 변수에 접근이 가능하다. 

그 밖에 일반적으로 지켜야할 규칙은 아래와 같다. 
 - 객체 필드(instance field)는 public으로 선언하면 안된다.
	 - 필드에 저장될 값을 제한할 수 없다; 불변식을 강제하는게 불가하다.
	 - 변경가능한 필드를 가진 클래스는 다중 스레드에 안전하지 않다.
- 예외적으로 public static final은 사용 가능하나 참조하는 객체는 변경 불가능 객체로 만들어야 한다.

>핵심정리
>프로그램 요소의 접근성은 가능한 최소로 하자.(접근 제한이 최대한 강하게) 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다. public 클래스는 상수용 public static finall 필드외에는 어떠한 public 필드도 가져선 안된다. public static final 필드가 참조하는 객체가 불변인지 확인하라. 

## Item16. public 클래스에서는 public 필드 지  접근자 메서드를 사용

 private 필드와 public 접근자 메서드(getter, setter)를 사용하자. 패키지 바깥에서 접근할때 사용하려는 클래스의 접근자를 사용하여도록 하자. (예를 들면, getter) 그러면 사용되는 클래스 내부 표현 방식을 언제든 바꿀 수 있게 된다. 반면에 public 클래스의 데이터 필드를 공게하게 되면,  직접 사용해서 가공하는 다수의 클라이언트가 생겨날 것이므로, 내부 표현 방식을 변경할 수가 없다. 

하지만 package-private 클래스나 private 중첩 클래스는 데이터 필드를 노출해도 하등 문제가 없다. 왜냐하면 패키지 내부에서만 쓰이는 코드이기 때문에 바깥의 코드는 아무 영향을 받지 않는다.

자바 플랫폼 라이브러리에도 public 클래스의 필드를 직접 노출하지 말라는 규칙을 어기는 사례가 종종 있다. 대표적으로는 java.awt.package의 Point와 Dimension클래스다. 이 **클래스들은 절대 흉내내지 말자.**

public 클래스의 필드가 만약 불변이라도 결코 좋은 생각이 아니다. API를 변경하지 않고는 표현 방식을 바꿀수 없고, 필드를 읽을때 가공작업을 할 수 없다는 단점은 여전하다. 단 불변식은 보장한다. 

>핵심정리
>public 클래스는 절대 가변 필드를 직접 노출해서는 안된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수 없다. 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 (불변이든 가변이든) 필드를 노출하는 편이 나을때도 있다. 

## Item17. 변경 가능성을 최소화 하라

불변 (immutable)란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다. 불변 인스턴스는 가지는 정보가 고정되어 객체가 파괴되는 순간까지 절대 변하지 않는다. 자바 플랫폼 라이브러리에는 다양한 불변클래스가 있다. String, 기본 타입의 박싱 클래스, BigInter, BigDecimal등이 있다. 이렇게 불변으로 클래스가 설계된 이유는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.

* 불변 클래스를 만들기 위한 규칙
	* 객체 상태를 변경하는 메서드(수정자 메서드등)을 제공하지 않는다.
	* 클래스를 확장할 수 없도록 한다.
		* 하위 클래스에서 부주의하게 또는 나쁜 의도로 객체의 상태를 변경하는 사태를 막는다.  	* 모든 필드를 final로 선언한다.  모든 필드를 private으로 선언한다.
	* 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 
		* 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체 참조를 얻을 수 없게 해야 한다. 만약 가변객체를 getter메서드로 제공한다 하더라도 그대로 반환하면 안되고, **가변 객체의 방어적 복사본을 반환해야 한다.** 
		
피연산자와 함수를 적용해서 그 결과를 반환하지만, 기존에 피연산자 자체는 그대로이 프로그래밍 패턴을 함수형 프로그래밍이라고 한다. 반면에, 함수를 적용했을때 피연산자 자체를 수정하는 경우 절차적 혹은 명령형 프로그래밍이라고 한다. 
함수형 프로그래밍에서는 메서드 이름으로 add같은 동사 대신 plus같은 전치사를 사용한다는 점에도 주주하자. 이는 해당 메서드가 객체의 값을 변경하지 않는다는 사실을 강조한다. 참고로 이 명명 규칙을 따르지 않은 BigInter와 BigDecimal클래스를 사람들이 잘못 사용하는 경우가 종종 있다. 이렇게 함수형 프로그래밍을 따르면 불변이 되는 영역이 높아지는 장점을 누릴 수 있다. 

>불변 객체는 단순하다. 
>불변 객체는 생성된 시점의 상태를 그대로 간직한다. 반면 가변객체는 변경자 메서드가 일으키는 상태 전이를 정밀하게 문서로 남겨놓지 않으면 믿고 사용하기 어려울 수 있다. 

>불변 객체는 근본적으로 스레드 안전하여 동기화할 필요 없다.
>여러 스레드가 사용해도 절대 훼손되지 않는다. 

>불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체 끼리는 내부 데이터를 공유할 수 있 끼리는 내부 데이터를 공유할 수 있다. 
>객체를 만들때ㄸ
	  
 불변 클래스의 장점    함 . 에    체는      한  그 다른 불변 객체를의 구성요소로 사용하면 이점이 많다. 예를 들어, BigInteger 클래스는 내부에서 값의 부호(sign)과 크기(magnitude)를 따로 표현한다. 부호에는 int변수, 절대값에는 int 배열을 사용하는 것이다. 한편 negate 메서드는 크기는 같고 부호만 반대인 BigInter를 생성하는데, 배열은 비록 가변이지만 복사하지 않고 원본 인스턴스와 공유해도 된다. 그 결과 새로 만든 BigInter 인스턴스도 원본 인스턴스가 가리키는 내부 배열을 그대로 가리킨다. 

>객체를 만들때 그 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 값이 바뀌지 않는 불변 객체들로 이루어진 객체라면 그 구조가 아무리 복잡해도 불변식 유지가 쉽다. 좋은 예로, 불변객체는 맵의 키와 집합의 원소로 쓰기 좋다. 맵이나 집합안에 담긴 값이 바뀌면 불변식이 허물어 지는데 불변 객체를 쓰면 그런 걱정이 없다. 

>불변 객체는 단점도 있다.
>값이 다르면 반드시 독립된도 훌륭하다. 
 6.  .     은 다  객체를 만들어야 한다는 것이다. 값의 가짓수가 많으면 이들을 새로 객체로 만드는데 큰 비용이 든다. 점

**클래스가 불변임을 보장하려면 자신을 상속받지 못하게 해야 한다.** 가장 쉬운 방법은 final 클래스로 선언하는 것이지만 더 유연한 방법이 있다. 모든 생성자를 private 혹은 default로 두고 객체 생성을 위한 public static 정적 팩터리 메서드를 제공하는 것이다. 

사실 패키지 바깥 클래스에서 바라본 이 객체는 사실상 final 클래스이다. 왜냐하면 public이나 protected로 제공하는 생성자가 없으니 다른 클래스에서 확장이 불가능하기 때문이다. BigInter와 BigDecimal을 설계할 당신에 불변객체가 사실상 final 이어야 한다는 생각이 널리 퍼지지 않았다. 그래서 두 클래스의 메서드들을 재정의 할 수 있게 설계되었고, 하위 호완성 때문에 지금도 이 문제를 고치지 못했다. 만약 신뢰할 수 없는 클라이언트로 부터 BigInteger나 BigDecimal을 인수로 받는 다면 주의해야 한다. 이 값들을 불변 객체로 가정했는데 알고 보니 **불변객체를 확장한 가변 객체일수가 있다.** 다시 말해 신뢰할 수 없는 하위 클래스로 확인되면 가변 객체라고 생각하고 방어적으로 복사를 해서 사용해야 한다. 

**클래스는 꼭 필요한 경우가 아니면 불변이어야 한다.** 불변 클래스는 장점이 많으며, 단점이라곤 특정 상황에서 잠재적 성능 저하 뿐이다. 성능 때문에 어쩔 수 없다면 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하도록 하자. 

한편 모든 클래스를 불변으로 만들 수는 없다. 대신 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자. 꼭 변경해야할 필드를 뺀 나머지 모두를 final로 선언하자. 다른 합당한 이유가 없다면 모든 필드는 private final이어야 ###1자바의 extends를 말한다. 

**생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.**  확실한 이유가 없다면 생성자와 정적 팩터리외에는 그 어떤 초기화 메서드도 public으로 제공해서 안된다. 객체를 재활용하려는 목적으로 상태를 다시 초기화하는 메서드도 안된다. 복잡성만 커지고 성능이점은 거의 없다. 

## Item18. 상속보다는 컴포지션을 사용하라

이번 장에서 논하는 문제는 인터페이스 상속(클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장)과는 무관하다. 
상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 코드를 만들게 된다. 상위 클래스와 하위 클래스 모두 같은 개발자가 통제하는 패키지 안에서라면 상속도 안전한 방법이다. 확장할 목적으로 설계되었고 문서화도 잘된 클래스도 마찬가지로 안전하다. 하지만 일반적인 구체 클래스를 패키지 경계를 넘어 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.  

**메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.**  다르게 말하면, 상위 클래스가 어떻게 구현되었느냐에 따라 하위 클래스의 동작에 이상이 발생할 수 있다. 상위 클래스의 내부 구현이 달라지면 그 여파로 아무것도 수정하지 않은 하위 클래스가 오동작할 수 있다는 말이다.

다행이도 이러한 문제를 해결할 좋은 방법이 있다. 기존 클래스를 확장존재
계승 하는 대신,에 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자. **새로운 클래스가 기존 클래스를 구성요소로 쓴다는 뜻에서 이를 컴포지션(Composition; 구성) 기법이라고 한다.** 새로운 클래스의 메서드는 기존 클래스에 대응하는 메서드를 호출해서 그 결과를 반환한다. 이런 방식을 전달(forwarding)이라하며 새 클래스의 메서드들을  전달 메서드(forwarding method)라 부른다. **컴포지션과 전달의 조합은 넓은 의미로 위임(delegation)이라 부른다.** 그 결과 새로운 클래스는 기존 클래스의 내부 구현방식에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향이 없다. 
```
// Forwaringding Class - 재사용할 수 있는 새로운 전달클래스
public class ForwardingSet<E> implements Set<E> {
	private final Set<E> s;
	public ForwardingSet(Set<E> s) {this.s = s;}
	
	public void clear() {s.clear();}
	public boolean contains(Object o) {return s.contains(0)l}
	public boolean isEmpty() {return s.isEmpty();}
	...
	public boolean add(E e) {return s.add(e);}
	public boolean remove(Object o) {return s.remove(o);}
	...
}
```
아래 InstrumentedSet 클래스는 앞서 ForwardingSet 클래스를 상속한다. 이 클래스는 Set 인터페이스를 구현한 인스턴스를 인수로 받는 생성자를 제공하고 임의의 Set 크기 계측 기능(addCount)을 추가했다. 앞서 ForwardingSet은 단지 forwarding만 하는 반면에 InstrumentedSet는 계측 기능을 추가하였다. 이렇게 다른 Set 인스턴스(ForwardingSet의 Set 인스턴스)에 추가기능을 Wrap했다고 하여 InstrumentedSet 클래스를 래퍼(Wrapper) 클래스 혹은 데코레이터(Decorator) 클래스라 한다. 컴포지션을 이용하며 기능을 추가하는 패턴을 데코레이터 패턴이라고 이해할 수 있다.
```
// Wrapper(Decorator) Class - 상속 대신 컴포지션을 사용; ForwardingSet에 Set 인스턴스로 컴포지션을 구성
public class InstrumentedSet<E> extends ForwardingSet<E> {
	//	private final Set<E> s; -- ForwardingSet에 있다. 
	private int addCount = 0;
	public InstrumentedSet(Set<E> s) {super(s);}
	@Override public boolean add(E e){
		addCount++;
		return super.add(e);
	}	
	@Override public boolean addAll(Collection<? extends E> c){
		addCount += c.size();
		return super.addAll(e);
	}
	public int getAddCount() { return addCount;}
}
```

데코레이터 클래스는 단점이 거의 없다. 래퍼 클래스가 콜백 프레임워크와는 어울리지 않는다는 점만 빼면 말이다. 콜백 프레임 워크에서는 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출때 사용하도록 한다. 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르니 대신 자신의 참조인 내부 객체를 넘기고, 콜백때는 래퍼가 아닌 이 내부객체를 호출하게 된다. 이를 SELF 문제라고 한다. 

전달 메서드(Forwarding Method)의 성능과 데코레이터 클래스의 메모리 사용량 등을 걱정하는 사람이 있지만 실전에서는 큰 문제가 없다. 그냥 써도 된다. 물론 전달 메서드들을 작성하는게 귀찮겠지만, 전달 클래스를 인터페이스당 하나만 만들어 두면 전달 클래스를 아주 손 쉽게 만들 수 있다. 실제 Guava는 모든 컬렉션 인터페이스용 전달 메서드를 전부 구현해뒀다. 

다시 돌아와 그럼 도대체 상속은 언제 사용하는지 말하자면, **상속은 하위클래스가 상위 클래스의 하위 자료형이 정말로 진짜 확실한 경우에 쓰도록 한다.** 다르게 말하면 하위 클래스 B가 클래스 A와 is-a관계 일때만 클래스 A를 상속해야 한다. 상속을 사용하기로 결정했다면 마지막으로 자문해야할 질문들이 있다. 

* 상속받으려는 클래스의 API에 아무런 결함이 없는가?
	* 결함이 있다면,  상속받아 구현하려는 클래스의 API까지 전파되어도 괜찮은가?

**컴포지션을 사용하면 이런 상속의 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스 API의 결함마저도 그대로 승계한다.** 

컴포지션을 써야할 상황에 상속을 사용하는 것은 내부 구현을 불필요하게 노출하는 것이다. 그 결과 API가 내부 구현에 묶이고 클래스의 성능도 제한된다. 더 심각한 문제는 클라이언트가 노출된 내부에 직접 접근할 수 있다는 점이다. 이는 사용자를 굉장히 혼란스럽게 할 수 있다. 

>핵심 정리
>상속은 강력하지만 정보은닉(캡슐화)를 해친다는 문제가 있다. 상속은 반드시 상위 클래스와 하위 클래스가 순수한 is-a 관계일때만 써야한다. is-a관계라고 하더라도 안심할 수 없는 게, 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다. 상속의 약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 특히 Wrapper 혹은 Decorator 클래스를 구현할 적당한 인터페이스가 있다면 더욱 좋다. Wrapper 혹은 Decorator 클래스는 하위 클래스 보다 견고하고 강력하다.

## Item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

Item18 에서는 상속을 염두에 두지 않은 클래스이자, 상속할 때의 주의점도 문서화하지 않은 패키지 외부에 클래스를 상속할때 위험을 경고했다. 자 이제 상속을 고려한 설계와 정확히 문서화가 뭔지 이야기해보자.

우선, 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다. 다시 말해, 상속용 클래스는 재정의할 수 있는재정의 가능 메서드들을를 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다. 

클래스의 API로 공개된 (public, protected) 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다. 그런데 마침 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. 덧붙여서 어떤 순서로 호출하는지, 각각의 호출결과가 이어지는 처리에 어떤 영향을 주는지도 적어야 한다. 여기서 재정의 가능 메서드란 public, protected 이면서 final이 아닌 모든 메서드를 말한다. **반드시 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.** 

API 문서의 메서드 설명 끝에 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주서에 @implSpc 태그를 붙여주면 자바독 도구가 생성해준다. 

 하지만 사실 이렇게 API가 자세히 무엇을 하는지를 설명한다면 캡슐화를 해치는 것이 아닌가? 그렇다. 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 현실이다. 클래스를 안전하게 상속하려면 (상속이 아니었다면 기술하지 않아도 됬을) 내부 구현 방식을 설명해야만 한다. @implcSpec 태그는 자바 8에 도입되어 자바 9부터 본격적으로 사용되기 시작했다. 이 태그가 기본값으로 활성화되어야 바람직하다고 생각하지만 자바 11의 자바독에서도 선택사항이다.

이처럼 내부 매커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다. 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 **훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.** 드물게는 protected 필드로 공개해야 할 필요가 있을 수도 있다. 예를 들어 java.Util.AbstractList의 removeRange 메서드를 예로 살펴보자. 

>protected void removeRange(int fromIndex, int toIndex)
>
>fromIndex(포함)부터 toIndex(미포함)까지의 모든 원소를 이 리스트에서 제거한다. toIndex 이후의 원소들은 앞으로 (index만큼씩) 당겨진다. 이 호출로 리스트는 toIndex - fromIndex 만큼 짧아진다. (toIndex == fromIndex라면 아무 효과가 없다.)
>
>이 리스트 혹은 리스트의 부분 리스트에 정의된 clear 연산이 이 메서드를 호출한다. 리스트 구현의 내부 구조를 활용하도록 이 메서드를 재정의하면 이 리스트와 부분 리스트의 clear 연산 성능을 크게 개선할 수 있다. 
>Implementation Requirements:  이 메서드는 fromIndex에서 시작하는 리스트 반복자를 얻어 모든 원소를 제거할 때까지 ListIterator.next와 ListIterator.remove를 반복 호출하도록 구현되었다. **주의: ListIterator.remove가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례한다.**

List 구현체의 최종 사용자는 removeRange 메서드에 관심이 없다. 그럼에도 이 메서드를 제공한 이유는 단지 하위클래스에서 부분 리스트의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서다. removeRange 메서드가 없다면 하위 클래스에서 clear 메서드를 호출하면 (제거할 원소 수의) 제곱에 비례해 성능이 느려지거나 부분 리스트의 메커니즘을 밑바닥 부터 새로 구현해야 했을 것이다. 만만치 않은 일이다. 

그렇다면 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할까? 안타깝게도 정답은 없다. 심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선이다. protected 메서드는 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적어야 한다. 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다. 

**상속용 클래스를 시험하는 벙법은 직접 하위 클래스를 만들어보는 것이 유일하다.** 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할때 확연히 티가 난다. 거꾸로 하위 클래스를 여러개 만들때 까지 전혀 쓰이지 않는 protected 멤버는 사실 pirvate이어야 할 가능성이 크다. 경험상 이러한 검증에는 하위 클래스 3개 정도가 적당하다. 그릭 이 중 하나 이상은 제 3자가 작성해봐야 한다. 

널리 상속용으로 쓰일 클래스를 설계한다면 무서화한 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정을 영원히 끝까지 책임져야 한다. 이 결정들이 해당 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다. 그러니 상속용으로 설계한 클래스는 **반드시 배포 전에 하위 클래스를 만들어 검증해야 한다.** 
또한, 상속하려는 사람을 위해 덧붙인 설명은 단순히 그 클래스의 인스턴스를 만들어 사용하려는 프로그래머에게는 필요없다. 일반적인 API 설명과 상속용 설명은 구분하는게 좋다.

상속을 허용하는 클래스가 지켜야 할 제약이 아직 몇 개 남았다. 상속용 클래스의 **생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.** 이 규칙을 어기면 프로그램이 오동작할 것이다. 상위 클래스의 생성자가 하위 클래스의 생성자 보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자 보다 먼저 호출된다. 이때 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다. 

```
public class Super {
	public Super() { overrideMe();}
	public void overrideMe(){ }	
}

public class Sub extends Super {
	private final Instant instant;
	Sub() { instant = Instant.now(); }

	@Override public void overrideMe() {
		System.out.println(instant)
	}
	public static void main(String[] args){
		Sub sub = new Sub();
		sub.overrideMe();
	}
}
```
Sub 하위 클래스를 생성하면 상위의 overrideMe를 호출하게 된다. 그리고 이때 null을 출력한다. 왜냐하면 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화 하기도 전에 overrideMe를 호출하기 때문이다. 
추가적으로 final 필드의 상태를 생각해보자. 원래의도는 생성뒤 변경 불가를 원했지만 상위 생성자에서 먼저 overrideMe 메서드를 호출하기 때문에 NPE 에러가 난다. 위 프로그램이 에러가 나지 않은 이유는 println이 null값도 처리를 하기 때문이다. 

```
private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다. 
```

cloneable과 Serializable 인터페이스는 상속용 설계시 문제를 더 어렵게 만든다. 둘 중 하나라도 구현한 클래스를 상속 가능하게 설계하는 것은 일반적으로 좋지 않다. 그 클래스를 확장하려는 프로그래머에게 엄청난 부담을 주기 때문이다. 물론 인터페이스들을 하위 클래스에서 구현하도록 하는 특별한 방법도 있다. 

clone과 readObject메서드는 생성자와 비슷한 효과를 낸다. 따라서 상속용 클래스에서 Cloneable과 Serializable을 구현할지 정해야 한다면, 이들을 구현할때 따르는 제약도 생성자와 비슷하다는 점에 주의하자. 즉 **clone과 readObject 모두 직간접적으로 재정의 가능 메서드를 호출해서는 안된다.** readObject의 경우 하위 클래스의 상태가 역직렬화 되기전에 재정의한 메서드가 호출된다. clone의 경우 clone 메서드가 복제본의 상태를 수정하기전에 재정의한 메서드를 호출하게 된다. 두 가지 모두 프로그램 오작동으로 이어진다. 

마지막으로, Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 구현해야 한다. private으로 선언하면 하위 클래스에서 무시되기 때문이다. 이 역시 상속을 허용하기 위해서 내부 구현을 클래스 API로 공개하는 예다.

거듭강조하지만 상속 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다. 상속을 금지하는 방법은 final을 클래스에 선언하는 방법과 모든 생성자를 private이나 default로 선언하고 정적 팩터리를 만들어주는 방법이다. 

>핵심 정리
>상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화 한것은 그 클래스가 쓰이는 한 반드시 지켜져야 한다. 그렇지 않으면 내부 구현방식을 믿고 활용하던 하위 클래스가 오동작하게 될 수 있다. 다른 개발자가 효율적인 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않는다면 상속을 금지하는 편이 낫다. 상속을 금지하는데는 final이나 생성자 모두를 외부에서 접근할 수 없도록 하자. 

## Item.20 추상 클래스보다는 인터페이스를 우선하라

자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스 두 가지이다. 자바 8부터는 인터페이스도 디폴트 메서드(default method)를 제공할 수 있게 되어 이제 인터페이스와 추상 클래스 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다. 

인터페이스와 추상 클래스의 가장 큰 차이는 **추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 것이다.** 자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는데 큰 제약이 있다. 반면에 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입이 된다.

**기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.**  인터페이스가 요구하는 메서드를 추가하고 클래스 선언에 implements만 추가하면 된다. 자파 플랫폼에서도 Comparable, Iterable, AutoCloseable 인터페이스가 새로 추가 됬을때 수많은 기존 클래스에 인터페이스가 구현된체 배포가 되었다. 반면에 기존 클래스 위에 새로운 추상 클래스를 끼워넣는것은 어려운게 일반적이다. 두 클래스가 같은 추상 클래스를 확장하길 원한다면, 그 추상 클래스는 계층 구조상 두 클래스의 공통 조상이어야 한다. 안타깝게도 이 방식은 클래스 계층 구조에 큰 혼란을 야기한다. 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 되는 것이다. 

**인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.** 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택정 행위를 제공한다고 선언하는 효과를 준다. 예를 들어, Comparable의 경우, 구현한 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 mixin 인터페이스이다. 이처럼 대상 타입의 주된 기능에 선택적 기능을 혼합(minin)한다고 해서 믹스인이라 한다. 
추상클래스로는 믹스인을 정의할 수 없다. 이유는 기존 클래스에 덧씌울 수 없기 때문이다. 클래스는 두 부모를 상속 받을 수 없고, 계층 구조에서는 믹스인을 삽입하기 적합한 구조가 아니다. 

인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다. 타입을 계층적으로 정의하면 수 많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에서는 계층을 엄격하게 구분하기 어려운 개념도 있다. 

래퍼(데코레이터) 클래스와 함게 사용하면 인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 된다. 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다. 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 쉽다. 

### 디폴트 메서드(default method)
인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해 개발자의 일감을 덜어줄 수 있다. 대표적인 예로는 removeIf 메서드를 보자. 디폴트 메서드를 제공할때는 상속하려는 사람을 위한 설명을 @implSpec 자바 독을 붙여 문서화를 해야 한다. 그러나 디폴트 메서드에도 제약은 있다. 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없다. 그리고 여러분이 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다. 

### 추상 골격 구현(skeletal implementation) 클래스
한편, **인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공**하는 식으로 인터페이스와 추상 클래스의 장점 모두를 취하는 방법도 있다. 인터페이스로 타입을 정의하고, 필요하면 디폴트 메서드도 몇개 함께 제공한다. 그리고 골격 구현 클래스는 나머지 메서드들까지 구현한다. 이렇게 하면 단순히 골격 구현 클래스를 확장하는 것만으로 이 인터페이스를 구현하는데 필요한 일이 대부분 완료된다. 이것이 바로 템플릿 메서드 패턴이다. 

관례상 인터페이스 이름이 interface라면, 그 골격 구현 클래스는 이름은 AbstractInterface라고 짓는다. 좋은 예로 컬렉션 프레임워크의 AbstractCollection, AbstractSet, AbstractList, AbstractMap 각각이 바로 핵심 컬렉션 인터페이스의 골격 구현이다. 제대로 설계했다면 골격 구현은 개발자가 구현해야하는 코드양을 상당히 덜어준다. 아래 예를 보면 완벽히 동작하는 List 구현체를 반환하는 정적 팩터리 메서드로, AbstractList 골격 구현을 활용했다. 

```
static List<Integer> intArrayAsList(int[] a) {
	Objects.requireNonNull(a);
	
	return new AbstractList<>() { // 추상List의 구현체
		@Override public Integer get(int i) {
			return a[i];
		}
		@Override public Integer set(int i, Integer val) {
			int oldVal = a[i];
			a[i] = val;
			return oldVal;
		}
		@Override public int size() {
			a.length;
		}
	};
}
```
골격 구현 클래스는 추상 클래스 처럼 구현을 도와주는 동시에 추상 클래스로 정의했을때 오는 심각한 제약에서 자유롭다는 점이 장점이다. 골격 구현을 확장하는 것으로 인터페이스 구현은 거의 끝나지만, 꼭 이런게 할 필요는 없다. 구조상 골격 구현 클래스를 확장할 수 없다면 인터페이스를 직접 구현해야 하는데, 이런 경우라도 인터페이스가 제공하는 디폴트 메서드의 이점을 누릴 수 있다. 

골격 구현 클래스를 우회적으로 이용할 수도 있다. 인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달하는 것이다. 이 방법을 다중 상속(simulated multiple inheritance)라 하며, 다중 상속의 많은 장점을 제공하는 동시에 단점은 피하게 해준다. 

골격 구현(skeletal implementation)의 작성은 상대적으로 쉽다. 가장 먼저, 인터페이스를 살펴 다른 메서드들의 구현에 사용되는 기반 메서드를 선정한다. 이 기반 메서드들은 골격 구현에서 추상 메서드가 될것이다. 그 다음으로 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공한다. **단 equals와 hashCode와 같은 Object의 메서드는 디폴트 메서드로 제공하면 안된다는 사실을 항상 유념하자.** 

만약 인터페이스의 모든 메서드가 기반 메서드와 디폴트 메서드가 된다면 골격 구현 클래스를 별도로 만들 필요는 없다. 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남아 있다면 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 만들어 넣는다. 골격 구현 클래스에는 필요하면 public이 아닌 필드와 메서드를 추가해도 된다. 

간단한 예로 Map.Entry 인터페이스를 살펴보자. getKey, getValue는 확실히 기반 메서드이며, 선택적으로 setValue도 포함할 수 있다. 이 인터페이스는 equals와 hashCode의 동작 방식도 정의해놨다. Object 메서드들은 디폴트 메서드로 제공해서는 안되므로, 해당 메서드들은 모두 골격 구현 클래스에 구현한다. toString도 기반 메서드를 사용해 구현해놨다. 

```
// 골격 구현 클래스(skeletal implementation)
public abstract class AbstractMapEntry<K,V> implements Map.Entry<K,V> {

	//변경 가능한 엔트리는 이 메서드를 반드시 재정의해야 한다.
	@Override 
	public V setValue(V value) {
		throw new UnsupprtedOperationException();	
	}
	// Map.Entry.equals의 일반 규약을 구현한다.
	@Override 
	public boolean equals(Object o){
		if(o == this) return true;
		if(!(o instanceof Map.Entry)) return false;
		Map.Entry<?,?> e = (Map.Entry) o;
		return Objects.equals(e.getKey(), getKey()) && Objects.equals(e.getValue(), getValue())
	}
	// Map.Entry.hashCode의 일반 규약을 구현한다.
	@Override 
	public int hashCode(){
		return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
	}
	@Override 
	public String toString(){
		return getKey() + "=" + getValue();
	}
}
```

> Map.Entry 인터페이스나 그 하위 인터페이스는 이 골격 구현을 제공할 수 없다. 디폴트 메서드는 equals, hashCode, toString과 같은 Object메서드를 재정의할 수 없기 때문이다. 

**골격 구현은 기본적으로 상속해서 사용하는걸 가정**하므로 Item.19에서 이야기한 설계 및 문서화 지침을 모두 따라야 한다. **인터페이스에 정의한 디폴트 메서드든 별도의 추상 클래스든, 골격 구현은 반드시 그 동작 방식을 잘 정리해 문서로 남겨두어야 한다.** 

### 단순 구현(simple implementation)

단순 구현(simple implementation)은 골격 구현의 작은 변종으로, AbstractMap.SimpleEntry가 좋은 예다. 단순 구현도 골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만, 추상 클래스가 아니란 점이 다르다. 쉽게 말해 동작하는 가장 단순한 구현이다. 이런 단순 구현은 그대로 써도 되고 확장해도 된다.

>핵심정리
>일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 것을 꼭 고려해보자. 골격 구현은 '가능한 한' 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다. '가능한 한'이라고 한 이유는, 인터페이스에 걸려있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문이다. 

## Item.21 인터페이스는 구현하는 쪽을 생각해 설계하라.

자바 8 전에는 기존 구현체를 파괴하지 않으면서 인터페이스에 메서드를 추가할 방법이 없었다. 인터페이스에 메서드를 추가하면 보통은 컴파일 오류가 나는데, 추가된 메서드가 우연히 기존 구현체에 이미 존재할 가능성은 아주 낮기 때문이다. 자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 마들었지만 위험이 완전히 사라진 것은 아니다. 

디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 이처럼 자바에도 기존 인터페이스에 메서드를 추가하는 길이 생겼지만 모든 클래스가 매끄럽게 연동되리란 보장은 없다. 

자바 7까지의 세상에서는 모든 클래스가 현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다고 가정하고 작성했다. **디폴트 메서드는 구현 클래스에 대해 아무것도 모른체 합의 없이 무작정 삽입될 뿐이다.** 

자바 8 에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다. 주로 람다를 활용하기 위해서다. 자바 라이브러리의 디폴터 메서드는 코드 품질이 높고 범용적이라 대부분 상황에서 잘 동작한다. 하지만 생각할 수 있는 **모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.** 

자바 8의 Collection인터페이스에 추가된 removeIf 메서드를 보자. 이 메서드는 주어진 boolean 함수(predicate)가 true를 반환하는 모든 원소를 제거한다. 디폴트 구현은 반복자를 이용해 순회하면서 각 원소를 인수로 넣어 predicate을 호출하고, true를 반환하면 반복자의 remove 메서드로 그 원소를 제거한다. 

```
default boolean removeIf(Predicated<? super E> filter){
	Objects.requireNonNull(filter);
	boolean result = false;
	for(Iterator<E> it = iterator(); it.hasNext();) {
		if(filter.test(it.next())) {
			it.remove();
			result = true;
		}
	}
	return result;
}
```
위 코드는 아마 실제 구현일 것이다. 이 보다 더 범용적으로 구현하기도 어렵겠지만, 그렇다고 현존하는 모든 Collection 구현체와 잘 어울러지는 것은 아니다. 대표적인 예로 SynchronizedCollection가 있다. 이 클래스는 java.util의 Collections.synchronizedCollection 정적 팩터리 메서드와 비스하다. 아파치 버전은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공한다. 즉, 모든 메서드에서  주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스이다. 

아파치의 SynchronizedCollection 클래스는 지금도 활발히 관리되고 있지만, 이 클래스를 자바 8과 함께 사용한다면, removeIf의 디폴트 구현을 물려받아 알아서 동기화 해주는 기능을 사용하기 못하게 된다. removeIf의 구현은 동기화에 관해 아무것도 모르므로 락 객체를 사용할 수 없다. 따라서 SynchronizedCollection 인스턴스를 여러 스레드가 공유하는 환경에서는 한 스레드가 removeIf를 호출하면 ConcurrentModificationException이 발생하거나 예상치 못한 결과가 나타날 수 있다. 

자바 라이브러리에서는 이런 문제를 예방하기 위해 조치를 취했는데, 예를 들어 구현한 인터페이스의 디폴트 메서드를 재정의하고 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다. 
예컨데 Collections.synchronizedCollection이 반환하는 package-private 클래스들은 removeIf를 재정의하고 이를 호출하는 다른 메서드들은 디폴 구현을 호출하기전에 동기화를 하도록 했다. 하지만 자바 플랫폼에 속하지 않은 제3의 기존 컬렉션 구현체들은 언어차원의 인터페이스 변화에 발맞춰 수정될 수 없었고 그 중 일부는 여전히 수정되지 않고 있다. 

**디폴트 메서드는 컴파일 성공하더라도 기존 구현체에 런타임 오류를 야기할 수 있다.** 자바 8은 컬렉션 인터페이스에 꽤 많은 디폴트 메서드를 추가했고, 그 결과 기존에 많은 코드가 영향을 받은 것으로 알려졌다. **기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 것은 꼭 필요한 경우가 아니면 피해야 한다.** 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지 않을지 심숙 수고도 해야 한다. 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용하게끔 해준다. 

한편, 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님을 명심해야 한다. 이런 형태로 인터페이스를 변경하면 반드시 기존 클라이언트를 망가뜨리게 된다. 

핵심은 명확하고 명백하다. **디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.** 디폴트 메서드로 기존 인터페이스에 새 메서드를 추가하면 커다란 위험이 딸려온다. 인터페이스에 내제된 작은 결함도 사용자 입장에서는 짜증나는데, 심각히 잘못된 인터페이스라면 이를 포함한 API에 어떤 재앙이 다가올지 알수 없다. 

새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야 한다. 수 많은 개발자가 그 인터페이스를 나름의 방식으로 구현할 것이니, 우리도 서로 다른 방식으로 최소 세 가지의 구현체는 구현해봐야 한다. 또한 각 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 만들어 보아야 한다. 새 인터페이스가 의도한 용도로 잘 부합하는지 판단하는 것은 굉장히 어렵다. 그래도 이러한 과정을 걸쳐야 인터페이스를 배포하기 전에 바로 잡을 수 있다. **인터페이스를 릴리스 한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.**

## Item.22 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 자신을 구현한 클래스의 인스턴스를 참조하는 일종의 타입 역할을 한다. 즉, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에게 알려주는 것이다. 인터페이스는 이 용도로만 사용해야 한다.

이 지침에 맞지 않는 예로 소위 **상수 인터페이스**라는 것이 있다. 상수 인터페이스는 메서드 없이, 상수를 뜻하는 static final 필드로만 가득찬 인터페이스를 말한다. 그리고 이 상수들을 사용하려는 클래스에서 정규화된 이름(qualified name)을 쓰는 것을 피하고자 그 인터페이스를 구현하곤 한다. 

```
public interface PhysicalConstants {
	static final double AVOGADROS_NUMBER = 6.022_140;
	static final double ELECTRON_MASS = 9.109_383_56;
}
```

**상수 인터페이스 안티 패턴은 인터페이스를 잘못 사용한 예다.** 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다. 따라서 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위다. 클래스가 어떤 상수 인터페이스를 사용하든 사용자에게는 아무런 의미가 없다. 오히려 사용자에게 혼란을 주기도 하며, 더 심하게는 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속되게 한다. 그래서 다음 배포때 이 상수들을 더 이상 쓰지 않게 되더라도 바이너리 호환성을 위해 여전히 상수 인터페이스를 구현하고 있어야 한다. final이 아닌 클래스가 상수 인터페이스를 구현한다면 모든 하위 클래스의 공간이 그 인터페이스가 정의한 상수들로 오염되어 버린다. 

java.io.ObjectStreamConstants 등 일부 자바 플랫폼 라이브러리에도 상수 인터페이스가 있으나 인터페이스를 잘못 사용한 예이니 절대 따라해서는 안된다. 

상수를 공개할 목적이라면 훨씬 적합한 선택지가 몇 가지 있다. 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다. 모든 숫자 기본 타입의 박싱 클래스에 있는 MIN_VALUE, MAX_VALUE가 대표적인 예다. 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개하면 된다. 그것도 아니라면, 인스턴스화 할 수 없는 유틸리티 클래스에 담아 공개하자. 다음 코드는 상수인터페이스의 유틸리티 클래스 버전이다. 




단점 
 1. 서로 다른 기능을 위한 코드가 모여 있어 가독성 하락
 2. 객체를 만들때마다 필요없응 기능을 위한 필드도 생성되어 메모리 추가 요구
 3. 객체의 자료형만봐서는 무슨 기능을 제공하는지 알수가 없다

결국 태그 기반 클래스 사용은 쓰지 말자

### 21. 전략을 표현하고 싶을때는 함수 객체를 사용해라 

함수 포인터, 대리자, 람다표현식 처럼 특정 함수를 호출 가능한 능력을 가지는 것들이 있다. 보틍은 함수의 인자로 함수를 전달하기 위해서 사용.

자바는 함수 포인터를 지원하지 않지만, 객체 참조를 통해 비슷하게 구현이 가능. 이런 객체를 함수 객체라고 한다. 

### 22. 멤버 클래스는 가능하면 static으로 선언하라.

중첩 클래스(nested class): 클래스 안에 정의된 클래스이다. 
중첩 클래스는 해당 클래스가 속한 클래스 안에서만 사용된다. 그렇지 않으면 중첩 클래스로 만들면 안된다.

 1. 정적 멤버 클래스 
 2. 비정적 멤버 클래스 
 3. 익명 클래스 
 4. 로컬 클래스
정적 멤버 클래스를 제외하면 모두 내부 클래스(inner class) 이다.

정적 멤버 클래스는 가장 간단한 중첩 클래스다. 정적 멤버 클래스는 바깥 클래스의 정적 멤버이며, 다른 정적 멤버와 동일한 접근 권한 규칙을 따른다.

비정적 멤버 클래스는 어댑터를 정의할때 많이 쓰인다. 바깥 클래스 객체를 다른 클래스 객체인것 처처럼 보이게 쓰인다. 

바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할때는 항상 선언문 앞에 static을 붙여서 비-정적 멤버 클래스 대신 정적 멤버 클래스로 만들자. 



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTkzOTU0NjIwNywtMzA4OTI5ODE5LDI0ND
U1MDAyOCwxNzEyNTM3MjYyLC0xNDk4NjI3MTEwLDE5ODA2MjIz
NjQsLTEzNTYxMzYyODAsMTcyMzk2MDQ0MSwyMDM3MzU5NDk1LD
E3MjEyMDE4NzQsMTM4MTExMjQ3OCwtMTcxNjc4OTA5OSw3Mjg2
MTIwNzIsMTg0OTA2NTQ3OCwxMzcwNjM1NTAsLTQ0ODUzMjk3MS
wtODMzMTE0ODk1LC02NTQwOTgwNzMsMzcyODU5NzI2LC0zNjU5
ODM3MzVdfQ==
-->