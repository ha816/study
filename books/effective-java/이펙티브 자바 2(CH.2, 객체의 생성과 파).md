# 2장 객체의 생성과 파괴

## 생성자 대신 정적 팩토리 메서드를 고려하라.

클라이언트가 클래스의 인스턴스를 얻는 전통적 수단은 public 생성자다. 하지만 그 뿐만아니라 클래스는 생성자와 별도로 **정적 팩터리 메서드(static factory method)**를 제공할 수 있다. 

예를 들어 boolean의 박싱 클래스인 Boolean 클래스를 보자. 
```
public static Boolean valueOf(boolean b) {
	return b ? Boolean.true : Boolean.false;
}
```
>주의!!
>여기서 이야기하는 정적 팩터리 메서드는 디자인 패턴에서의 팩터리 메서드(Factory Method)와 다르다. 디자인 패턴 중에서 이와 일치하는 패턴은 없다. 

### 정적 팩터리 메서드의 명명법

### 정적 팩터리 메서드의 장점
먼저 장점 다섯 가지를 알아보자

#### 1. 이름을 가질 수 있다.  
기존에 생성자를 사용하면 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 이해하기 힘들다. 반면에 정적 팩터리 메서드는 메서드 이름만 잘 지으면 반환될 객체의 특성을 쉽게 파악할 수 있다. 

생성자는 하나의 시그니처만으로 만들 수 있기 때문에 이름을 가질 수 있는 정적 펙터리 메서드에서는 이런 제약이 없다. 

#### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

생성자는 호출될 때마다 반드시 새로운 인스턴스를 만든다. 반면에 정적 팩터리 메서드는 필요에 따라 매번 새로운 인스턴스를 반환 할수도 있고 이미 이전 시점에 호출이 되었을때 만들어진 인스턴스를 그대로 반환하도록 할 수 있다. 더 나아가 불변 클래스 인스턴스를 미리 만들어 놓거나 이전 시점에 만들어진 인스턴스를 캐싱하여 재활용하는 식으로 인스턴스를 만드는데 드는 비용을  줄일 수 있다. **플라이 웨이트 패턴(Flyweight pattern)**은 이와 유사한 기법이다. 

#### 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

기존의 생성자에서는 자기자신 클래스의 인스턴스만 반환할 수 있다. 반면에 정적 팩토리 메서드는 반환될 객체의 클래스를 자유롭게 선택할 수 있다. 따라서 반환 타입을 구현(implements)하거나 상속(extends)받는 하위 타입 객체 반환이 가능하다. 그리고 이는 일반적으로 좋은 코딩 습관이다. 

#### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 

상황에 따라 그 상황에 맞는 적절한 인스턴스를 사용할 필요가 있을수가 있다. 입력 매개변수에 포함된 어떤 상황에 따라서, 정적 팩토리 메서드에서는 적절한 객체를 반환한다. 예를 들어 EnumSet 클래스의 정적 팩터리 메소드는 원소가 64개 이하면 원소들을 long 변수 하나로 관리하는 RegularEnumSet을 반환하고 65개 이상이면 long 배열로 관리하는 JumboEnumSet를 반환한다. 

클라이언트의 입장에선 팩터리가 던져주는 객체가 어느 클래스의 인스턴스인지 알  수 없고 알 필요도 없다. 그저 반환된 인스턴스를 사용하는데 문제만 없으면 된다. 

#### 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 

적절한 인스턴스를 클라이언트에게 제공하고 관리하는 것을 담당하는 프레임워크를 서비스 제공자 프레임워크(service provider framework)라고 한다. 이 프레임워크에서 제공자(provider)는 서비스의 구현체이다. 그리고 이 서비스 구현체들을 클라이언트에 제공하는 역활을 프레임워크가 통제하여, 클라이언트를 구현체로부터 분리해준다. 

서비스 제공자 프레임워크(service provider framework)는 3개의 핵심 컴포넌트로 이루어 진다. 구현체의 동작을 정의하는 서비스 인터페이스(service interface), 제공하는 구현체를 등록할때 사용하는 제공자 등록 API(provider registration API), 클라이언트가 서비스의 인스턴스를 얻을때 사용하는 서비스 접근 API(service access API)가 그것이다.

클라이언트는 서비스 접근 API를 사용할때 원하는 구현체의 조건을 명시할 수 있다. 조건을 명시하지 않으면 기본 구현체나 지원하는 구현체를 하나씩 돌아가며 반환한다. 이것이 바로 서비스 제공 프레임워크의 근간인 유연한 정적 팩터리의 실체이다. 사실 의존객체 주입(dependency injection) 프레임워크도 서비스 제공자라고 생각할 수 있다. 

### 정적 팩터리 메서드의 단점

#### 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들수가 없다. 

생성자 없이 정적 팩토리 메서드만 제공하는 클래스가 있다고 하자. 그러면 생성자가 없기 때문에 이 클래스를 상속하는 하위 클래스를 만들수가 없다. 어찌 보면 이 제약을 상속보다 컴포지션을 사용하도록 유도하고 










From, With,
Cleaner;
try with resource

equals, 재정의시는 hashCode

@override를 반드시 써라
오버로드로 햇갈리면 컴파일 에러가 뜬다. 

1.  builder 패턴 

서비스 로직을 catch에서 처리하지마라 




<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMzk3MzQyMSwtMTk3MjAwMzYwNCwyNz
I1NTAzMDAsLTIxMTUzODA2NTIsLTE1ODgzNDMyOTYsLTM4MTI4
NjgyNywtOTk5MjU4MzIyLDE0NTY4MDQ0MDcsLTE1NTM1NDk0Mz
YsLTEzODE2MzA5NTQsLTE4ODAwMDQyMDYsMTU1MDUxMzI5Niwt
MTEzNzcxOTAxNV19
-->