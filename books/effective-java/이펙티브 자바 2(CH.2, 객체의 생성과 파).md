# 2장 객체의 생성과 파괴

## Item1. 생성자 대신 정적 팩토리 메서드를 고려하라.

클라이언트가 클래스의 인스턴스를 얻는 전통적 수단은 public 생성자다. 하지만 그 뿐만아니라 클래스는 생성자와 별도로 **정적 팩터리 메서드(static factory method)**를 제공할 수 있다. 

예를 들어 boolean의 박싱 클래스인 Boolean 클래스를 보자. 
```
public static Boolean valueOf(boolean b) {
	return b ? Boolean.true : Boolean.false;
}
```
>주의!!
>여기서 이야기하는 정적 팩터리 메서드는 디자인 패턴에서의 팩터리 메서드(Factory Method)와 다르다. 디자인 패턴 중에서 이와 일치하는 패턴은 없다. 

### 정적 팩터리 메서드의 명명법

from
: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드 이름
```Date d = Date.from(instant);```

of
: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
```Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);```

valueOf
: from과 of의 더 자세한 버전
```BigInteger prime = BigInter.valueOf(Integer.MAX_VALUE)```

instance, getInstance
: (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다. 

create, new Instance
: instance, getInstance와 같지만, 언제나 새로운 인스턴스를 생성해서 반환한다.

get[Type]
: 정적 팩터리 메서드를 가지는 클래스가 아닌 다른 클래스 인스턴스를 반환할때 쓴다. `Type`은 팩터리 메서드가 반환할 다른 클래스 객체의 타입이다. 
```FileStore fs = Files.getFileStore(path); ```

new[Type]
: get[Type]과 같이 정적 팩터리 메서드를 가지는 클래스가 아닌 다른 클래스 인스턴스를 반환할때 쓴다. 다만 이렇게 생성된 객체는 언제나 새로운 인스턴스를 반환한다.
```BufferedReader br = Files.newBufferedReader(path)```

type
: get[Type]과 new[Type]의 간결한 버전. 따라서 언제나 새로운 인스턴스인지 같은 인스턴스인지 알수가 없다.
```List<Complaint> litany = Collections.list(legacyLitany);```

### 정적 팩터리 메서드의 장점

#### 1. 이름을 가질 수 있다.  
기존에 생성자를 사용하면 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 이해하기 힘들다. 반면에 정적 팩터리 메서드는 메서드 이름만 잘 지으면 반환될 객체의 특성을 쉽게 파악할 수 있다. 

생성자는 하나의 시그니처만으로 만들 수 있기 때문에 이름을 가질 수 있는 정적 펙터리 메서드에서는 이런 제약이 없다. 

#### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

생성자는 호출될 때마다 반드시 새로운 인스턴스를 만든다. 반면에 정적 팩터리 메서드는 필요에 따라 매번 새로운 인스턴스를 반환 할수도 있고 이미 이전 시점에 호출이 되었을때 만들어진 인스턴스를 그대로 반환하도록 할 수 있다. 더 나아가 불변 클래스 인스턴스를 미리 만들어 놓거나 이전 시점에 만들어진 인스턴스를 캐싱하여 재활용하는 식으로 인스턴스를 만드는데 드는 비용을  줄일 수 있다. **플라이 웨이트 패턴(Flyweight pattern)**은 이와 유사한 기법이다. 

#### 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

기존의 생성자에서는 자기자신 클래스의 인스턴스만 반환할 수 있다. 반면에 정적 팩토리 메서드는 반환될 객체의 클래스를 자유롭게 선택할 수 있다. 따라서 반환 타입을 구현(implements)하거나 상속(extends)받는 하위 타입 객체 반환이 가능하다. 그리고 이는 일반적으로 좋은 코딩 습관이다. 

#### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 

상황에 따라 그 상황에 맞는 적절한 인스턴스를 사용할 필요가 있을수가 있다. 입력 매개변수에 포함된 어떤 상황에 따라서, 정적 팩토리 메서드에서는 적절한 객체를 반환한다. 예를 들어 EnumSet 클래스의 정적 팩터리 메소드는 원소가 64개 이하면 원소들을 long 변수 하나로 관리하는 RegularEnumSet을 반환하고 65개 이상이면 long 배열로 관리하는 JumboEnumSet를 반환한다. 

클라이언트의 입장에선 팩터리가 던져주는 객체가 어느 클래스의 인스턴스인지 알  수 없고 알 필요도 없다. 그저 반환된 인스턴스를 사용하는데 문제만 없으면 된다. 

#### 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 

적절한 인스턴스를 클라이언트에게 제공하고 관리하는 것을 담당하는 프레임워크를 서비스 제공자 프레임워크(service provider framework)라고 한다. 이 프레임워크에서 제공자(provider)는 서비스의 구현체이다. 그리고 이 서비스 구현체들을 클라이언트에 제공하는 역활을 프레임워크가 통제하여, 클라이언트를 구현체로부터 분리해준다. 

서비스 제공자 프레임워크(service provider framework)는 3개의 핵심 컴포넌트로 이루어 진다. 구현체의 동작을 정의하는 서비스 인터페이스(service interface), 제공하는 구현체를 등록할때 사용하는 제공자 등록 API(provider registration API), 클라이언트가 서비스의 인스턴스를 얻을때 사용하는 서비스 접근 API(service access API)가 그것이다.

클라이언트는 서비스 접근 API를 사용할때 원하는 구현체의 조건을 명시할 수 있다. 조건을 명시하지 않으면 기본 구현체나 지원하는 구현체를 하나씩 돌아가며 반환한다. 이것이 바로 서비스 제공 프레임워크의 근간인 유연한 정적 팩터리의 실체이다. 사실 의존객체 주입(dependency injection) 프레임워크도 서비스 제공자라고 생각할 수 있다. 

### 정적 팩터리 메서드의 단점

#### 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들수가 없다. 

생성자 없이 정적 팩토리 메서드만 제공하는 클래스가 있다고 하자. 그러면 생성자가 없기 때문에 이 클래스를 상속하는 하위 클래스를 만들수가 없다. 어찌 보면 이 제약은 상속보다 컴포지션을 사용하는 것이 좋다는 관점과 불변 타입 클래스는 상속이 불가하다는 관점에서는 장점으로 느껴질수도 있다. 

#### 2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다. 

생성자 처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화하는 방법을 찾아봐야 한다.  따라서 정적 팩터리 메서드에  JavaDoc 주석으로 문서화를 해놓고 메서드 이름도 잘 알려진 규약을 따라 짓는 식으로 문제를 완화해줘야 한다. 

> 핵심정리
> 정적 펙터리 메서드와 public 생성자는 각자의 쓰임새가 있으므로 장단점을 이해하고 적절히 사용하는 것이 좋다. 일반적으로는 정적 펙터리 메서드를 사용하는게 유리한 경우가 많기 때문에 생각 없이 public 생성자를 이용하는 습관이 있었다면 고치도록 하자.

## Item2. 생성자에 매개변수가 많다면 빌더를 고려하라. 

정적 팩터리 메서드와 생성자 모두 똑같은 이슈가 하나 있다. 매개변수가 많을때 이를 적절히 처리하기 어렵다는 점이다. 개발자들은 이런 상황에서 **점층적 생성자 패턴(telescoping constructor pattern)**을 즐겨 사용했다.  오버로딩을 이용한 다양한 형태의 생성자를 제공하고 사용자는 그 중 원하는 매개변수를 모두 포함하는 생성자를 선택해서 사용했다. 그런데 이 방법도매개변수의 수가 어느정도 이상이 되면 금세 걷잡을 수 없다. 즉 점층적 생성자 패턴은 근본적으로 좋은 해결방법이 아니다. 매개변수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다. 각 매개변수의 의미가 무엇인지 헷갈릴 것이고, 매개변수가 몇개인지도 주의해서 세어보아야 할것이다. 

다음으로 매개변수가 많을때 활용할 수 있는 두 번째 대안인 **자바빈즈 패턴(JavaBeans pattern)**을 보자.  매개변수가 없는 생성자로 객체를 만든 후 세터setter 메서드로 필요한 매개변수를 설정하는 방법이다. 자바빈즈 패턴을 쓰면 객체를 만들기가 쉽고, 필요한 변수만 설정하여 더 읽기 쉬운 코드가 된다. 하지만 불행히도 자바빈즈 패턴은 치명적인 단점이 있다. **자바빈즈 패턴에서는 객체를 하나 만들려면 여러 메서드를 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태에 놓인다.** 일관성이 깨진 객체가 사용되면 논리적 오류가 발생할 수 있어 큰 문제에 처할 수도 있다. 일관성이 깨지는 상황에 놓인다면 클래스를 불변으로 만들 수 없고 쓰레드 안전성을 얻으려면 프로그래머가 추가 작업을 해야만 한다.

마지막 대안인 점층적 생성자 패턴의 안정성과 자바빈즈패턴의 가독성을 겸비한 빌더 패턴(Builder pattern)을 알아보자. 클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자나 정적 펙터리 호출해 빌더 객체를 얻는다. 그 다음 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 매개변수를 설정한다. 마지막으로 build 메서드를 호출해 드디어 우리에게 필요한 일관성 있는 객체를 얻는다. 빌더는 보통 생성할 클래스 안에 정적 멤버 클래스로 만든다. 

빌더의 세터 메서드들은 빌더 자신을 반환하기 때문에 연쇄적으로 호출할 수 있다. 이런 방식을 메서드 호출이 계속 연결된다는 뜻으로 플루언트 API(fluent API) 혹은 메서드 연쇄(method chaining)이라고 한다. 잘못된 매개변수를 최대한 일찍 발견하려면 빌더의 생성자와 메서드에서 입력 매개변수를 검사하고, build 메서드에서 여러 매개변수에 걸친 불변식을 검사하자. 공격에 대비해 불변식을 보장하려면 빌더로부터 매개변수를 복사한 후 해당 객체 필드들도 검사해야 한다. 검사해서 잘못된 점을 발견하려면 어떤 매개변수가 잘못되었는지를 메세지에 담아 예외를 던지면 된다. 

추가적으로 빌더 패턴은  계층적으로 설계된 클래스와 함께 쓰기 좋다. 여러 계층의 클래스에서 관련 빌더를 멤버로 정의하자. 즉 추상클래스는 추상빌더를, 구현 클래스(concrete class)는 구현 빌더를 갖도록 한다.

```
public abstract class Pizza {
	abstract static class Builder<T extends Builder<T>> {
		abstract Pizza build();
		protected abstract T self(); // 하위 클래스는 이 메서드를 재정의 하여 this를 반환해야 한다.
	}
}
```
위에서 정의한 Pizza.Builder 클래스는 재귀적 타입 한정을 이용하는 제네릭 타입이다.  여기서 말한 재귀적 타입 한정은 ```<T extends Builder<T>>``` 으로 T의 타입으로는 Builder<T>를 상속하는 하위 타입만 가능하다는 의미이다. 
추상 메서드인 self는 하위 클래스에서 형변환 하지 않고도 메서드 연쇄를 가능하게 한다. 이러한 방법을 시뮬레이티드한 셀프 타입(simulated self-type) 관용구라 한다. 이제 구현 클래스(concrete class)를 보자. 

```
public class NyPizza extends Pizza {
	private NyPizza(Builder builder) {
		super(builder);
	}
	public static class Builder extends Pizza.Builder<Builder>{
		@Override public NyPizza build(){
			return new NyPizza();
		}
		@Override protected Builder self(){ // T == Builder
			return this;
		}
	}
}
```
구현 클래스의 빌더가 재정의한 build메서드는 해당 구현 하위 클래스를 반환하도록 정의한다.  즉 NyPizza.Builder는 NyPizza를 반환한다. 이렇게 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입(Pizza)이 아닌, 그 하위 타입을 반환하는 기능을 공변 반환 타이핑(covariant return typing)이라 한다. 따라서 클라이언트가 형변환에 신경쓰지 않고 빌더를 편하게 사용이 가능하다. 

빌더 패턴은 다양한 응용이 가능하기 때문에 상당히 유연하다. 하지만 빌더 패턴이 장점만 있는 것은 아니다. 우선, 객체를 만들려면 빌더 부터 만들어야 한다. 빌더 자체의 생성 비용이 크지는 않지만 성능에 민감한 상황이라면 문제가 될수 있다. 다음으로 매개변수가 최소 4개 이상은 되어야 값어치를 한다. 하지만 API는 시간이 지날수록 매개변수가 많아지는 경향이 있기 때문에 생성자나 팩터리 방식으로 시작했다가 나중에 빌더 패턴으로 전환하는것 보다는 애초에 빌더 패턴으로 시작하는 편이 나을때가 많다. 

> 핵심정리
> 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 것이 낫다. 매개변수 중 다수가 필수가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰시가 간결하고, 자바빈즈 보다 훨씬 안전하다. 

## Item3. private 생성자나 열거 타입으로 싱글턴임을 보증하라. 

싱글턴(singleton)이란 인스턴스를 오직 하나만 생성이 가능한 클래스를 말한다. 싱글턴 패턴의 전형적인 예로는 함수와 같은 무상태 객체(stateless)나 설계 목적상 유일해야하는 시스템 컴포넌트가 있다. 

클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트에서 테스트하기가 어려워질 수 있다. 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가자(mock) 구현으로 대체할 수 없기 때문이다. 

싱글턴을 만드는 방식은 보통 둘 중 하나다. 두 가지 방법 모두 생성자는 private으로 감춰두고, 유일한 하나의 인스턴스에 접근하는 수단으로 public static 멤버를 하나 마련해둔다.

아래 코드는 싱글턴을 만드는 일반적인 방법의 예이다. 
```
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
}
```
private 생성자는 INSTANCE를 초기화 하는데 딱 한번 호출된다. public이나 protected 생성자가 없으므로 Elvis 클래스가 초기화 될때 new Elvis()로 만들어진 인스턴스가 전체 시스템에서 유일한것이 보장된다. 

하지만 사실 리플렉션 API인 AccessibleObject.setAccessible을 사용해서 private 생성자를 호출할 수 있다. 이러한 것을 방어하려면 생성자를 수정하여 두 번째 객체가 생성되려할때 예외를 던지게 하면 된다. 

다음으로 아래 코드는 정적 팩터리 메서드를 public static 멤버로 제공한다. 
```
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
	public static Elvis getInstance() { return INSTANCE; }
}
```
getInstance 메서드를 통해서 항상 같은 객체 참조를 반환하므로 제 2의 Elvis 객체는 만들어지지 않는다. 하지만 리플렉션을 이용하면 생성자를 호출할 수 있기 때문에 완벽하지 않다. 

이제 일반적인 방법과 정적 팩터리 메서드 방법간의 장점을 보자.

일반적인 방법의 장점
* 해당 클래스가 싱글턴임이 API에 명백히 들어난다. public static 필드가 final이니 절대로 다른 객체를 참조할 수 없다. 
* 간결하다. 

정적 팩터리 메서드의 장점
* 나중에 변경이 발생했을때, API를 바꾸지 않고도 싱글턴이 아니게 변경이 가능하다는 점이다. 유일한 인스턴스를 반환하던 팩터리 메서드가 상황에 따라(매개변수에 따라) 다른 인스턴스를 넘겨주도록 수정이 가능하다. 
* 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.(item 30)
* 정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할 수 있다. 

정적 팩터리 메서드의 장점을 사용할 일이 없다면 일반적인 방법(public 필드로 제공)을 이용하는 것이 좋다.

위 두가지 방식으로 만든 싱글턴 클래스를 직렬화(serializable)하려면 단순히 Serializable을 구현 선언하는 것만으로는 부족하다. 구현하려면 모든 인스턴스 필드를 일시적(transient)이라 선언하고 readResolve 메서드를 제공해야 한다. 이렇게 하지 않으면 직렬화된 인스턴드를 역직렬화 할때마다 새로운 인스턴스가 생성된다. 

transient
: a variables modifier used in Serialization. At the time of serialization, if we don’t want to save value of a particular variable in a file, then we use **transient** keyword. When JVM comes across **transient** keyword, it ignores original value of the variable and save default value of that variable data type. 

싱글턴을 지키고 싶다면 아래와 같은 readResolve 메서드를 추가하자.
```
private Object readResolve() {
	return INSTANCE; //진짜 하나를 반환하고, 가짜는 가바지 컬렉터가 처리하도록 둔다. 
}
```

마지막으로 싱글턴을 만드는 방법은 원소가 하나인 열거 타입을 선언하는 것이다. 
```
public enum Elvis {
	INSTANCE;
}
```
열거 타입을 사용하면 public 필드 방식과 비슷하지만, 더 간결하고, 추가 노력없이 직렬화 할 수 있고, 심지어 아주 복잡한 직렬화 상황이나 리플렉션을 사용해도 제 2의 인스턴스가 생기는 일을 완벽히 만아준다. 

다소 부자연스러워 보일수는 있으나 **대부분 상황에서 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.**  단, 만들려는 싱글턴이 Enum이외에 클래스를 상속해야 한다면 이 방법은 사용불가하다. (열거 타입이 다른 인터페이스를 구현하도록 선언은 가능하다.)

## Item4. 인스턴스화를 막으려거든 private  생성자를 사용하라. 

가끔씩 단순 정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을때가 있다. 분명 객체 지향적이지 않고, 남용할 수도 있는 방식이라 그리 좋아보이지는 않지만 분명 나름대로 쓰임새가 있다.

예를 들면, java.lang.Math와 java.util.Arrays처럼 기본 타입 값이나 배열 관련 메서드들을 모아놓을 수 있다. 또한, java.util.Collections처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아놓을수도 있다. 마지막으로, final 클래스와 관련한 메서드들을 모아놓을 때도 사용한다. 참고로 final 클래스는 확장(상속) 불가능한 클래스를 의미한다.

사실 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 클래스가 아니다. 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어 준다. 즉, 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 생성자가 자동 생성된 것인지 구분할 수 없다. 실제로 공개된 API들에서도 이처럼 의도치 않게 인스턴스화를 할 수 있게 된 클래스가 종종 목격된다. 

그럼 인스턴스화를 어떻게 막아야 할까? 참고로 **추상 클래스로 만드는 것만으로는 인스턴스화를 막을 수 없다.** 왜냐하면 하위 클래스를 만들어면 인스턴스화가 가능하기 때문이다. 더욱이 사용자는 추상 클래스를 보고 상속 받아 쓰라는 뜻으로 오해할 수도 있으니 더 큰 문제를 야기할 수 있다. 
다행히도 인스턴스화를 막는 방법은 아주 간단하다. 컴파일러가 기본생성자를 만드는 경우는 오직 명시된 생성자가 하나도 없을때 뿐이니 **private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.** 

```
public class UtilityClass {
	private UtilityClass() {
		throw new AssertionError();
	}
}
```

명시적 생성자가 private이니 클래스 바깥에서는 접근할 수 없다. private 생성자내에서 꼭 Error를 던질 필요는 없지만, 생성자를 호출하지 않도록 경고를 한다. 그런데 생성자가 분명 존재하는데 호출할 수는 없다니, 그다지 직관적이지 않다. 그러니 적절한 주석을 달아두도록 하자. 

이렇게 private 생성자를 사용하면 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 되는데, 이를 private으로 선언했으니 하위 클래스가 상위 클래스 생성자에 접근하는것이 불가능하다. 

## Item5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

많은 클래스가 하나 이상의 자원에 의존한다. 가령 맞춤법 검사기(SpellChecker)는 사전(dictionary)에 의존하는데, 이런 클래스를 정적 유틸리티 클래스로 구현한 모습을 드물지 않게 볼 수 있다.
```
public class SpellChecker {
	private static final Lexicon ditionary = ...;
}
```
SpellChecker는 private static final의 단 하나만의 사전을 사용한다. 하지만 실전에서는 사전이 언어별로 다를 수도 있고, 특수 어휘용 사전이 있을 수도 있다. 단 하나만의 사전으로 모든 맞춤법을 검사한다는 것은 너무 순진한 생각이다. 자 이제 SpellChecker가 여러 사전을 사용할 수 있도록 하자. 간단히 dictionary필드에서 final을 제거하고 다른 사전으로 교체하는 메서드를 추가할 수 있지만, 아쉽게도 이 방식은 어색하고 오류가 나기 쉬우며 멀티쓰레드 환경에서는 사용이 불가하다. 

**사용하는 자원(사전)에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.** 대신 클래스(SpellChecker)가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원(dictionary)를 사용해야한다. 이 조건을 만족하는 간단한 패턴이 있으니, 바로 인스턴스를 생성할때 생성자에 필요한 자원을 넘겨주는 방식이다. 이는 의존 객체 주입의 한 형태로, 검사기(SpellChecker) 생성할 때, 의존 객체인 사전을 주입해주면 된다. 
```
public class SpellChecker {
	private final Lexicon dictionary;
	public SpellChecker(Lexicon dictionary) {
		this.dictionary = Objects.requireNonNull(dictionary);
	}
}
```
의존 객체 주입 패턴(Dependency Injection, DI)은 아주 단순하여 많은 프로그래머가 이 방식에 이름이 있다는 사실도 모른 채 사용해 왔다. 예제에서는 dictionary라는 딱 하나의 자원만 사용하지만, 자원이 몇개 든 의존 관계가 어떻든 상관 없이 잘 동작한다. 또 불변성을 보장하여 같은 자원을 사용하려는 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있기도 한다. 의존 객체 주입은 생성자, 정적 팩터리, 빌더 모두에 똑같이 응용 가능하다. 

이런 패턴의 쓸만한 변형으로 생성자에 자원 팩터리를 넘겨주는 방식이 있다. **팩터리란 호출할 때마다 특정 타입의 인스턴스를 반혹해서 만들어주는 객체를 말한다.** 이것이 바로 팩터리 메서드 패턴(Factory Method Pattern)을 구현한 것이다. 

자바 8에서 소개한 Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예이다. Supplier<T>를 입력으로 받는 메서드는 일반적으로 한정적 와일드카드 타입(bounded wildcard type)을 사용해 팩터리의 타입 매개변수를 제한해야 한다. 이런한 방법을 통해 클라이언는 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성 할 수 있는 팩터리를 넘길수 있다. 다음 코드는 클라이언트가 제공한 팩터리가 생성한 타일(Tile)들로 구성된 모자이크(Mosaic)를 만드는 메서드다.

```
Mosaic create(Supplier<? extends Tile> tileFactory){ ... }
```
의존 객체 주입이 항상 옳은 것은 아니다. 의존성이 수천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 한다. Spring, Dagger, Guice와 같은 의존 객체 주입 프레임워크를 사용하면 이런 문제를 해소할 수 있다. 이 책에서 다룰 주제는 아니지만, 이들 프레임워크는 의존 객체를 직접 주입하도록 설계된 API를 알맞게 응용해서 사용하고 있다. 

>핵심정리
>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 클래스가 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는게 좋다. 









 














 













<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwNTM1NTUxNzQsOTA5MjEzNTg0LC0yMD
g4NDI4ODE1LC0xOTQxMjg2ODQ0LDE3MTkxODg1MDQsLTI1ODI4
MjU2Myw3MTAyOTYwMTYsLTk1NjA0NTcxOSwtMTQ5NDY3NTAyNS
wtMTg3Mjk2OTM3NiwtMTc1OTU2MDMxMiw2OTQ5MTQ2MTMsLTY3
NDM2NzMxNywzMzU0OTc0OTMsLTg3OTY4MDA5NSwxMDcwMzc5ND
gxLDgzOTk5MjkyOCwtMTY3NjYyMzY1MCwtMTAzNzE4ODU5Miwy
MTI4OTU0MjcyXX0=
-->