# 8장 방어적 프로그래밍

방어적 프로그래밍은 코드 작성에 대해 방어적인 태도를 보이라는 의미가 아니다. 그 보다는 안정적으로 운전하는 습관에 가깝다. 

방어적 프로그래밍에서 가장 중요한 개념은 설령 다른 루틴의 잘못으로 인한 거싱라도 루틴에 잘못된 데이터가 들어왓을때 루틴에 아무런 문제가 발생하지 않도록 하는데 잇다. 

타당하지 않은 데이터와 절대로 발생할 수 없는 이벤트, 다른 개발자의 실수로부터 자신을 보호하기 위한 방법을 설명한다. 


## 8.1 잘못된 입력으로부터 프로그램 보호

쓰레기를 넣으면 쓰레가 나온다.(Garbage in, garbage out)

### 외부로부터 들어오는 모든 데이터의 값이 검사

파일이나 사용자, 네트워크, 그 밖의 다른 인터페이스로부터 데이터 받을때 허용가능한 범위에 있는지 검사를 해라. 


숫자값은 허용 범위 내
문자열은 길이 또는 제한된 값


### 루틴의 모든 입력 매개변수를 검사
사실 8.5절 오류로 인한 손상을 막기위한 방책에서 입력검사는 해야하는 루틴이 어느것인지 결정하기 위한 실용적인 방법을 제공

### 잘못된 이별긍 ㄹ어떻게 처리할 것인지를 결정하라

유효하지 않은매개변수를 어떻게 처리해야 할가? 8.3절에서 자세히 소개 한다. 

## 8.2 어설션

어설션은 대개 루틴이나 매크로 실행시 프로그램이 스스로 검사할수 있도록 사용하는 코드다.
어설션이 참이면 모든것이 잘 동작하고 있다는 것을 의미한다.  어셜션이 거짓일때는 코드에서 예상치 못한 오류가 발생했다는 의미다.

어설션은 일반적으로 두개 인자를 갖는다. 

```
assert denominator != 0 : "unexpected error";
```
첫번째 인자는   denominator != 0이고 두번째 인자는 첫번째 인자가 거짓일때 출력하는 메세지이다. 

일반적으로 배포되는 코드에서는 어설션 메세지를 사용자에게 보여주지 않는다. 어설션은 주로 개발과 유지보수에 사용되며, 개발버전에서는 코드에 포함되지만 제품에서는 제외된다. 

### 어설션 사용지침

발생이 예상되는 상황에서는 오류 처리 코드를 사용하되, 절대로 발생해서는 안되는 조건에 대해서는 어설션을 사용하라. 

다시 강조하지만 어설션은 절대로 발생해서는 안되는 조건을 검사한다. 
오류 처리 코드로 비정상적인 조건을 처리하면 프로그램이 매끄럽게 상황을 처리할 것이다. 어설션을 통해 비정상적인 조건을 처리하면 프로그램이 강제로 충돌하게 되어 문제를 해결하기 위해 버그를 해결하고 새로운 버전을 배포해야 한다. 

### 선행 조건과 후행조건을 문서화하고 검증하는데 어설션을 사용하라. 

선행조건은 루틴이나 클래스에서 다른 루틴을 호출하거나 객체를 생성하기 전에 반드시 참이어야 하는 특성이다. 선행 조건은 루틴을 호출하는 쪽에서 반드시 지켜야 한다

후행조건은 루틴이나 클래스 호출후 반드시 참이어야 하는 조건이다. 후행 조건은 호출된 코드나 클래스가 지켜야 하는 약속이다. 

## 8.3 오류 처리 기법

어설션은 절대 발생해서는 안될 오류를 처리하는데 사용한다. 그렇다면 발생할 것이 예상되는 오류는 어떻게 처리할까?

### 중립적인 값을 반환한다. 
### 다음에 오는 유효한 데이터로 대체한다. 

## 8.4 예외

예외는 코드가 오류나 예외적인 이벤트를 루틴을 호출한 코드에 전달할 수 있는 특수한 방법이다. 오류가 발생한 상황을 전혀 인식하지 못하는 코드는 오류를 해석하고 오류에 뭔가 도움이 되는 것을 처리할 능력이 있는 시스템의 다른 영역에 제어를 넘긴다. 

흔히 try -catch 구문을 많이 쓰는데 아래 try-cat의 차이점을 요약했다. 

|특성| C++| 자바| 비주얼베이직|
|--|--|--|--|
|finally지원|아니오|예|예|
|던질수있는것|Exception 객체나 파생 객체, 객체 포인터, 객체 참조|Excetpion 객체나 파생객체|Excetpion 객체나 파생객체|
|잡히지 않은 예외의 효과|std::undexpected를 호출하고 ...|예외가 검사 예외라면 실행 스레드를 중단하고 런타임예외라면 아무작업도 하지 않는다.|프로그램을 중단한다.|

### 예외를 사용해 무시되어서는 안되응 오류는 프로그램의 다른부분에 알린다. 

### 정말로 예외적진 조건인 경우에만 예외를 던져라.

기본적으로 예외는 호출 코드 내부에서 어떤 예외를 던질지 알아야 함으로 복잡성을 증가시킨다. 

### 책임을 전가하기 위해서 예외를 사용하지 않는다. 

오류를 발생한 코드에서 처리할 수 있다면 직접 처리하는 게 좋다. 오류를 처리할 수 있는데도 처리되지 않는 예외를 던지지 않도록 한다. 

### 생성자와 소멸자에서 예외를 잡을 수 없다면 생성자와 소멸자에서 예외를 던지지 않는다. 

예외를 처리하는 방법을 정할 때 예외를 생성자와 소멸자에서 발생시킬 수 있다고 가정하면 코드가 매우 복잡해진다. 예를 들면 C++에서 소멸자는 객체가 완전히 생성 되기 전에는 호출되지 않는다. 이 말은 생성자에서 예외를 던진다면 소멸자가 호출되지 않기 때문에 리소스 누수가 있다는 것을 의미한다. 

### 올바른 추상화 수준에서 오류를 던진다. 

좋은 예제
``` class Employee {
	public taxId getTexId() throws EOFException 
}
```
호출한 쪽에서 저수준의 EOFException 예외를 전달한다. 저수준 예외를 호출한 쪽에 전달함으로써 루틴이 어떻게 구현되었는지 사항을 노출한다. 이렇게 하면 클라이언트 코드는 Employee 클래수 수준에서 이해하는게 아니라 EOFException 예외를 던지는 Employee 클래스의 세부적인 루틴을 이해하도록 한다. 

나쁜 예제
``` class Employee {
	public taxId getTexId() throws EmployeeDataNotAvailable
}
```
위의 클래스는 자신이 속한 클래스와 일관성을 유지하는 예외를 던진다. 

### 예외를 발생시킨 모든 정보를 예외 메세지에 포함한다.

모든 예외는 코드가 예외를 던질때 감지된 특정한 환경에서 발견한다. 이러한 정보는 예외가 발생한 이류를 이해하는데 매우 중요하다.

### 비어 있는 catch 블록을 피한다. 

## 8.5 오류로 인한 손해를 막기 위한 방책
















 



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg4NDkzMDY5MCwxOTI1NDk3OTY4LC0xOT
Y4NjEwMTQyLDU0MzE3Mjg0NSwxNjg0NTEyNzk1LDMwOTg4NzM5
NCwtMTk4MzI2NTE5OCwtMTY4ODkwNTQyNywxNzkwNzE3NjAyLC
0xNDk4MjE3MTQwLDEyMjA5NDEwMywtMjAyNjUwMDY4MCwtMjEz
ODA1NzIyOV19
-->