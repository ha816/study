# 25장 코드 튜닝 전략

성능은 전략과 전술이라는 두 가지 측면을 가지고 설명한다. 이 장에서는 성능 전략을 설명한다. 만약 성능 전략에 대해 잘 파악하고 있고 성능 전술을 위한 구체적인 기법을 찾고 있다면 26장으로 넘어가자.

## 25.1 성능이란?

성능은 프로그램 전체의 성능을 뜻한다. 즉 성능이 코드속도를 포함하는 더 큰 개념이다. 코드 속도는 말그대로 기능의 수행속도를 말한다. 

성능과 코드 속도는 어느정도 관련이 있다. 그렇지만 속도를 더 빠르게 만들려고 다른 특성을 희생하는 것은 조심해야 한다. 속도에 대한 작업이 전체적인 성능에는 해를 입힐 수 있다. 

사용자는 코드의 품질보다 구체적인 프로그램의 특성에 더 많은 관심을 둔다. 따라서 소프트웨어를 제시간에 전달하고 깔끔한 사용자 인터페이스를 제공하고 오류 및 고장을 피하는 것이 더 중요하다. 

### 성능과 코드 튜닝

코듀 튜닝은 프로그램 성능 향상에 한 방법이다. 그렇지만 코듀 튜닝보다 시간이 덜 걸리고 코드에 손상도 덜 주는 성능 향상 방법도 쉽게 찾을수 있다. 

아래 관점에서 바라본 효율화가 무엇인지 생각해보자. 

#### 프로그램 요구사항
성능에 대한 요구사항은 굉장히 빈번히 변화한다. 성능 요구사항을 해결하기 전에 마땅히 해결해야하는 문제인지 먼저 확인한다. 책의 일화로는 요구 사항을 쉽게 변경(응답시간 1초 이하 > 응답시간 4초 이하)하여 비용을 줄였다. 

#### 프로그램 설계
프로그램의 크기와 속도가 중요하다면 목표를 합리적으로 달성하도록 아키텍처를 설계한다. 성능 중심의 아키텍처 설계후 개별적인 서브시스템과 기능, 클래스에 대한 리소스 목표를 설정한다. 
책의 일화로는 소프트웨어 레벨의 코드 튜닝으로는 도저히 해결하기 힘든 문제를 하드웨어 설계수준에서 해결하는 예를 들었다. 

#### 클래스와 루틴 설계
클래스와 루틴 설계 수준에서 할 수 있는 부분은 데이텨 형과 알고리즘을 선택하는 것으로, 대게 프로그램의 메모리 사용과 실행 속도에 영향이 있다. 

#### 운영체제 상호작용
프로그램 외부 파일이나 동적 메모리, 출력 장치를 다룬다면 운영체제와 상호작용할 것이다. 성능이 좋지 않다면 운영체제 루틴이 느리거나 비대하기 때문일 것이다. 때때로 컴파일러는 꿈도 꾸지 않았던 시스템 호출이나 시스템 호출을 일으키는 라이브러리를 생성한다.

#### 코드 컴파일
좋은 컴파일러는 ㅋ고급 프로그래밍 언어 코드를 최적화된 기계어 코드로 변환한다. 올바른 컴파일러를 선택하면 속도 최적화에 대해선 더 생각하지 않아도 된다. 

#### 하드웨어
때로는 프로그램의 성능 향상을 위해서 가장 저렴한 방법이 새로운 하드웨어를 구입하는 것일 수도 있다. 수십만명의 고객이 사용하는 프로그램의 경우 새로운 하드웨어를 구매하는것은 비현실적이다. 소수의 고객을 위한 주문형 소프트웨어를 개발한다면 하드웨어 업그레이드가 가장 저렴한 대안일 것이다.

#### 코드 튜닝
코드 튜닝은 코드가 더 효율적으로 작동하도록 정확하게 수정하는 방법이다. 튜닝은 단일 클래스나 단일 루틴, 더 일반적으로 몇 줄의 코드에 영향을 미치는 작은 규모의 변경을 말한다. 튜닝은 성능을 향상시키는 다른 고수준의 방법이나 큰 규모의 설계상 변경을 말하는 것이 아니다. 

## 25.2 코드 튜닝 소개

> 코드 튜닝의 매력??
**코드 튜닝은 성능을 향상시키는 가장 효과적인 방법이 아니다.**  
프로그램 아키텍처, 클래스 설계, 알고리즘 선택이 일반적으로 더 극적인 향상을 가져온다. 또한 코드 튜닝이 성능을 향상시키는 가장 쉬운 방법도 아니다. 

#### 파레토 법칙
80대20, 파레토 법칙은 20%의 노력으로 80%의 결과를 얻을 수 있다고 한다. 즉 전체 코드 중 20%에 해당하는 루틴이 전체 실행시간의 80%를 차지한다는 이야기다. 
 
#### 코드 튜닝의 미신
* 고급언어에서 코드를 줄이면 결과적으로 기계어 코드의 속도나 크기를 향상시킨다.
* 어떤 연산이 아마 다른연산보다 빠르거나 비용이 작을것이다. 
	* 성능에 대해선 '아마'라는 말은 통하지 않는다. 변경사항이 도움이 되는지 성능을 측정해야 한다. 
* 코드를 작성하면서 최적화 해야 한다.
	* 각 루틴을 작성하면서 가능한 코드를 가장 빠르고 작게 작성하려고 하면 프로그램이 빨라지고 작아질것이다, 하지만 이러한 접근 방법은 개발자들이 세부적인 최적화를 하느라 중요한 전역적인 최적화를 무시하는 상황을 만든다.
* 빠른 프로그램은 정확한 프로그램만큼 중요하다.
	* 제대로 동작하지 않는 프로그램은 아무 의미없다.

## 25.3 느리고 비대한 부분

### 비효율성의 공통적인 원인  

>입력/출산(I/O) 연산 
비효율성의 가장 중요한 원인 중 하나는 불필요한 입력/출력(I/O)이다. 따라서 공간이 중요하지 않다면 인메모리 방식을 사용하자. 

> 페이징(Paging)
> 운영체제가 메모리 페이지를 교체하게 하는 연산은 메모리 페이지 하나에서 작동하는 연산보다 훨씬 느리다.

>시스템 호출
>시스템 루틴을 호출하면 문맥전환(context switching)이 발생한다. 디스크, 키보드, 스크린, 프린터, 기타 장치에 대한 입력/출산 연산을 비롯한 루틴을 포함한다. 
>>문맥전환(context switching)
다중 프로그램 환경에서 어떤 프로그램을 중단하고 다른 프로그램을 재개할 때, 재개에 필요한 환경을 설정하는 것

> 인터프리터 언어
> 인터프리터 언어는 기계어 코드를 생성하고 실행하기 전에 각 프로그래밍 언어 명령을 처리해야 하므로 상당한 성능 손해가 있다.

> 오류 코드
> 코드에 남겨진 디버깅 코드, 메모리 할당 해제 잊음 등등이 있다.

### 공통적 연산의 상대적인 성능비용

성능을 측정하지 않고는 어떤 연산이 다른 연산보다 비싸다고 확신할수 없지만, 특정한 연산은 좀 더 비싼 경향이 있다. 예를 들면, 난해한 함수(sqrt(), sin(), log() 등등)

##  25.4 측정

일반적으로 프로그램의 작은 부분이 실행시간을 많이 차지하기 때문에 그러한 과열지점을 찾아야 한다. 그리고 과열지점을 최적화하고 코드를 다시 측정해 코드가 얼마나 향상 됐는지 평가한다. 성능과 관련해서 직관으로 내린 결론이 기대와 다른 부분이 많다. 

책의 예제로는 행렬의 요소를 더하기 위한 이중 for문을 들었다. 포인터를 이용한 최적화로 성능 향상을 꾀했지만 컴파일러가 이미 최적화를 하여 성능을 높이고 있었다. 

## 코드 튜닝 단계 요약
코드 튜닝이 프로그래밍 성능 향상에 도움이 되는지 고려할때 아래 단계를 밟자. 

1. 이해하고 변경하기 쉬운 잘 설계된 코드를 사용하여 소프트웨어 개발을 한다. 
2. 성능이 좋지 않다면
	1.  마지막으로 좋았던 상태로 돌아오도록 기존 코드를 저장한다
	2. 과열지점을 찾는다
	3. 성능이 느린것이 설계, 데이터 구조, 알고리즘 때문인지 판단하고 코드 튜닝이 적절한지 판단한다.
	4. 한번에 하나씩 성능을 튜닝하고 측정한다.
	5. 성능이 향상되지 않았다면 튜닝전 저장했던 과거로 돌아간다. 일반적으로 튜닝시도의 절반이상은 오히려 성능에 악영향을 미친다.

# 26장 코드 튜닝 기법
이 장에서는 속도 향상에 대한 내용을 중점적으로 소개하고 코드를 작게 만드는 몇 가지 팁을 소개한다. 일반적으로 성능은 속도와 크기 모두를 말하지만, 크기 감소는 코드를 튜닝하는 것보다 클래스와 데이터를 재설계하는것에 영향을 더 받는다. 코드 튜닝은 큰 규모의 변경보다는 작은 규모의 변경을 말한다. 

## 26.1 논리 구조
프로그래밍의 상당 부분은 논리 구조를 다루는 작업으로 이루어진다. 

### 답을 알고 있을때는 테스트를 중단하라
```
if(5<x && x < 10) then
```
x가 5보다 크다는게 결정되면 그 이후의 테스트는 수행할 필요가 없다. 

### 빈도에 따른 테스트 정렬
가장 빠르고 참일 가능성이 가장 높은 테스트가 맨 먼저 수행되도록 테스트를 정렬한다. 보통 Case 문과 if-then-else문에 적용된다.

최적화된 코드에서는 가장 흔한 경우가 대개 더 일찍 발견 되기 때문에 전체적으로 보면 더 적은 테스트를 수행하는 결과가 된다. 

### 복잡한 표현식을 테이블 참조로 대체하라
어떠 환경에서는 복잡한 논리 구조를 상세하게 따지는 것보다 테이블 참조가 더 빠를 수 있다. 복잡하게 연결됐다는 것은 대개 무언가를 분류하고 나서 그 범주를 기반으로 작업을 수행하는 것이다. 
```
if( (a && !c) || (a && b)){
	category = 1;
} else if((b && c) || (c && !b)){
	category = 2;
} else if() //
```
위 처럼 복잡한 논리 구조를 따르는 것보다...

``` 
categoryTable [][][] // 테이블 정의를 통해서 복잡한 논리구조를 쉽게 읽게 한다.
```

### 소극적 평가를 사용하라
소극적 평가(lazy evaluation)를 하면 작업이 정말 필요해질때 까지 어떠한 작업도 하지 않는다. 소극적 평가는 필요한 순간에 작업하는 JIT(Just in Time) 전략과 유사하다. 

가령 5000로우의 테이블이 있고 프로그램 시작시 테이블 값을 생성한 다음, 프로그램이 실행되면서 그것을 사용하는 프로그램이 있다고 하자. 그런데 그중 테이블의 일부만 사용한다면 필요할때만 사용하는 것이 좋다.

## 26.2 반복문
반복문은 여러 번 수행되기 때문에 프로그램에서 문제가 발생할 확률이 높다. 

### 스위칭 해제
스위칭은 반복문이 실행될때마다 반복문내에서 무언가를 결정하는 것을 말한다. 반복문이 실행되는 동안 결정이 변하지 않는다면 반복문 밖에서 결정함으로써 불필요한 스위칭을 하지 않을 수 있다.
```
스위칭 되는 반복문을 작성
for(){
	if(condition1){
		...
	} else if(){
		...
	}
}
```
condition1 조건이 항상 같다면, 굳이 반복문 안에서 테스트를 할 필요가 없다. 

```
스위칭 해제한 반복문
if(condition1){
	for(){}
} else if(condition2){
	for(){}
}
```

사실 이 코드는 여러가지 좋은 프로그래밍 규칙을 위반한다. 가독성과 유지보수 편의성이 더 중요한데, 성능을 위해서 다른 규칙과 트레이드 오프를 하고 있다. 게다가 비주얼 베이직에서는 이런 튜닝후 눈에 띄는 성능향상이 없었다. 

**거듭 강조하지만 어떤 최적화는 효과를 확인하려면 반드시 측정을 해야 한다.**

### 결합(fusion)
같은 요소의 집합을 다루는 두 개의 반복문을 결합한 결과다. 두개의 반복문을 하나로 줄임으로써 반복문의 반복횟수를 줄일 수 있다. 

### 코드 풀어쓰기
반복문을 쓰는 이유는 코드의 양을 줄이기 위한 것이다. 완전히 풀어쓰는것이 성능에는 도움이 되지만 코드의 품질과 유지보수가 어려워진다. 또 언어에 따라 튜닝이 될수도 있고 아닐 수도 있기 때문에 꼭 튜닝후 측정을 해라. 

### 반복문 내부 작업 최소화

성능을 높이려면 반복문 내부에서 처리되는 작업을 최소화해야한다. 

### 감시값

반복문에서 복합적인 테스트를 수행할때는 내부의 테스트를 단순화함으로써 시간을 절약 할수 있다. 반복문이 검색을 위해서라면 단순화하는 한 방법은 검색 범위의 끝을 지났을때 검색이 종료되게 하려고 입력하는 값인 감시값을 사용하는것이다. 


```
found = false;
i = 0;
while(found == false && i < count){
	if(item[i]==testValue){
		found = true;
	} else {
		i++;
	}
}

if(found){	
	...
}
```

이 코드에서 found를 찾기 위해 모든 요소를 검색한다. 사실 찾기만 하면 for문을 더이상 돌필요가 없다. 

```
i = 0;
while(item[i] != testValue){
	i++
}

if(i < count){\
	...
}
```

이 방법은 어떤언어에서도 효과가 있다. 

### 가장 빈번하게 실행되는 반복문을 안쪽에 작성한다.

중첩된 반복문이 있을때 어떤 반복문을 안쪽에 넣고 어떤 반복문을 바깥에 둘리 생각해본다. 

```
for(col = 0; col < 100; col++){
	for(row = 0; row < 5; row ++){
		...
	}
}
```
문제는 바깥쪽에 있는 반복문이 안쪽에 있는 반복문보다 더 자주 실행된다는 것이다. 반복문이 실행될때 마다 반복문 인덱스를 초기화하고 인덱스를 증가시키고 반복하고 난 다음에는 인덱스 값을 검사해야한다. 

바깥쪽에 있는 전체 실행횟수가 100이고 안쪽 반복문의 실행회수가 500이라 전체적으로 600번 반복한다. 단순히 안쪽과 바깥쪽을 바꾸는 것만으로 바깥 실행회수는 5번 안쪽은 500번이 되어 전체적으로 505번이 된다. 

### 연산 줄이기

연산 줄이기는 곱셈과 같이 오래걸리는 연산을 덧셈과 같이 적게 걸리는 연산으로 대체하는 것을 의미한다. 일반적으로 덧셈이 곳셈보다 빠르고 곳셈대신 그만큼은 반복해 더하면 같은 코드가 더 빠르게 실행될 것이다. 

## 26.3 데이터 변환

데이터형의 변화는 프로그램의 크기를 줄이고실행속도 향상에 도움이 된다. 데이터 형의 구현을 적당히 변경해도 성능 향상이 가능하다. 

### 부동 소수점 수 대신 정수를 사용하라.

정수의 덧셈과 곱셈은 부동 소수점의 덧셈과 곳셈보다 빠른 경향이 있다. 

### 가능한 가장 적은 차수의 배열을 사용하라

다차원 배열은 느리다는게 일반적인 통념이다. 2차원이나 3차원 배열 대신 1차원 배열로 구성하면 어느정도 시간을 절약할수있을것이다. 

하지만 최적화 결과에서 C++이나 C#을 제외하고는 모두 개선되었다. 즉 맹목적인 통념을 따르는게 얼마나 위험한지 보여준다. 개발환경에서 직접 확인하기 전에 튜닝의 성능이 좋을것이라고 확신해서는 안된다.

### 배열에 대한 참조를 최소화 하라

사실 배열에 대한 접근 자체를 최소화하는것이 좋다.

``` 
//discount[type]이 계속해서 호출된다.
for(type =0; type < typeCount; type++ ){
	for(level = 0; level < levelCount; count++){
		result[level] = result[level]+discount[type]
	}
}
```

``` 
//discount[type]을 필요할때 호출한다.
for(type =0; type < typeCount; type++ ){
	disCountType = discount[type];
	for(level = 0; level < levelCount; count++){
		result[level] = result[level]+disCountType
	}
}
```

### 보조 인덱스를 사용하라

보조 인덱스는 데이터형에 더 효율적으로 접근하기 위해 추가하는 데이터다. 관련 데이터는 주 데이터형에 추가하거나 병렬구조에 저장할 수 있다. 

* 문자열 길이 인덱스
	* 문자열 길이를 저장하는 바이트를 따로 저장하자. 그러면 특정 연산 수행시 처음부터 일일이 문자열을 읽을 필요가 없다.
* 독립적인 병렬 인덱스 구조
	* 때로는 저장되어 있는 데이터 자체를 이동시키기 어렵다면 데이터에 인덱스를 주어 정렬하고 검색하는 것이 빠르다.
* 캐싱을 사용하라
	* 일반적으로 새로운 요소를 생성하는데 비용이 비싸고 같은 정보를 호출하는 횟수가 많을 수록, 캐시된 요소에 접근하기 쉽고 저장하는 비용이 저렴할 수록 좋다. 

## 26.4 표현식

프로그램의 상당 부분은 수학적, 논리적 표현식으로 처리된다. 복잡한 표현식은 비싼 경향이 있어 싸게 만드는 법을 알아 보자.

### 대수 항등식을 사용하라

not A and not B = not(A or B) // 드모르간의 법칙 
not 연산을 하나 줄일수 있다. 

Math.sqrt(x) < Math.sqrt(y) <=> x < y  
Math.sqrt 비용을 절약할 수 있다.	

### 연산 줄이기

* 곱셈을 덧셈으로 대체
* 거듭제곱을 곳셈으로 대체
* longlong -> long이나 int로 대체
* 부동 소수점 수를 고정 소수점 수나 정수로 대체
* 배정도 부동 소수점을 단정도 부동 소수점 수로 대체
* 정수에 2를 곱하거나 2를 나누는 계산은 시프트 연산으로 대체

### 컴파일 시간에 초기화하라

루틴 호출 전에 상수나 매직 넘버를 사용하면 성능을 계선할 수 있다. 
```
unsigned int Log2(unsigned int x){
	return (unsigned int) (log(x) / log(2));
}
```

여기서 사용되는 log(2) 값은 절대로 변하지 않기 때문에 상수로 두면 좋다

```
const double LOG2 = 069314718;
```

### 시스템 루틴을 주의하라.

시스템 루틴은 비싸고 종종 쓸데 없이 정확하다. 앞 예제에서 log2()루틴은 정수값을 리턴하지만 이것을 계산하는데  부동 소수짐 log()루틴을 사용했다. 이것이 너무 지나친 계산일때가 있다. 

```
unsigned int Log2(unsigned int x){
	if(x<2) return 0;
	if(x<4) return 1;
	if(x<8) return 2;
	if(x<16) return 3;
	...
}
```
위와 같이 사용하면 절대로 부동 소수점을 변환하지 않고 성능이 뛰어나다. 

소위 초월함수로 불리는 대부분 함수는 최악의 경우를 대비해 설계되어 정확성을 위해 성능이 느리다. 정확성이 필요 없고 성능을 생각한다면 위의 루틴을 피하도록 하자

또 다른 방법으로 오른쪽 시프트 연산이 2로 나누는 것과 같다는 사실을 이용하는 것이다. 
```
unsigned int Log2(unsigned int x){
	unsigned int i = 0;
	while( ( x = ( x >> 1 ) ) != 0){
		i++;
	}
	return i;
	...
}
```
시프트 연산을 잘 모르면 매우 읽기가 힘들다. while조건안에 있는 복잡한 표현식은 타당한 이유가 없다면 반드시 피해야 한다. 

### 상수의 정확한 타입을 사용하라 

값을 할당하고자 하는 변수와 같은 타입의 이름 상수와 리터럴을 사용한다. 좋은 컴파일러는 컴파일 시간에 타입 변환을 하기 때문에 실행시 성능에 영향을 주지 않는다.

### 결과를 사전에 계산하라

낮은 수준 설계에서는 일반적으로 결과를 실행 중에 계산할건지, 계산을 한번 수행하고 저장한 다음 필요할때마다 참조할 것인지 결정한다. 결과가 여러번 사용된다면 한번 계산하고 나머지는 그 값을 참조하게하는게 낫다. 

* 프로그램이 실행되기전에 결과를 한번만 계산하고 필요할때 마다 참조한다.
* 처음 필요할때 결과를 계산하고 다시 필요할때 가져올수 있도록 저장한다.

### 공통적인 하위 표현식을 제거하라

여러번 반복되는 표현식을 발견하면 그 표현식을 여러 곳에서 다시 계산하는대신 변수에 할당하고 변수를 참조한다. 
```
payment = loanAmount / (
	( 1.0* Math.pow(1.0 + (interestRate / 12.0), - months ))/(interestRate / 12.0)
);
```
복잡한 표현식에서 공통적인 영역을 찾아 하나의 변수로 추출한다. 
```
monthlyInterest = interstRate / 12.0
```

## 26.5 루틴

코드 튜닝에서 강력한 전략 중 하나는 훌륭한 루틴 분해다. 작고 잘 정의된 루틴은 여러 곳에서 독립적으로 수행할 작업을 대신해주기 때문에 공간을 절약할 수 있다.

### 루틴을 인라인으로 재작성하라

프로그래밍 초기 시절, 어떤 장비에서는 루틴을 호출하면 성능이 크게 떨어졌다. C++의 inline 키워드와 같은 언어의 기능을 이용하여 루틴에 있는 코드를 프로그램의 필요한 위치에 곧바로 놓아 속도를 개선할 수 있다. 

하지만 최신 장비는 사실상 루틴을 호출한다고 해서 성능에 큰 손해를 입히지는 않는다. 

## 26.6 저급언어를 이용한 재구성

반드시 집고 넘어거야한 통념 중 하나는 성능에 병목이 생겼을때 저급 언어로 구현해야 한다는 충고이다. 아래는 저급 언어로 최적화 하는 전형적인 절차다.

1. 고급언어로 응용프로그램을 작성한다
2. 응용 프로그램을 완전히 테스트하고 정확한지 검증한다.
3. 성능 개선이 필요하다면 문제가 발생하는 지점을 찾는다. 일반적으로 프로그램의 약 5% 해당하는 부분이 실행시간의 50%를 차지한다.
4. 전체 성능을 개선하기 위해 작은 부분을 저급 언어로 재작성한다.

이 절차를 따를지는 자신의 저급 언어 실력과 프로그램이 얼마나 어셈블러에 적합한지, 그리고 개발자의 노력에 달렸다. 

저자는 암호화 표준 프로그램에 이 기법을 사용했는데 당시 알고 있던 모든 최적화 방법을 사용했고 유일한 방법이 어셈블러로 재작성하는 것이었다. 어셈블러 언어에 초보여서 고급언어를 저급언어로 직역하는 것이 다 였지만 성능이 50%나 향상되었다. 

## 26.7 변경이 많을 수록 상태는 그대로

Code Complete 초판이 발견된 이후 10년 동안 많은 변화가 있어 책에서 설명한 성능 최적화가 큰 영향을 미치지 모할만큼 컴퓨터의 성능은 좋아졌다. 하지만 성능 문제는 여전히 이슈가 되고 있다. 데스크톱 프로그래머는 아닐 수 있지만 임베디드 시스템, 실시간 시스템든 제약이 있는 공간에서는 여전히 최적화 기법이 도움이 될수 있다. 

코듀 튜닝은 항상 복잡성과 가독성, 단순성, 유지보수성 그리고 다른 측면에서 성능을 개선하기 위한 노력과 트레이드 오프를 수반한다. 튜닝을 하면 모든 코드를 다시 분석해야 하므로 유지보수의 부담이 커진다. 

측정 가능한 개선을 하는 것이 직감에 의존하여 최적화하려는 유혹을 뿌리치고 직관적이고 좋은 코드를 작성하는 방법이다. 

# 27장 프로그램의 크기가 구현에 미치는 영향

소프트웨어 개발에서 규모를 키우는 것은 작은 프로젝트를 가져다가 각 뿐을 좀 더 크게 만드는 식의 단순한 문제가 아니다. 

이 장에서는 규모가 커진 프로젝트를 어떻게 다루는지 또는 작은 프로젝트는 어떻게 다루는지에 대해 이야기 한다.

## 27.1 의사소통과 크기

프로젝트에 참여하는 사람이 n명이라고 했을때 모든 사람이 의사소통을 하기위한 노력은 $nC_2$이다. 
현실적으로 모든 사람이 의사소통하는것은 어렵고 가장 전형적 방법은 문서로 의사소통하는것이다.

## 27.2 프로젝트 크기의 범위

프로젝트 크기에 대한 개념은 너무 많다. 몇가지 기준을 들자면 팀의 크기와 팀의 크기에 작업하는 개발자의 비율을 측정하는 것이다. 

## 27.3 프로젝트 크기가 오류에 미치는 영향

오류의 양과 종류는 모두 프로젝트의 크기의 영향을 받는다. 오류의 종류에는 영향을 받지 않는다고 새각할지도 모르겠지만 크기가 클 수록 요구사항과 설계에서 발생하는 오류가 많아진다. 

결함의 밀도, 즉 1000줄 당 결함의 수는 아래 
| 프로젝트 크기(줄 단위) | 전형적인 오류의 밀도 |
|--|--|
|2k 이하 | 1000줄당 0~25개 |
|2k - 16k | 1000줄당 0~40개 |
|16k - 64k | 1000줄당 0.5~50개 |
|64k - 512k | 1000줄당 2~70개 |
|512k 이상 | 1000줄당 4~1000개 |

## 27.4 프로젝트의 크기가 생산성에 미치는 영향

생산성은 프로젝트 크기게 있어서 소프트웨어 품질과 공통점이 많다. 작은 크기에서는 생산성에 가장 큰 영향을 미치는 요소가 개발자의 능력이다. 프로젝트가 커질수록 팀의 크기와 조식이 생산성에 더 많은 영향을 미친다. 

팀 크기가 생산성에 영향을 미치기 시작하는 프로젝트의 크기는 얼마일까? 

| 프로젝트 크기(줄 단위) | 팀원당 작성한 코드 줄 수 |
|--|--|
|1k | 2500-25000 |
|2k - 16k | 2000-25000 |
|16k - 64k | 1000-20000 |
|64k - 512k | 700-10000 |
|512k 이상 | 300-5000 |

## 27.5 프로젝트의 크기가 개발 활동에 미치는 영향

작은 프로젝트에서는 구현이 전체 개발 시간의 65%를 차지하고 중간은 50%. 매우 큰 프로젝트에서는 아키텍처, 통합, 시스템 테스트가 더 많은 시간을 차지하고 구현이 차지하는 비율이 줄어든다. 

# 28장 구현관리


## 28.1 훌륭한 코딩 장려

코드가 구현의 주요 산출물이기 때문에 구현 관리에서 좋은 코드 작성 습관을 어떻게 장려할 것인가 하는 문제는 매우 중요하다.

일반적으로 관리자가 엄격한 기술적 표준을 정하는 것은 좋은 생각이 아니다. 개발자들은 관리자의 기술적 수준이 낮다고 보는 경향이 있으며 프로그래밍 표준을 정할거라면 개발자가 직접 정해야 한다. 

프로젝트 표준을 정한다면 휼륭한 아키테트가 정해라. 소프트웨어 프로젝트는 전문적 기술만큼이나 권한에 의해 영향을 받는다. 

### 표준을 정할때 고려할 사항

* 프로젝트의 모든 영역에 두 사람을 할당하라.
	* 두 사람이 함께 작업하면 효율이 좋다.
* 모든 코드를 검토하라
	* 코드 검토는 전형적으로 한명의 개발자와 두명의 검토자가 참여한다. 
* 코드에 서명하라
* 검토를 위해 좋은 예제 코드를 돌려보라
* 코드가 공용자산이라는 것을 강조하라.
* 좋은 개발 방식에 대해 보상을 하라
* 한 가지 쉬운 표준으로 가라

## 28.2 형상 관리 

형상 관리란 시간이 지나면서 시스템이 무결성을 유지하도록 체계적으로 프로젝트의 부산물을 파악하고 변화를 처리하기 위한 행위로, 변경 관리라고도 한다. 일반적으로 소프트웨어 형상 관리(SCM)이라고 부르는 프로젝트를 사용하는데 SCM은 프로그램의 요구사항과 소스코드, 문서화, 테스트 데이터에 중점을 둔다. 

### 요구사항과 설계의 변경

설계의 변경을 제어하기 위한 몇 가지 지침

* 체계적인 변경관리 절차를 따르라
* 변경 요구사항을 그룹으로 처리하라
* 각 변경 비용을 산출하라
* 지나친 변경을 주의하라
* 관료주의를 주의하되, 관료주이에 대한 두려움이 효과적인 변경관리를 방해하지 않도록 한다. 

## 28.3 구현 일정 예측

프로젝트 예측을 위한 다양한 방법

* 예측기능이 있는 소프트웨어를 사용한다.
* 배리 보엠의 예측 모델인 Cocomo 2와 같은 알고리즘적 방법을 사용한다. 
* 외부의 측정 전문가가 프로젝트를 예측하게 한다. 
* 예측을 위한 회의를 한다
* 프로젝트의 부분별로 예측하여 각 예측의 합을 구한다. 
* 사람들이 자신의 작업을 예측하게 하고 작업의 합을 구한다
* 이전 프로젝트의 경험을 참조한다
* 이전 예측을 가지고 있다가 그것이 얼마나 정확한지 본다. 


### 일정에 뒤처졌을때 해야할 일

일반적인 프로젝트는 거의 100%확률로 계획된 일정을 초과한다. 일정을 초과했을때 작업 시간을 늘리는 경우는 별로 없다. 하지만 아래와 같은 해결책을 시도해 볼수 있다


* 일정에 맞출수 있다는 희망을 품어라
* 팀을 키워라
	* 일정이 늦은 소프트웨어에 사람을 추가한다고 프로젝트를 맞출수는 없다. 오히려 더 늦어 진다.
* 프로젝트의 범위를 축소하라
	* 반드시 갖추어야할것을 추수려 범위를 출이는게 사실 이상적이다.


# 29장 통합

통합이란 용어른 개별적인 소프트웨어 컴포넌트를 하나의 시스템으로 결합하는 소프트웨어 개발 행위를 말한다. 

통합이라는 주제는 구현 순서와 밀접한 연관이 있다. 클래스나 컴포넌트를 작성하는 순서는 그것을 통합하는 순서에 영향을 미친다. 통합과 구현의 순서는 중요한 주제다. 

## 통합 빈도-단계별 또는 점증적 접근 방법

### 단계별 통합

기본적으로 단계별 통합이 일반적이다. 

1. 각 클래스를 설계하고 작성하고 테스트하고 디버깅한다. 즉 단위개발을 한다
2. 클래스를 하나의 큰 시스템으로 결합한다
3. 전체 시스템을 테스트하고 디버깅한다. 

이 통합의 문제점은 시스템에 있는 클래스가 처음 통합될때 불가피하게 새로운 문제점이 발생하고 원인이 발생한 곳을 예상할 수 없다는 것이다. 

수많은 클래스가 이전에는 한번도 함께 동작해 본적이 없기 때문에 모든 클래스를 의심해야 한다. 

발생한 지점을 모르는 것은 갑자기 한순간에 발생한다는점에서 심각하다. 이러한 이유로 단계별 통합을 빅뱅 통합이라고도 한다. 

아주 작은 프로그램에서는 단계별 통합이 최고의 접근 법이다 하지만 대부분의 경우라면 이 통합법을 사용하지 말자.

### 점증적 통합

작은 단위로 프로그램을 작성하고 테스트 한 다음 한번에 하나씩 코드를 결합한다.

1. 크기가 작고 기능적인 부분을 개발한다. 그러한 부분을 전체적으로 테스트하고 디버깅을 하고 통과하면 이 기능은 뼈대 역할을 하게 된다.
2. 클레스를 설계하고 코드를 작성하고 테스트 및 디버깅 한다.
3. 새로운 클래스를 뼈대에 통합한다. 뼈애와 새로운 클래스를 결합한 것을 테스트한다. 잘 동작한다면 2번 을 반복한다.

#### 점증적 통합의 이점

* 오류를 찾기가 쉽다. 
	* 새로운 문제가 발생하면, 추가한 새로운 클래스와 관련이 높다. 
* 시스템이 프로젝트 초기부터 작동한다. 
* 진행 상황을 좀 더 잘 관찰 할 수 있다.
* ...

### 점증적 통합 전략

점증적 통합은 컴포넌트를 구현하는 순서가 통합되는 순서와 맞아야 한다.

#### 하향식 통합

계층 구조 상위에 있는 클래스를 먼저 작성하고 토압한다. 상위 클래스라고 하면, 메인 윈도우나 응용프로그램 제어 루프, 자바 main함수 와 같은것을 포함하는 객체를 말한다. 

중요한 특징은 클래스사이의 인터페이스를 신중하게 명시해야 한다는 것이다. 디버깅 하기 가장 어려운 오류는 어느 한 클래스에 영향을 미치는 오류가 아니라 클래스 사이에 미묘한 상호작용으로 발생하는 오류다. 주의 깊게 인터페이스를 명시하면 그런 문제를 줄일 수 있다.  

장점 
1. 시스템의 제어 논리 구조를 비교적 일찍 테스트 할 수 있다는 장점이 있다. 구조 상위에 있는 클래스는 모두 많이 사용되기 때문에 개념적인 설계상 문제점이 빨리 노출된다. 
2. 프로그램 초기부터 부분적으로 동작하는 시스템을 완성할 수 있다. 
3. 하위 수준 설계 세부 사항이 완성되기 전에 코드를 작성할 수 있다.

단점
1. 순수한 하향식 통합은 까다로운 시스템 인터페이스를 마지막 까지 사용해 볼 수 없다. 하위 수준에서 발생할 수 있는 문제점을 미리 알기가 힘들다.  만약 하위 수준에서 발생하는 문제점이 치명적이라면 어마어마한 개선이 필요하다.
2.  하향식으로 통합하귀 위해 엄청나게 많은 스텁 코드가 필요하다. 많은 저수준 클래스가 통합되지 않았다는 것은 통합 중간에 수많은 스텁이 필요하다는 뜻이다. 
3. 클래스 집합에 최상위라는 개념이 없으면 하향식 통합을 할수가 없다. 상위의 위치가 주관적이다.

순수한 하향식 통합의 좋은 대안은 그림처럼 수직으로 나누는 접근 방법이다. 접근 방법에서 시스템을 부문별로 나누어 하향식으로 구현한다. 순수학 하향식 통합을 실무에 적용하기는 불가능 하지만 가장 일반적인 접근 방법이다.

### 상향식 통합

상향식통합에서는 계층 구조 맨 아래부터 클래스를 작성하고 통합한다. 

장점
1. 오류의 원인을 통합되고 있는 단일 클래스로 제한하기 때문이 오류찾기가 쉽다.
2. 까다로울수 있는 시스템 인터페이스를 초기에 사용한다. 즉 필요한 기능을 제대로 제공하는지 바로 알 수 있다.

단점
3. 마지막에 가서야 고수준 시스템 인터페이스를 통합할 수 있다. 시스템이 상위 수준에서 개념적인 설계상 문제를 가지고 있다면 구현과정에서 발견이 어렵다.
4. 통합을 시간하기 전에 전체 시스템 설계를 마쳐야 한다. 그러면 설계 시 다루지 않았던 가정이 저수준 코드게 포함되게 되며 저수준 코드에서 발생한 문제점을 해결하려고 상위 수준 클래스를 설계해야 하는 상황이 일어 난다. 저수준의 세부사항이 상위 수준 클래스의 설계에 영향을 미치는 것은 이상하다.

순수한 상향식 방법은 드물고 부분적으로 통합하는 하이브리드 접근법을 쓴다.


### 샌드위치 통합
앞서 이야기한 순수한 하향식 통합과 상향식 통합의 문제 때문에 몇몇 전문가들은 샌드위치 접근 방법을 권장한다.

우선상위 수준에서 비지니스 클래스를 통합한다. 그리고 하위 수준에서 널리 사용되는 유틸리티 클래스를 통합한다. 여기서 고수준 클래스와 저수준 클래스가 샌드위치의 빵역할을 한다. 

중간 클래스는 나중까지 남겨놓고 원하는대로 통합한다.

이 접근법은 순수한 상향식이나 하향식 토앟ㅂ의 엄격함을 피해갈 수 있다. 

### 위험 지향적인 통합

어려운 부분 우선 통합이라고 불린다. 이 방법도 최상위와 최하위 클래스를 먼저 통합하고 중간 수준 클래스를 나중에 통합한다. 

위험지향적인 통합은 각 클래스에 구현하기 어려전 정도를 결정하여 그 부분을 먼저 구현한다. 경험적으로 최상위 인터페이스에 위험요소가 많기 때문에 인터페이스를 먼저 통합한다. 결과적으로 난이도가 쉬운 중간 클래스는 가장 나중에 통합된다.

### 기능 지향적인 통합

한번에 하나의 기능을 통합하는 것이다. 기능이란 시스템의 구체적인 기능을 말하는데 예를들면 워드프로세스 아래 밑줄을 표시한다던가...

일반적으로 컴포넌트는 하나의 기능을 이루고 있는 계층적인 클래스의 집합인 기능 트리에 추가된다. 각 기능이 독립적이면 통합하기 쉽다.

### T 자형 통합

초기 개발과 통합을 위해 특정 시스템에 부분이 선택된다. 선택된 부분은 가장 핵심적이고 중요한 부분이고 그 이후에 연관된 시스템을 개발해 나간다.

# 30장 프로그래밍 도구

최신 프로그래밍 도구는 개발시간을 줄여준다. 최첨단 도구를 사용하고 그 도구에 익숙해지면 생산성을 50%이상 향상 시킬수 있다. 

이 장의 목표는 유용하게 쓸 수 있는 도구를 그냥 지나친 것은 아닌지 스스로 판단하게 돕는 것이다.

## 30.1 설계 도구

요즘 설계도구는 주로 설계 다이어 그램을 그리는 그래픽 도구로 이루어져 있다. 그래픽 설계 도구는 일반적으로 UML, ERD, 클래스 다이어그램 등이 있다.

## 30.2 소스코드 도구

이 도구들은 소스코드 편집과 관련이 있다.

> 통합 개발환경(IDE)
* 다중 파일 문자열 검색 및 바꾸기
* 차이 비교 도구
	* 두개의 파일을 비교하는 도구(Diff)
* 병합 도구
* 소스코드 정돈 도구
* 인터페이스 문서화 도구
	* javadoc이 대포적 예
* 템플릿 
	* 자주 수행하거나 일관성 있는 코드를 간단히 만들어준다.
* 참조 도구
	* 변수와 루틴, 그리고 클래스를 나열한다.
* 클래스 계층 구조 생성기
	* 상속 트리 정보 생성 및 모듈화 가능

> 코드 품질 분석

* 까다로운 문법 및 의미 검사기
	* 컴파일러보다 더 광범위하게 코드를 검사하여 컴파일러의 부족한 점을 채워준다.
* 메트릭 보고 도구
	* 코드를 분석하여 코드의 품질을 보고한다. 

> 소스코드 리팩터링

* 리팩터링 도구
	* 일반적으로 IDE에 통합되어 리팩토링 기능을 지원한다.
* 재구성 도구
	* goto같은 스파게티 코드를 더 좋은 구조로 만든다.
* 코드 변환 도구

> 버전관리

* 데이터 사전
	* 모든 데이터를 설명하는 데이터베이스다. 주로 데이터 베이스 스키마를 다룬다. 

### 30.3 실행 코드 도구

> 코드 생성

* 컴파일러와 링커
	* 링커는 컴파일러가 생성한 소스코드로부터 생성한 하나 이상의 객체 파일과 실행 가능한 프로그램을 만드는데 필요한 표준 코드를 연결한다. 

* 빌드 도구
	* 최신버전의 소스코드를 사용하는 프로그램의 빌드 시간을 줄여준다. 대표적으로 make유틸과 자바 프로그램 ant가 있다.

### 마치며...

수십년 동안 도구 벤더와 업계 학자들은 프로그래밍 없애는데 필요한 도구가 있을 것이라고 생각했고 그 별칭을 받은 도구는 포트란 이였다. 
포트란(Formula Translation Language)는 수식변환 언어로 과학자와 공학자가 공식에 간단히 입력할 수 있게 되어 개발자에게는 별로 필요 없을거라고 여겨졌다.

소프트웨어 산업은 지루한 작업을 줄이거나 제거하기 위해 새로운 도구를 계속 개발한다. 새로운 도구가 생산성에 나은 결과를 보여주기 시작하면 그것이 계속 좋아질거라 추정하고 프로그래밍의 필요성을 없앨것이라고 생각한다. 

지난 수년 동안 많은 개발자들이 프로그래밍은 없애기 위해 노력했지만, 그 결과로 컴퓨터 프로그래밍에 진보를 가져왔다. 심지어 새로운 도구가 나오기 전에 프로그래밍을 배웠던 사람은 새로운 프로그래밍을 알아 볼수 없게 만들었다. 하지만 어느것도 프로그래밍 자체를 없애지는 못했다.

이렇게 계속 도구가 발전하는 이유는 본질적으로 프로그래밍은 어렵기 때문이다. 어떤 도구가 있더라도 현실에 복잡성과 싸워 나가야 한다.

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNzI3NjYyMTQsNjQxMDIzMDEwLDExNz
I2OTg4MDAsLTQyOTk0NDMxLC0yMDI0Nzc3Mjg1LC0yMDM4MDE5
NjQwLC0xNTQzMjQ5MTAyLDUwMDc0MzU0MiwtODUzNDg0OTY4LC
0xMDk3Mjc5OTQ3XX0=
-->