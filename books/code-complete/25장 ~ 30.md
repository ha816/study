# 25장 코드 튜닝 전략

역사적으로 논란이 많았던 성능 튜닝 문제 논의하자.
성능은 전략과 전술이라는 두 가지 측면을 가지고 설명한다. 이 장에서는 성능 전략을 설명한다. 만약 성능 전략에 대해 잘 파악하고 있고 성능 향상을 위한 구체적인 기법을 찾고 있다면 26장으로 넘어가자.

## 25.1 성능이란?

코듀 튜닝은 프로그램 성능 향상에 한 방법이다. 그렇지만 코듀 튜닝보다 시간이 덜 걸리고 코드에 손상도 덜 주는 성능 향상 방법도 쉽게 찾을수 있다. 그러한 방법을 알아보자. 

사용자는 코드의 품질보다 구체적인 프로그램의 특성에 더 많은 관심을 둔다. 따라서 소프트웨어를 제시간에 전달하고 깔끔한 사용자 인터페이스를 제공하고 오류 및 고장을 피하는 것이 더 중요하다. 

성능과 코드 속도는 어느정도 관련이 있다. 그렇지만 속도를 더 빠르게 만들려고 다른 특성을 희생하는 것은 조심해야 한다. 속도에 대한 작업이 전체적인 성능에는 해를 입힐 수 있다. 

성능은 프로그램 전체의 성능을 뜻한다. 즉 성능이 코드속도를 포함하는 더 큰 개념. 코드 속도는 말그대로 기능의 수행속도를 말한다. 

### 성능과 코드 튜닝

효율화를 최우선 순위로 두어 효율화에 앞서 각 관점에서 바라본 효율화가 무엇인지 생각해보자. 

#### 프로그램 요구사항
성능에 대한 요구사항은 굉장히 빈번하다. 성능 요구사항을 해결하는데 투자하기 전에 마땅히 해결해야하는 문제인지 먼저 확인한다. 
예제에서는 요구 사항을 쉽게 변경(응답시간 1초 이하 > 응답시간 4초 이하)하여 비용과 설계를 쉽게 만들었다.

#### 프로그램 설계

프로그램 설계에는 주로 프로그램을 여러 개의 클래스로 나누는 방법에 해당하는 단일 프로그램 설계라는 주요 작업이 포함된다. 

프로그램의 크기와 속도가 중요하다면 묵표를 합리적으로 달성하도록 아키텍처를 설계한다. 성능 중심의 아키텍처 설계후 개별적인 서브시스템과 기능, 클래스에 대한 리소스 목표를 설정한다. 

예제에서는 소프트웨어 레벨의 코드 튜닝으로는 도저히 해결하기 힘든 문제를 하드웨어 설계수준에서 해결하는 예를 들었다. 

#### 클래스와 루틴 설계

클래스와 루틴의 내부 설계는 성능에 도움이 되게 설계할 수 있는 또 다른 기회를 제공한다. 이 수준에서 할 수 있는 부분은 데이텨 형과 알고리즘을 선택하는 것으로, 대게 프로그램의 메모리 사용과 실행 속도에 영향이 있다. 

#### 운영체제 상호작용
프로그램 외부 파일이나 동적 메모리, 출력 장치를 다룬다면 운영체제와 상호작용할 것이다. 성능이 좋지 않다면 운영체제 루틴이 느리거나 비대하기 때문일 것이다. 때때로 컴파일러는 꿈도 꾸지 않았던 시스템 호출이나 시스템 호출을 일으키는 라이브러리를 생성한다.

#### 코드 컴파일
좋은 컴파일러는 ㅋ고급 프로그래밍 언어 코드를 최적화된 기계어 코드로 변환한다. 올바른 컴파일러를 선택하면 속도 최적화에 대해선 더 생각하지 않아도 된다. 

#### 하드웨어
때로는 프로그램의 성능 향상을 위해서 가장 저렴한 방법이 새로운 하드웨어를 구입하는 것일 수도 있다. 수십만명의 고객이 사용하는 프로그램의 경우 새로운 하드웨어를 구매하는것은 비현실적이다. 소수의 고객을 위한 주문형 소프트웨어를 개발한다면 하드웨어 업그레이드가 가장 저렴한 대안일 것이다.

#### 코드 튜닝
코드 튜닝은 코드가 더 효율적으로 작동하도록 정확하게 수정하는 방법이다. 튜닝은 단일 클래스나 단일 루틴, 더 일반적으로 몇 줄의 코드에 영향을 미치는 작은 규모의 변경을 말한다. 튜닝은 성능을 향상시키는 다른 고수준의 방법이나 큰 규모의 설계상 변경을 말하는 것이 아니다. 

## 25.2 코드 튜닝 소개

코딩 튜닝의 매력? 
-> 코딩 튜닝은 성능을 향상시키는 가장 효과적인 방법이 아니다.  프로그램 아키텍처,클래스 설계, 알고리즘 선택이 일반적으로 더 극적인 향상을 가져온다. 또한 튜닝 성능이 향상시키는 가장 쉬운 방법도 아니다. 

#### 파레토 법칙

80/20 법칙으로 알려진 파레토 봅칙은 20%의 노력으로 80%의 결과를 얻을 수 있다고 하나다. 

즉 전체 코드 중 20%에 해당하는 루틴이 전체 실행시간의 80%를 차지한다는 이야기다. 
 커누스라는 사람은 많이 사용되는 코드를 발견하여 그 부분을 최적화하는데 노력하여 큰 성과를 거뒀다. 

#### 코드 튜닝의 미신

* 고급언어에서 코드를 줄이면 결과적으로 기계어 코드의 속도나 크기를 향상시킨다.
* 어떤 연산이 아마 다른것보다 빠르거나 작을것이다. 
	* 성능에 대해서 말할때 아마라는 말은 통하지 않는다. 변경사항이 도움이 되는지 성능을 측정해야 한다. 
* 코드를 작성하면서 최적화 해야 한다.
	* 각 루틴을 작성하면서 가능한 코드를 가장 빠르고 작게 작성하려고 하면 프로그램이 빨라지고 작아질것이다, 하지만 이러한 접근 방법은 개발자들이 세부적인 최적화를 하느라 중요한 전역적인 최적화를 무시하는 상황을 만든다.
* 빠른 프로그램은 정확한 프로그램만큼 중요하다.
	* 제대로 동작하지 않는 프로그램은 아무 의미없다.

## 25.3 느리고 비대한 부분

### 비효율성의 공통적인 원인  

>입력/출산(I/O) 연산 
비효율성의 가장 중요한 원인 중 하나는 불필요한 입력/출력(I/O)이다. 따라서 공간이 중요하지 않다면 인메모리 방식을 사용하자. 

> 페이징(Paging)
> 운영체제가 메모리 페이지를 교체하게 하는 연산은 메모리 페이지 하나에서 작동하는 연산보다 훨씬 느리다.

>시스템 호출
>시스템 루틴을 호출하면 문맥전환(context switching)이 발생한다. 디스크, 키보드, 스크린, 프린터, 기타 장치에 대한 입력/출산 연산을 비롯한 루틴을 포함한다. 

문맥전환(context switching)
다중 프로그램 작성 환경에서 어떤 프로그램을 중단하고 다른 프로그램을 재개할때, 다른 프로그램 재개에 필요한 환경을 설정하는것

> 인터프리터 언어
> 인터프리터 언어는 기계어 코드를 생성하고 실행하기 전에 각 프로그래밍 언어 명령을 처리해야 하므로 상당한 성능 손해가 있다.

> 오류 
> 성능 문제의 마지막 원인은 코드에 있을 오류다. 오류 코드에 남겨진 디버깅 코드, 메모리 할당 해제 잊음 등이 있다.


### 공통적인 연산의 상대적인 성능비용

성능을 측정하지 않고는 어떤 연산이 다른 연산보다 비싸다고 확신할수 없지만, 특정한 연산은 좀 더 비싼 경향이 있다. 난해한 함수 ...

##  측정

일반적으로 프로그램의 작은 부분이 실행시간을 많이 차지아기때문에 그러한 과열지점을 찾아야 한다. 그리고 과열지점을 최적화했다면 코드를 다시 측정해 코드가 얼마나 향상됐는지 평가한다. 성능과 관련햇거는 직관으로 내린 결론과 다른 부분이 많다. 

컴파일러의 최적화 기능이 최적화를 하여 포인터로 변환하여 성능을 높이고 있었다. 

## 코드 튜닝 단계 요약

코드 튜닝이 프로그래밍 성능 향상에 도움이 되는지 고려할때 아래 단계를 밟자. 

1. 이해하고 변경하기 쉬운 잘 설계된 코드를 사용하여 소프트웨어 개발을 한다. 
2. 성능이 좋지 않다면
	3. 마지막으로 좋았던 상태로 돌아오도록 기존 코드를 저장한다
	4. 과열지점을 찾는다
	5. 성능이 느린것이 설계, 데이터 구조, 알고리즘 때문인지 판단하고 코듀 튜닝이 적절한지 판단하한다.
	6. 한번에 하나씩 성능을 튜닝하고 측정한다.
	7. 성능이 향상되지 않았다면 a단계에서 저장했던 과거로 돌아간다. 일반적으로 튜닝시도의 절반이상은 오히려 성능에 악영향을 미친다.




# 27장 프로그램의 크기가 구현에 미치는 영향

소프트웨어 개발에서 규모를 키우는 것은 작은 프로젝트를 가져다가 각 뿐을 좀 더 크게 만드는 식의 단순한 문제가 아니다. 

이 장에서는 규모가 커진 프로젝트를 어떻게 다루는지 또는 작은 프로젝트는 어떻게 다루는지에 대해 이야기 한다.

## 27.1 의사소통과 크기

프로젝트에 참여하는 사람이 n명이라고 했을때 모든 사람이 의사소통을 하기위한 노력은 $nC_2$이다. 
현실적으로 모든 사람이 의사소통하는것은 어렵고 가장 전형적 방법은 문서로 의사소통하는것이다.

## 27.2 프로젝트 크기의 범위

프로젝트 크기에 대한 개념은 너무 많다. 몇가지 기준을 들자면 팀의 크기와 팀의 크기에 작업하는 개발자의 비율을 측정하는 것이다. 

## 27.3 프로젝트 크기가 오류에 미치는 영향

오류의 양과 종류는 모두 프로젝트의 크기의 영향을 받는다. 오류의 종류에는 영향을 받지 않는다고 새각할지도 모르겠지만 크기가 클 수록 요구사항과 설계에서 발생하는 오류가 많아진다. 

결함의 밀도, 즉 1000줄 당 결함의 수는 아래 
| 프로젝트 크기(줄 단위) | 전형적인 오류의 밀도 |
|--|--|
|2k 이하 | 1000줄당 0~25개 |
|2k - 16k | 1000줄당 0~40개 |
|16k - 64k | 1000줄당 0.5~50개 |
|64k - 512k | 1000줄당 2~70개 |
|512k 이상 | 1000줄당 4~1000개 |

## 27.4 프로젝트의 크기가 생산성에 미치는 영향

생산성은 프로젝트 크기게 있어서 소프트웨어 품질과 공통점이 많다. 작은 크기에서는 생산성에 가장 큰 영향을 미치는 요소가 개발자의 능력이다. 프로젝트가 커질수록 팀의 크기와 조식이 생산성에 더 많은 영향을 미친다. 

팀 크기가 생산성에 영향을 미치기 시작하는 프로젝트의 크기는 얼마일까? 

| 프로젝트 크기(줄 단위) | 팀원당 작성한 코드 줄 수 |
|--|--|
|1k | 2500-25000 |
|2k - 16k | 2000-25000 |
|16k - 64k | 1000-20000 |
|64k - 512k | 700-10000 |
|512k 이상 | 300-5000 |

## 27.5 프로젝트의 크기가 개발 활동에 미치는 영향

작은 프로젝트에서는 구현이 전체 개발 시간의 65%를 차지하고 중간은 50%. 매우 큰 프로젝트에서는 아키텍처, 통합, 시스템 테스트가 더 많은 시간을 차지하고 구현이 차지하는 비율이 줄어든다. 

# 28장 구현관리


## 28.1 훌륭한 코딩 장려

코드가 구현의 주요 산출물이기 때문에 구현 관리에서 좋은 코드 작성 습관을 어떻게 장려할 것인가 하는 문제는 매우 중요하다.

일반적으로 관리자가 엄격한 기술적 표준을 정하는 것은 좋은 생각이 아니다. 개발자들은 관리자의 기술적 수준이 낮다고 보는 경향이 있으며 프로그래밍 표준을 정할거라면 개발자가 직접 정해야 한다. 

프로젝트 표준을 정한다면 휼륭한 아키테트가 정해라. 소프트웨어 프로젝트는 전문적 기술만큼이나 권한에 의해 영향을 받는다. 

### 표준을 정할때 고려할 사항

* 프로젝트의 모든 영역에 두 사람을 할당하라.
	* 두 사람이 함께 작업하면 효율이 좋다.
* 모든 코드를 검토하라
	* 코드 검토는 전형적으로 한명의 개발자와 두명의 검토자가 참여한다. 
* 코드에 서명하라
* 검토를 위해 좋은 예제 코드를 돌려보라
* 코드가 공용자산이라는 것을 강조하라.
* 좋은 개발 방식에 대해 보상을 하라
* 한 가지 쉬운 표준으로 가라

## 28.2 형상 관리 

형상 관리란 시간이 지나면서 시스템이 무결성을 유지하도록 체계적으로 프로젝트의 부산물을 파악하고 변화를 처리하기 위한 행위로, 변경 관리라고도 한다. 일반적으로 소프트웨어 형상 관리(SCM)이라고 부르는 프로젝트를 사용하는데 SCM은 프로그램의 요구사항과 소스코드, 문서화, 테스트 데이터에 중점을 둔다. 

### 요구사항과 설계의 변경

설계의 변경을 제어하기 위한 몇 가지 지침

* 체계적인 변경관리 절차를 따르라
* 변경 요구사항을 그룹으로 처리하라
* 각 변경 비용을 산출하라
* 지나친 변경을 주의하라
* 관료주의를 주의하되, 관료주이에 대한 두려움이 효과적인 변경관리를 방해하지 않도록 한다. 

## 28.3 구현 일정 예측

프로젝트 예측을 위한 다양한 방법

* 예측기능이 있는 소프트웨어를 사용한다.
* 배리 보엠의 예측 모델인 Cocomo 2와 같은 알고리즘적 방법을 사용한다. 
* 외부의 측정 전문가가 프로젝트를 예측하게 한다. 
* 예측을 위한 회의를 한다
* 프로젝트의 부분별로 예측하여 각 예측의 합을 구한다. 
* 사람들이 자신의 작업을 예측하게 하고 작업의 합을 구한다
* 이전 프로젝트의 경험을 참조한다
* 이전 예측을 가지고 있다가 그것이 얼마나 정확한지 본다. 


### 일정에 뒤처졌을때 해야할 일

일반적인 프로젝트는 거의 100%확률로 계획된 일정을 초과한다. 일정을 초과했을때 작업 시간을 늘리는 경우는 별로 없다. 하지만 아래와 같은 해결책을 시도해 볼수 있다


* 일정에 맞출수 있다는 희망을 품어라
* 팀을 키워라
	* 일정이 늦은 소프트웨어에 사람을 추가한다고 프로젝트를 맞출수는 없다. 오히려 더 늦어 진다.
* 프로젝트의 범위를 축소하라
	* 반드시 갖추어야할것을 추수려 범위를 출이는게 사실 이상적이다.



> Written with [StackEdit](https://stackedit.io/).








<!--stackedit_data:
eyJoaXN0b3J5IjpbMjE0MTg4OTQxN119
-->