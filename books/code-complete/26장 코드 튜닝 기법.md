
# 26장 코드 튜닝 기법

이 장에서는 속도 향상에 대한 내용을 중점적으로 소개하고 코드를 작게 만드는 몇 가지 팁을 소개한다. 일반적으로 성능은 속도와 크기 모두를 말하지만, 크기 감소는 코드를 튜닝하는 것보다는 클래스와 데이터를 재설계하는것으로 영향을 더 받는다. 코드 튜닝은 큰 규모설계에 변경보다는 작은 규묘의 변경을 말한다. 


## 26.1 논리 구조

프로그래밍의 상당 부분은 논리 구조를 다루는 작업으로 이루어진다. 

### 답을 알고 있을때는 테스트를 중단하라

```
if(5<x && x < 10) then
```
x가 5보다 크다는게 결정되면 그 이후의 테스트는 수행할 필요가 없다. 

### 빈도에 따른 테스트 정렬

가장 빠르고 참일 가능성이 가장 큰 테스트가 맨 먼저 수행되도록 테스트를 정렬한다. 보통 Case 문과 if-then-else문에 적용된다.

최적화된 코드에서는 가장 흔한 경우가 대개 더 일찍 발견 되기 때문에 전체적으로 보면 더 적은 테스트를 수행하는 결과가 된다. 

### 복잡한 표현식을 테이블 참조로 대체하라

어떠 환경에서는 복잡한 논리 구조를 상세하게 따지는 것보다 테이블 참조가 더 빠를 수 있다. 복잡하게 연결됐다는 것은 대개 무언가를 분류하고 나서 그 범주를 기반으로 작업을 수행하고자 하는 것이다. 

```
if( (a && !c) || (a && b)){
	category = 1;
} else if((b && c) || (c && !b)){
	category = 2;
} else if() //
```
위에 처럼 복잡한 논리 구조를 따르는 것보다...

``` 
categoryTable [][][] // 테이블 정의를 통해서 복잡한 논리구조를 쉽게 읽게 한다.
```

### 소극적 평가를 사용하라

소극적 평가(lazy evaluation)를 하면 작업이 정말 필요해질때 까지 어떠한 작업도 하지 않는다. 소극적 평가는 필요한 순간에 작업하는 JIT(Just in Time) 전략과 유사하다. 

가령 5000개의 값이 테이블이 있고 프로그램 시작시 테이블 값을 생성한 다음, 프로그램이 실행되면서 그것을 사용하는 프로그램이 있다고 하자. 그런데 그중 테이블의 일부만 사용한다면 필요할때만 사용하는 것이 중요하다. 

## 26.2 반복문

반복문은 여러 번 수행되기 때문에 프로그램에서 문제가 발생하는 영역이 확률이 높다. 

### 스위칭 해제 

스위칭은 반복문이 실행될때마다 반복문내에서 무언가를 결정하는 것을 말한다. 
반복문이 실행되는 동안 결정이 변하지 않는다면 반복문 밖에서 결정함으로써 불필요하게 스위칭하지 않게 할 수 있다. 

```
스위칭 되는 반복문을 작성
for(){
	if(condition1){
		...
	} else if(){
		...
	}
}
```

condition1 조건이 항상 같다면, 굳이 반복문 안에서 테스트를 할 필요가 없다. 

```
스위칭 해제한 반복문
if(condition1){
	for(){}
} else if(condition2){
	for(){}
}
```

사실 이 코드는 여러가지 좋은 프로그래밍 규칙을 위반한다. 가독성과 유지보수 편의성이 더 중요한데, 성능을 위해서 다른 규친과 트레이드 오프를 하고 있다. 게다가 비주얼 베이직에서는 이런 튜닝후 눈에 띄는 성능향상이 없었다. **따라서 어떠한 최적화는 효과를 확인하려면 반드시 측정을 해야 한다.**

### 결합(fusion)

같은 요소의 집합을 다루는 두 개의 반복문을 결한한 결과다. 두개의 반복문을 하나로 줄임으로써 반복문의 반복횟루를 줄일 수 있다. 

### 코드 풀어쓰기

반복문을 쓰는 이유는 코드의 양을 줄이기 위한것이였다. 완전히 풀어쓰는것이 성능에는 도움이 되지만 코드의 품질과 유지보수가 어려워진다. 또 언어에 따라 튜닝이 될수도 있고 아닐 수도 있기 때문에 꼭 튜닝후 측정을 해라. 

### 반복문 내부 작업 최소화

성능을 높이려면 반복문 내부에서 처리되는 작업을 최소화해야한다. 

### 감시값

반복문에서 복합적인 테스트를 수행할때는 내부의 테스트를 단순화함으로써 시간을 절약 할수 있다. 반복문이 검색을 위해서라면 단순화하는 한 방법은 검색 범위의 끝을 지났을때 검색이 종료되게 하려고 입력하는 값인 감시값을 사용하는것이다. 


```
found = false;
i = 0;
while(found == false && i < count){
	if(item[i]==testValue){
		found = true;
	} else {
		i++;
	}
}

if(found){	
	...
}
```

이 코드에서 found를 찾기 위해 모든 요소를 검색한다. 사실 찾기만 하면 for문을 더이상 돌필요가 없다. 

```
i = 0;
while(item[i] != testValue){
	i++
}

if(i < count){\
	...
}
```

이 방법은 어떤언어에서도 효과가 있다. 

### 가장 빈번하게 실행되는 반복문을 안쪽에 작성한다.

중첩된 반복문이 있을때 어떤 반복문을 안쪽에 넣고 어떤 반복문을 바깥에 둘리 생각해본다. 

```
for(col = 0; col < 100; col++){
	for(row = 0; row < 5; row ++){
		...
	}
}
```
문제는 바깥쪽에 있는 반복문이 안쪽에 있는 반복문보다 더 자주 실행된다는 것이다. 반복문이 실행될때 마다 반복문 인덱스를 초기화하고 인덱스를 증가시키고 반복하고 난 다음에는 인덱스 값을 검사해야한다. 

바깥쪽에 있는 전체 실행횟수가 100이고 안쪽 반복문의 실행회수가 500이라 전체적으로 600번 반복한다. 단순히 안쪽과 바깥쪽을 바꾸는 것만으로 바깥 실행회수는 5번 안쪽은 500번이 되어 전체적으로 505번이 된다. 

### 연산 줄이기

연산 줄이기는 곱셈과 같이 오래걸리는 연산을 덧셈과 같이 적게 걸리는 연산으로 대체하는 것을 의미한다. 일반적으로 덧셈이 곳셈보다 빠르고 곳셈대신 그만큼은 반복해 더하면 같은 코드가 더 빠르게 실행될 것이다. 

## 26.3 데이터 변환

데이터형의 변화는 프로그램의 크기를 줄이고실행속도 향상에 도움이 된다. 데이터 형의 구현을 적당히 변경해도 성능 향상이 가능하다. 

### 부동 소수점 수 대신 정수를 사용하라.

정수의 덧셈과 곱셈은 부동 소수점의 덧셈과 곳셈보다 빠른 경향이 있다. 

### 가능한 가장 적은 차수의 배열을 사용하라

다차원 배열은 느리다는게 일반적인 통념이다. 2차원이나 3차원 배열 대신 1차원 배열로 구성하면 어느정도 시간을 절약할수있을것이다. 

하지만 최적화 결과에서 C++이나 C#을 제외하고는 모두 개선되었다. 즉 맹목적인 통념을 따르는게 얼마나 위험한지 보여준다. 개발환경에서 직접 확인하기 전에 튜닝의 성능이 좋을것이라고 확신해서는 안된다.

### 배열에 대한 참조를 최소화 하라

사실 배열에 대한 접근 자체를 최소화하는것이 좋다.

``` 
//discount[type]이 계속해서 호출된다.
for(type =0; type < typeCount; type++ ){
	for(level = 0; level < levelCount; count++){
		result[level] = result[level]+discount[type]
	}
}
```

``` 
//discount[type]을 필요할때 호출한다.
for(type =0; type < typeCount; type++ ){
	disCountType = discount[type];
	for(level = 0; level < levelCount; count++){
		result[level] = result[level]+disCountType
	}
}
```

### 보조 인덱스를 사용하라

보조 인덱스는 데이터형에 더 효율적으로 접근하기 위해 추가하는 데이터다. 관련 데이터는 주 데이터형에 추가하거나 병렬구조에 저장할 수 있다. 

* 문자열 길이 인덱스
	* 문자열 길이를 저장하는 바이트를 따로 저장하자. 그러면 특정 연산 수행시 처음부터 일일이 문자열을 읽을 필요가 없다.
* 독립적인 병렬 인덱스 구조
	* 때로는 저장되어 있는 데이터 자체를 이동시키기 어렵다면 데이터에 인덱스를 주어 정렬하고 검색하는 것이 빠르다.
* 캐싱을 사용하라
	* 일반적으로 새로운 요소를 생성하는데 비용이 비싸고 같은 정보를 호출하는 횟수가 많을 수록, 캐시된 요소에 접근하기 쉽고 저장하는 비용이 저렴할 수록 좋다. 

## 26.4 표현식

프로그램의 상당 부분은 수학적, 논리적 표현식으로 처리된다. 복잡한 표현식은 비싼 경향이 있어 싸게 만드는 법을 알아 보자.

### 대수 항등식을 사용하라

not A and not B = not(A or B) // 드모르간의 법칙 
not 연산을 하나 줄일수 있다. 

Math.sqrt(x) < Math.sqrt(y) <=> x < y  
Math.sqrt 비용을 절약할 수 있다.	

### 연산 줄이기

* 곱셈을 덧셈으로 대체
* 거듭제곱을 곳셈으로 대체
* longlong -> long이나 int로 대체
* 부동 소수점 수를 고정 소수점 수나 정수로 대체
* 배정도 부동 소수점을 단정도 부동 소수점 수로 대체
* 정수에 2를 곱하거나 2를 나누는 계산은 시프트 연산으로 대체

### 컴파일 시간에 초기화하라

루틴 호출 전에 상수나 매직 넘버를 사용하면 성능을 계선할 수 있다. 
```
unsigned int Log2(unsigned int x){
	return (unsigned int) (log(x) / log(2));
}
```

여기서 사용되는 log(2) 값은 절대로 변하지 않기 때문에 상수로 두면 좋다

```
const double LOG2 = 069314718;
```

### 시스템 루틴을 주의하라.

시스템 루틴은 비싸고 종종 쓸데 없이 정확하다. 앞 예제에서 log2()루틴은 정수값을 리턴하지만 이것을 계산하는데  부동 소수짐 log()루틴을 사용했다. 이것이 너무 지나친 계산일때가 있다. 

```
unsigned int Log2(unsigned int x){
	if(x<2) return 0;
	if(x<4) return 1;
	if(x<8) return 2;
	if(x<16) return 3;
	...
}
```
위와 같이 사용하면 절대로 부동 소수점을 변환하지 않고 성능이 뛰어나다. 

소위 초월함수로 불리는 대부분 함수는 최악의 경우를 대비해 설계되어 정확성을 위해 성능이 느리다. 정확성이 필요 없고 성능을 생각한다면 위의 루틴을 피하도록 하자

또 다른 방법으로 오른쪽 시프트 연산이 2로 나누는 것과 같다는 사실을 이용하는 것이다. 
```
unsigned int Log2(unsigned int x){
	unsigned int i = 0;
	while( ( x = ( x >> 1 ) ) != 0){
		i++;
	}
	return i;
	...
}
```
시프트 연산을 잘 모르면 매우 읽기가 힘들다. while조건안에 있는 복잡한 표현식은 타당한 이유가 없다면 반드시 피해야 한다. 

### 상수의 정확한 타입을 사용하라 





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjM4NjM4MTg0LC0xOTk0OTAwMDY4LDk1Mz
EyMDM1MywtMTYxOTMxNTM4NCwxODY3NTIyMDYsLTQ1OTM0NTQz
MywtMTg0MDc1MzI3NywxMDQ5ODY3MTcwLC00OTE0Mzc4NDAsOT
k1MjQ5MTAsLTEwMTE5NTQ1OTcsLTE4MzY3NzA4MzYsMzAyOTYw
NjMxLC0xNjYyNTI0NDYzLDE3Mzk5NTA2Myw0NjAwMjE5MDUsLT
E2Mzk3MzI1NzksMzk4NDY1MjI3LDIwNTc5NzAyMDMsMTIxODM0
NzcyMF19
-->