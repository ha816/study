# 7장 루틴

루틴(routine): 한 가지 목적만을 위해서 호출할 수 있는 개별 메서드나 프로시저를 말한다. 예를 들면, 자바에서는 메서드, C++에서는 함수. 루틴은 공간을 절약하고 성능을 향상하기 위해 가장 훌륭한 기법이다.  이번 장에서는 좋은 루틴과 나쁜 루틴을 만드는 특성을 공부한다.

## 7.1 루틴을 작성하는 이유

* 프로그램의 복잡성을 줄인다.
	* 구체적인 루틴의 내부 구현사항에 신경 쓰지않고 루틴 사용이 가능.	
* 이해하기 쉬운 중간 단계의 추상화 도입
	* 코드의 일부를 이해하기 쉬운 이름의 다른 루틴으로 만든다. 
* 중복코드를 피한다. 
	* 중복되는 코드를 더 일반화된 형태로 변경하여 코드 공간을 절약하고 변경도 쉽게 한다. 또한 한 코드만 검사하면 되므로 더 신뢰할 수 있다. 
* 서브클래싱을 지원한다.
	* 구조적으로 완성도가 높은 루틴을 오버라이드 하면 변경할 내용이 적다. 
* 코드의 실행순서를 감춘다. 
	* 이벤트가 처리되는 순서를 숨기는 것이 좋다. 
* 이식석을 높인다.
	* 루틴을 사용하면 미래에 이식이 가능한 기능과 그렇지 않은 기능을 구분할 수 있다. 
* 복잡한 불린 테스트를 단순화한다. 
* * 프로그램의 흐름을 이애하기 위해서 복잡한 불린 테스트를 상세하게 이해할 필요 없다. 그러한 테스트를 함수로 작성하면 코드를 이해하기가 쉽다.

## 루틴으로 작성하기에는 너무 단순해 보이는 연산

효과적인 루틴을 작성할때 주저하는 상황 : 간단한 작업을 처리하는 단순한 루틴을 만들때 경험상 작은 루틴도 매우 유용하다. 

길이가 짧은 루틴의 장점 
* 가독성 향상
* 단순한 작업이 점차 복잡한 작업이 되는 경향이 있기 때문에 

# 7.2 루틴 수준의 설계

응집성이란? 

사실 추상화나 캡슐화 같은 개념은 클래스 수준에서 고려해야 할 사항이고 개별적인 루틴 수준에서는 응집성이라는 개념을 잣대로 활용 가능하다. 

루틴에서의 응집성은 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다. 

루틴은 한가질 목적을 잘 처리하도록 만드는 것이지 여러가지 일을 처리하는데는 적합하지 않다. 즉 한가지 목적만을 위한 연산이 밀접하게 모여 있을때 응집성이 높다고 한다. 

응집성의 종류 

기능적 응집성 : 루틴이 오직 하나의 연산만 처리하는 경우처럼 가장 강하고 바람지갛ㄴ 응집성이다. 예로는 sin(), getCustomerName()등이다. 이름에서 설명하고 있는 기능을 처리할때만 ㅇ응집성이 높다라고 한다. 

순차적 응집성 : 루틴이 특정한 순서대로 수행되어야 하고 단계마다 정보를 공유하며 동시에 수행될때 완전히 기능을 제공하지 못하는 연산을 포함할때 존재한다. 즉 계산시 앞의 계산을 통해서 뒷 계산이 된다. 

통신적 응집성 : 루틴이 있는 연산들이 같은 데이터를 사용하지만, 서로 아무런 연관성이 없을때 생긴다. 

시간적 응집성 : 여러 연산이 동시에 수행되어야해서 하나의 루틴으로 결합할때 발쌩. 

지양해야 하는 응집성

* 절차적 응집성 : 루틴에 있는 연산들을 순서대로 처리할때 발생한다. 이 기능은 순차적으로 처리하는 것 외에는 결합할 필요가 없기 때문에 독립적인 기능을 별도의 루틴에 구현한다. 즉 온전한 하나의 기능으로 나눈다. 
* 
* 논리적 응집성 : 여러가지 기능을 한 루티네서 수행할때 루틴에 전달되는 조건에 따라 수행하는 기능이 다른 경우 발생. 논리적 흐름에 따라 각 기능을 처리한다고 해서 논리적 응집성 이라고 한다. 각 기능이 논리적으로 서로 연관이 있기 때문이 아니다. 작업이 서로 연관이 없다는 점을 고려하면 비논리적 응집성이라고 말하는게 낫다. 

일반적으로 루틴의 유일한 기능이 if 문에 의해서 정해진 명령을 처리하는 것일 뿐이라면 좋은 설계이다. 이러한 종류의 루틴 기술을 이벤트 핸들러라고도 한다. 

## 7.3 좋은 루틴 이름

### 루틴이 하는 모든것을 표현하라. 

루틴 이름에 모든 출력과 부수적인 효과를 설명해라. 
만약 전체보고서를 계산하고 출력 파일을 여는 루틴을 만들었다면...
* ComputeReportTotals()
* ComputeReportTotalsAndOpenOutputFile(): 자세히 하는 역활을 전부 표현했지만, 너무 길고 우스꽝스러운 이름이다. 더 나은 이름을 갖기위해 노력하는 대신 루틴이 가급적 부수적 영향을 갖지 않도록 코드를 수정해서 루틴의 역할을 좀더 분명하게 하자.

### 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 마라. 

어떤 동사는 너무 포괄적이고 유연해서 많은 뜻을 포함한다.
Handle, Perform, output, process, dealWith 등등 이런 루틴이름은 루틴이 무슨일을 하는 구체적으로 알려주지 않는다. 

어떤 경우는 루틴이 처리하는 연산 자체가 모호해서 동사도 모호하게 사요아기도 한다. 원래 루틴의 목적이 불분명하다는 점이 원인이고 그런 경우라면 루틴을 고쳐 모든 루틴이 분명한 목적을 갖도록 고치고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하는 것이 가장 좋은 해결책이다. 

### 루틴 이름을 숫자만으로 구분하지 말라.

연구하면 적절한 길이는 문자로 9자에서 15자 사이다. 루틴이 하는일은 변수보다 복잡하기 때문에 이롬도 더 복잡하고 길다. 한편 루틴이 특정 객체와 연관된 작업을 처리할 경우에는 객체 이름까지 들어가야 한다. 전반적으로 이름은 명료함에 초점을 맞춰야 하고, 따라서 이름의 길이 제약을 받지 않고 이해하기 쉽게 이름을 지어야 한다. 

### 함수 이름을 지을때는 리턴 값에 관해서 설명해라

기능적 응집성을 갖는 프로시저는 일반적으로 하나의 객체에 대해서 한 가지 연산을 수행한다. 프로시저 이름은 프로시저가 무슨일을 하는지 반영해야 하기 대문에 객체에 대한 연산은 동사에 객체 이름을 붙여 쓴 형태의 이름을 갖는다. 

### 반의어를 정확하게 사용하라 

반의어에 대한 이름 규약을 사용하면 일관성을 유지하는데 도움을 주고 이해하기가 쉽다. 

* add <-> remove
* begin <-> end
* start <-> stop
* create <-> destory
* get <-> put, set
* next <-> previous
* source <-> target

## 7.4 루틴 길이에 대한 문제

한 루틴의 길이에 대한 수많은 연구가 진행되었고 몇몇은 오늘날에도 맞지만 맞지 않는것도 있다.

* IBM 한 연구에서는 500줄보다 큰 루틴이면 오류율이 비례하는 경향이 잇었다. 
* 바실리와 페리콘이 진행한 연구에서는 루틴의 크기와 오류가  반비례 관계를 갖는다는 것을 발견했다. 즉 루틴의 길이가 길어질수록 최대 200줄 한 줄당 오류의 수는 감소한다. 

객체지향 프로그램에서 많은 부분을 차지하는 루틴은 접근자 루틴이며 이 루틴은 매우 짧다. 때때로 복잡한 알고리즘으로 인해 긴 루틴이 만들어지기도 하는데, 그러한 환경에서는 루틴의 길이를 100줄에서 200줄까지 유지적으로 커지도로 허용해야 한다. 

결과적으로 200줄 이상의 긴 루틴을 작성하고자 할때는 주의해야 한다. 
200줄 이상의 큰 루틴에서 비용이 절감된다거나 오류 발생률이 감소한다거나, 또는 두 가지 경우가 모두 생긴다고 밝혀진 연구는 없었고 코드가 200줄 이상 넘어가면 이해하기도 쉽지 않다. 


## 7.5 루틴 매개변수 처리

바실리와 페리콘이 수행한 연구에서는 전체 오류의 39%가 내부 인터페이스 오유 즉, 루틴끼리 서로 호출할때 발생하는 오류였다. 다음은 인터페이스 문제를 초소화하는 몇 가지 지침이다. 

### 매개변수를 입력-수정-출력 순서로 입력한다.

매개변수를 무작위나 알파벳 순으로 정렬하는 대신에 입력만 가능한것을 첫번째로, 입출력이 가능한것을 두번째로, 마지막으로 출력만 가능한 것을 세번째로 나열한다. 

### 유사한 매개변수가 여러 루틴에서 사용된다면 해당 매개변수를 항상 같은 순서로 입력한다. 

### 모든 매개변수를 사용한다.

루틴에 매개변수를 전달하면 매개변수를 반드시 사용해야 한다. 사용하지 않는다면 루틴 인터페이스에서 매개변수를 제거한다. 사실 당연한 이야기다. 

### 루틴의 매개변수를 연산을 위한 변수로 사용하지 않는다.

매개변수를 연산을 위한 지역변수처럼 사용하지 않아야 한다. 

### 매개변수에 대한 제약사항을 주석으로 작성한다. 

루틴에서 입력받는 데이터가 특정한 조건을 만족해야 한다면 그러한 제약사항에 관해서 설명해야 한다. 막상 루틴을 작성하고 나면 애초에 생각했던 제약사항이 생각나지 않을수도 잇기 때문에 루틴을 완성할때까지 기다리지말고 처음 루틴을 개발할때 주석을 작성해야 한다. 

매개변수를 주석으로 작성해야 할것

* 매개변수가 입력을 위한것인지, 변경되는지 값을 반환하기 위한것인지 내용
* 숫자 매개변수의 단위
* 열거형이 아닌 경우 상태코드와 오류값 의미
* 값읨 범위
* 절대로 가질 수 없는 값

### 루틴 매개변수의 수를 7개 정도로 제한한다.

일반적으로 연구에 따르면 7개 이상의 정보 묶음을 추적할수 없다고 한다. 이러한 발견이 여러 규칙에 적용되었고 같은 논리로  7개 이상의 매개변수를 지양하는 것이 좋다. 

### 루틴이 인터페이스 추상화를 유지하도록 변수나 객체를 전달한다.

## 7.6 함수를 사용할때특별히 고려할 사항

C++, 자바, 비주얼 베이직과 같은 언어는 함수와 프로시저를 모두 지원한다. 

함수는 값을 반환하고 프로시저는 아무 값도 반환하지 않는 루틴이다. 
C++에서는 일반적으로 모든 루틴을 함수라고 부르지만, 사실 void 리턴형을 갖는 함수는 의미론적으로 프로시저이다. 
일차적인 목적이 함수의 이름에서 가리키고 있는 값을 반환하는 것이라면 함수를 사용하고 그렇지 않다면 프로시저를 사용해라.

# 8장 방어적 프로그래밍

방어적 프로그래밍은 코드 작성에 대해 방어적인 태도를 보이라는 의미가 아니다. 그 보다는 안정적으로 운전하는 습관에 가깝다. 

방어적 프로그래밍에서 가장 중요한 개념은 설령 다른 루틴의 잘못으로 인한 거싱라도 루틴에 잘못된 데이터가 들어왓을때 루틴에 아무런 문제가 발생하지 않도록 하는데 잇다. 

타당하지 않은 데이터와 절대로 발생할 수 없는 이벤트, 다른 개발자의 실수로부터 자신을 보호하기 위한 방법을 설명한다. 

## 8.1 잘못된 입력으로부터 프로그램 보호

쓰레기를 넣으면 쓰레가 나온다.(Garbage in, garbage out)

### 외부로부터 들어오는 모든 데이터의 값이 검사

파일이나 사용자, 네트워크, 그 밖의 다른 인터페이스로부터 데이터 받을때 허용가능한 범위에 있는지 검사를 해라. 

숫자값은 허용 범위 내
문자열은 길이 또는 제한된 값


### 루틴의 모든 입력 매개변수를 검사
사실 8.5절 오류로 인한 손상을 막기위한 방책에서 입력검사는 해야하는 루틴이 어느것인지 결정하기 위한 실용적인 방법을 제공

### 잘못된 이별긍 ㄹ어떻게 처리할 것인지를 결정하라

유효하지 않은매개변수를 어떻게 처리해야 할가? 8.3절에서 자세히 소개 한다. 

## 8.2 어설션

어설션은 대개 루틴이나 매크로 실행시 프로그램이 스스로 검사할수 있도록 사용하는 코드다.
어설션이 참이면 모든것이 잘 동작하고 있다는 것을 의미한다.  어셜션이 거짓일때는 코드에서 예상치 못한 오류가 발생했다는 의미다.

어설션은 일반적으로 두개 인자를 갖는다. 

```
assert denominator != 0 : "unexpected error";
```
첫번째 인자는   denominator != 0이고 두번째 인자는 첫번째 인자가 거짓일때 출력하는 메세지이다. 

일반적으로 배포되는 코드에서는 어설션 메세지를 사용자에게 보여주지 않는다. 어설션은 주로 개발과 유지보수에 사용되며, 개발버전에서는 코드에 포함되지만 제품에서는 제외된다. 

### 어설션 사용지침

발생이 예상되는 상황에서는 오류 처리 코드를 사용하되, 절대로 발생해서는 안되는 조건에 대해서는 어설션을 사용하라. 

다시 강조하지만 어설션은 절대로 발생해서는 안되는 조건을 검사한다. 
오류 처리 코드로 비정상적인 조건을 처리하면 프로그램이 매끄럽게 상황을 처리할 것이다. 어설션을 통해 비정상적인 조건을 처리하면 프로그램이 강제로 충돌하게 되어 문제를 해결하기 위해 버그를 해결하고 새로운 버전을 배포해야 한다. 

### 선행 조건과 후행조건을 문서화하고 검증하는데 어설션을 사용하라. 

선행조건은 루틴이나 클래스에서 다른 루틴을 호출하거나 객체를 생성하기 전에 반드시 참이어야 하는 특성이다. 선행 조건은 루틴을 호출하는 쪽에서 반드시 지켜야 한다

후행조건은 루틴이나 클래스 호출후 반드시 참이어야 하는 조건이다. 후행 조건은 호출된 코드나 클래스가 지켜야 하는 약속이다. 

## 8.3 오류 처리 기법

어설션은 절대 발생해서는 안될 오류를 처리하는데 사용한다. 그렇다면 발생할 것이 예상되는 오류는 어떻게 처리할까?

### 중립적인 값을 반환한다. 
### 다음에 오는 유효한 데이터로 대체한다. 

## 8.4 예외

예외는 코드가 오류나 예외적인 이벤트를 루틴을 호출한 코드에 전달할 수 있는 특수한 방법이다. 오류가 발생한 상황을 전혀 인식하지 못하는 코드는 오류를 해석하고 오류에 뭔가 도움이 되는 것을 처리할 능력이 있는 시스템의 다른 영역에 제어를 넘긴다. 

흔히 try -catch 구문을 많이 쓰는데 아래 try-cat의 차이점을 요약했다. 

|특성| C++| 자바| 비주얼베이직|
|--|--|--|--|
|finally지원|아니오|예|예|
|던질수있는것|Exception 객체나 파생 객체, 객체 포인터, 객체 참조|Excetpion 객체나 파생객체|Excetpion 객체나 파생객체|
|잡히지 않은 예외의 효과|std::undexpected를 호출하고 ...|예외가 검사 예외라면 실행 스레드를 중단하고 런타임예외라면 아무작업도 하지 않는다.|프로그램을 중단한다.|

### 예외를 사용해 무시되어서는 안되응 오류는 프로그램의 다른부분에 알린다. 

### 정말로 예외적진 조건인 경우에만 예외를 던져라.

기본적으로 예외는 호출 코드 내부에서 어떤 예외를 던질지 알아야 함으로 복잡성을 증가시킨다. 

### 책임을 전가하기 위해서 예외를 사용하지 않는다. 

오류를 발생한 코드에서 처리할 수 있다면 직접 처리하는 게 좋다. 오류를 처리할 수 있는데도 처리되지 않는 예외를 던지지 않도록 한다. 

### 생성자와 소멸자에서 예외를 잡을 수 없다면 생성자와 소멸자에서 예외를 던지지 않는다. 

예외를 처리하는 방법을 정할 때 예외를 생성자와 소멸자에서 발생시킬 수 있다고 가정하면 코드가 매우 복잡해진다. 예를 들면 C++에서 소멸자는 객체가 완전히 생성 되기 전에는 호출되지 않는다. 이 말은 생성자에서 예외를 던진다면 소멸자가 호출되지 않기 때문에 리소스 누수가 있다는 것을 의미한다. 

### 올바른 추상화 수준에서 오류를 던진다. 

좋은 예제
``` class Employee {
	public taxId getTexId() throws EOFException 
}
```
호출한 쪽에서 저수준의 EOFException 예외를 전달한다. 저수준 예외를 호출한 쪽에 전달함으로써 루틴이 어떻게 구현되었는지 사항을 노출한다. 이렇게 하면 클라이언트 코드는 Employee 클래수 수준에서 이해하는게 아니라 EOFException 예외를 던지는 Employee 클래스의 세부적인 루틴을 이해하도록 한다. 

나쁜 예제
``` class Employee {
	public taxId getTexId() throws EmployeeDataNotAvailable
}
```
위의 클래스는 자신이 속한 클래스와 일관성을 유지하는 예외를 던진다. 

### 예외를 발생시킨 모든 정보를 예외 메세지에 포함한다.

모든 예외는 코드가 예외를 던질때 감지된 특정한 환경에서 발견한다. 이러한 정보는 예외가 발생한 이류를 이해하는데 매우 중요하다.

### 비어 있는 catch 블록을 피한다. 

## 8.5 오류로 인한 손해를 막기 위한 방책

오늘날에는 일반적으로 악의적인 네트워크 트래픽을 차단하는 것에 방화벽이라고 한다. 

일반적 요청(여기 있는 데이터는 신뢰할수 없고 불결한 것으로 여겨짐)
 -> 유효성 검증 클래스(데이터를 정리하는 역할을 하는 바리게이트) -> 내부 클래스(데이터를 신뢰할수 있다고 간주하고 작업)

# 9장 의사코드 프로그래밍 프로세스

이장에선 루틴과 클래스를 구현하기 위한 단계를 소개한다.
또한 설계와 문서 작성시 해야하는 작업을 줄이고 품질을 향상 시키는 의사코드 프로그래밍 프로세스(PPP)에 대해서 설명한다. 

## 요점 정리

* 클래스와 루틴의 구현은 반복적인 경향이 있다. 루틴을 구현하면서 얻는 내용이 클래스 설계에 영향을 미치는 경향이 있다.
* 훌륭한 의사코드를 위해선 이해할수있는 자연어를 쓰고 특정 프로그래밍 언어에 특화된 기능을 사용하지 말고 의도 수준에서 작성해야 한다.
* 첫 번째 설계를 최종 설계로 결정하지 않는다.


# 10장 변수 사용 시 고려할 사항

이 장에서는 건축으로 비유했을때 너트와 볼트 수준의 이슈에 해당하는 변수 사용에 대한 모든것을 설명한다. 

이 장에서 설명하는 변수는 정수나 배열과 같이 기본으로 제공되는 데이터 형 뿐만이 아니라 클래스로 부터 생성한 객체도 포함한다. 데이터형이라는 용어는 일반적으로 기본 제공되는 데이터 형을 말하지만 데이터 라는 단어는 객체나 기본 제공되는 타입 모두를 말한다. 

## 변수 선언을 쉽게 만드는 방법

암시적 선언: 어떤 언어는 암시적변수 선언을 지원한다. 비주얼 베이직에서 변수를 선언하지 않으면 컴파일러가 자동으로 변수를 선언한다. 사실 암시전 선언은 언어가 지원하는 가장 위험한 기능중 하나다. 따라서 암시적 기능을 사용하지 않도록 하자.

* 모든 변수를 선언한다.
* 이름 규칙을 정한다. 
	* Num이나 No같은 자주사용되는 접미사에 규칙을 세워 일관적으로 쓰자

## 변수 초기화 가이드 라인

부적절한 데이터 초기화는 프로그래밍에서 오류를 발생시키는 가장 빈도가 높다. 

부적절한 초기화는 아래 이유로 발생할 수 있다.

* 변수에 값을 할당한적이 없다. 프로그램 시작시 해당 메모리 공간에 원래 있던 비트값이 그대로 반영된것이다. 
* 변수에 있는 값이 더는 유효하지 않다.
* 변수 일부에는 값을 할당하고 나머지는 할당하지 않았다. 

그럼 부적절한 초기화를 피하는 가이드는 아래이다.
* 변수 선언시 초기화를 한다.
* 변수가 처음 사용되는 곳 가까에서 변수를 초기화 하고 정의한다.
* 가능하다면 final이나 const를 사용한다. 
* 카운터와 누산기를 특히 주의한다. 카운터나 누산기 재사용하기 전에 반드시 초기화 하자
* 컴파일러의 경고 메세지를 활용
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMTcyOTA4ODRdfQ==
-->