# 7장 고급 루틴

루틴 : 한 가지 목적만을 위해서 호출할 수 있는 개별 메서드나 프로시저를 말한다. 예를 들면, 자바에서는 메서드, C++에서는 함수
루틴은 공간을 절약하고 성능을 향상하기 위해 가장 훌륭한 기법이다.  이번 장에서는 좋은 루틴과 나쁜 루틴을 만드는 특성을 공부한다.

## 7.1 루틴을 작성하는 이유

* 프로그램의 복잡성을 줄인다.
	* 구체적인 루틴의 내부 구현사항에 신경 쓰지않고 루틴 사용이 가능.
	
* 이해하기 쉬운 중간 단계의 추상화 도입
	* 코드의 일부를 이해하기 쉬운 이름의 다른 루틴으로 만든다. 
* 중복코드를 피한다. 
	* 중복되는 코드를 더 일반화된 형태로 변경하여 코드 공간을 절약하고 변경도 쉽게 한다. 또한 한 코드만 검사하면 되므로 더 신뢰할 수 있다. 
* 서브클래싱을 지원한다.
	* 구조적으로 완성도가 높은 루틴을 오버라이드 하면 변경할 내용이 적다. 
* 코드의 실행순서를 감춘다. 
	* 이벤트가 처리되는 순서를 숨기는 것이 좋다. 
* 이식석을 높인다.
	* 루틴을 사용하면 미래에 이식이 가능한 기능과 그렇지 않은 기능을 구분할 수 있다. 
	* 복잡한 불린 테스트를 단순화한다. 
		* 프로그램의 흐름을 이애하기 위해서 복잡한 불린 테스트를 상세하게 이해할 필요 없다. 그러한 테스트를 함수로 작성하면 코드를 이해하기가 쉽다.

## 루틴으로 작성하기에는 너무 단순해 보이는 연산

효과적인 루틴을 작성할때 주저하는 상황 : 간단한 작업을 처리하는 단순한 루틴을 만들때 
경험상 작은 루틴도 매우 유용하다. 

길이가 짧은 루틴의 장점 
* 가독성 향상
* 단순한 작업이 점차 복잡한 작업이 되는 경향이 있기 때문에 

# 7.2 루틴 수준의 설계

응집성이란? 

사실 추상화나 캡슐화 같은 개념은 클래스 수준에서 고려해야 할 사항이고 개별적인 루틴 수준에서는 응집성이라는 개념을 잣대로 활용 가능하다. 

루틴에서의 응집성은 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다. 

루틴은 한가질 목적을 잘 처리하도록 만드는 것이지 여러가지 일을 처리하는데는 적합하지 않다. 즉 한가지 목적만을 위한 연산이 밀접하게 모여 있을때 응집성이 높다고 한다. 

응집성의 종류 

기능적 응집성 : 루틴이 오직 하나의 연산만 처리하는 경우처럼 가장 강하고 바람지갛ㄴ 응집성이다. 예로는 sin(), getCustomerName()등이다. 이름에서 설명하고 있는 기능을 처리할때만 ㅇ응집성이 높다라고 한다. 

순차적 응집성 : 루틴이 특정한 순서대로 수행되어야 하고 단계마다 정보를 공유하며 동시에 수행될때 완전히 기능을 제공하지 못하는 연산을 포함할때 존재한다. 즉 계산시 앞의 계산을 통해서 뒷 계산이 된다. 

통신적 응집성 : 루틴이 있는 연산들이 같은 데이터를 사용하지만, 서로 아무런 연관성이 없을때 생긴다. 

시간적 응집성 : 여러 연산이 동시에 수행되어야해서 하나의 루틴으로 결합할때 발쌩. 

지양해야 하는 응집성

* 절차적 응집성 : 루틴에 있는 연산들을 순서대로 처리할때 발생한다. 이 기능은 순차적으로 처리하는 것 외에는 결합할 필요가 없기 때문에 독립적인 기능을 별도의 루틴에 구현한다. 즉 온전한 하나의 기능으로 나눈다. 
* 
* 논리적 응집성 : 

## 7.3 좋은 루틴 이름





시간적 응지성








> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0NjA3MTcwNTIsMjA0MTU3Mzc5NywtNj
A0MDY3Mzk0LC02OTkxNjQxMDYsNzcwODM4MjY3LDE5Mzc2MDE4
NjIsLTMzOTUwNjgzOCw1NjI2NjE1NjgsNDMzNDIxNjk4LC0xOD
kwNDc0MDUzLC0yMTI2NDM5ODQ1LDYwMzMzNTQzMCwxMDU2MDA1
NzA4LC0xNDM0Mzc5NjI1LC0xMTc1NzQ1OTAwLDEzMjI1MDQwMj
UsLTgyNzg1NzY2NywtMTAzOTc4MDA3OF19
-->