# 7장 고급 루틴

루틴 : 한 가지 목적만을 위해서 호출할 수 있는 개별 메서드나 프로시저를 말한다. 예를 들면, 자바에서는 메서드, C++에서는 함수
루틴은 공간을 절약하고 성능을 향상하기 위해 가장 훌륭한 기법이다.  이번 장에서는 좋은 루틴과 나쁜 루틴을 만드는 특성을 공부한다.

## 7.1 루틴을 작성하는 이유

* 프로그램의 복잡성을 줄인다.
	* 구체적인 루틴의 내부 구현사항에 신경 쓰지않고 루틴 사용이 가능.
	
* 이해하기 쉬운 중간 단계의 추상화 도입
	* 코드의 일부를 이해하기 쉬운 이름의 다른 루틴으로 만든다. 
* 중복코드를 피한다. 
	* 중복되는 코드를 더 일반화된 형태로 변경하여 코드 공간을 절약하고 변경도 쉽게 한다. 또한 한 코드만 검사하면 되므로 더 신뢰할 수 있다. 
* 서브클래싱을 지원한다.
	* 구조적으로 완성도가 높은 루틴을 오버라이드 하면 변경할 내용이 적다. 
* 코드의 실행순서를 감춘다. 
	* 이벤트가 처리되는 순서를 숨기는 것이 좋다. 
* 이식석을 높인다.
	* 루틴을 사용하면 미래에 이식이 가능한 기능과 그렇지 않은 기능을 구분할 수 있다. 
	* 복잡한 불린 테스트를 단순화한다. 
		* 프로그램의 흐름을 이애하기 위해서 복잡한 불린 테스트를 상세하게 이해할 필요 없다. 그러한 테스트를 함수로 작성하면 코드를 이해하기가 쉽다.

## 루틴으로 작성하기에는 너무 단순해 보이는 연산

효과적인 루틴을 작성할때 주저하는 상황 : 간단한 작업을 처리하는 단순한 루틴을 만들때 
경험상 작은 루틴도 매우 유용하다. 

길이가 짧은 루틴의 장점 
* 가독성 향상
* 단순한 작업이 점차 복잡한 작업이 되는 경향이 있기 때문에 

# 7.2 루틴 수준의 설계

응집성이란? 

사실 추상화나 캡슐화 같은 개념은 클래스 수준에서 고려해야 할 사항이고 개별적인 루틴 수준에서는 응집성이라는 개념을 잣대로 활용 가능하다. 

루틴에서의 응집성은 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다. 

루틴은 한가질 목적을 잘 처리하도록 만드는 것이지 여러가지 일을 처리하는데는 적합하지 않다. 즉 한가지 목적만을 위한 연산이 밀접하게 모여 있을때 응집성이 높다고 한다. 

응집성의 종류 

기능적 응집성 : 루틴이 오직 하나의 연산만 처리하는 경우처럼 가장 강하고 바람지갛ㄴ 응집성이다. 예로는 sin(), getCustomerName()등이다. 이름에서 설명하고 있는 기능을 처리할때만 ㅇ응집성이 높다라고 한다. 

순차적 응집성 : 루틴이 특정한 순서대로 수행되어야 하고 단계마다 정보를 공유하며 동시에 수행될때 완전히 기능을 제공하지 못하는 연산을 포함할때 존재한다. 즉 계산시 앞의 계산을 통해서 뒷 계산이 된다. 

통신적 응집성 : 루틴이 있는 연산들이 같은 데이터를 사용하지만, 서로 아무런 연관성이 없을때 생긴다. 

시간적 응집성 : 여러 연산이 동시에 수행되어야해서 하나의 루틴으로 결합할때 발쌩. 

지양해야 하는 응집성

* 절차적 응집성 : 루틴에 있는 연산들을 순서대로 처리할때 발생한다. 이 기능은 순차적으로 처리하는 것 외에는 결합할 필요가 없기 때문에 독립적인 기능을 별도의 루틴에 구현한다. 즉 온전한 하나의 기능으로 나눈다. 
* 
* 논리적 응집성 : 여러가지 기능을 한 루티네서 수행할때 루틴에 전달되는 조건에 따라 수행하는 기능이 다른 경우 발생. 논리적 흐름에 따라 각 기능을 처리한다고 해서 논리적 응집성 이라고 한다. 각 기능이 논리적으로 서로 연관이 있기 때문이 아니다. 작업이 서로 연관이 없다는 점을 고려하면 비논리적 응집성이라고 말하는게 낫다. 

일반적으로 루틴의 유일한 기능이 if 문에 의해서 정해진 명령을 처리하는 것일 뿐이라면 좋은 설계이다. 이러한 종류의 루틴 기술을 이벤트 핸들러라고도 한다. 

## 7.3 좋은 루틴 이름

### 루틴이 하는 모든것을 표현하라. 

루틴 이름에 모든 출력과 부수적인 효과를 설명해라. 
만약 전체보고서를 계산하고 출력 파일을 여는 루틴을 만들었다면...
* ComputeReportTotals()
* ComputeReportTotalsAndOpenOutputFile(): 자세히 하는 역활을 전부 표현했지만, 너무 길고 우스꽝스러운 이름이다. 더 나은 이름을 갖기위해 노력하는 대신 루틴이 가급적 부수적 영향을 갖지 않도록 코드를 수정해서 루틴의 역할을 좀더 분명하게 하자.

### 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 마라. 

어떤 동사는 너무 포괄적이고 유연해서 많은 뜻을 포함한다.
Handle, Perform, output, process, dealWith 등등 이런 루틴이름은 루틴이 무슨일을 하는 구체적으로 알려주지 않는다. 

어떤 경우는 루틴이 처리하는 연산 자체가 모호해서 동사도 모호하게 사요아기도 한다. 원래 루틴의 목적이 불분명하다는 점이 원인이고 그런 경우라면 루틴을 고쳐 모든 루틴이 분명한 목적을 갖도록 고치고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하는 것이 가장 좋은 해결책이다. 

### 루틴 이름을 숫자만으로 구분하지 말라.

연구하면 적절한 길이는 문자로 9자에서 15자 사이다. 루틴이 하는일은 변수보다 복잡하기 때문에 이롬도 더 복잡하고 길다. 한편 루틴이 특정 객체와 연관된 작업을 처리할 경우에는 객체 이름까지 들어가야 한다. 전반적으로 이름은 명료함에 초점을 맞춰야 하고, 따라서 이름의 길이 제약을 받지 않고 이해하기 쉽게 이름을 지어야 한다. 

### 함수 이름을 지을때는 리턴 값에 관해서 설명해라

기능적 응집성을 갖는 프로시저는 일반적으로 하나의 객체에 대해서 한 가지 연산을 수행한다. 프로시저 이름은 프로시저가 무슨일을 하는지 반영해야 하기 대문에 객체에 대한 연산은 동사에 객체 이름을 붙여 쓴 형태의 이름을 갖는다. 

### 반의어를 정확하게 사용하라 

반의어에 대한 이름 규약을 사용하면 일관성을 유지하는데 도움을 주고 이해하기가 쉽다. 

* add <-> remove
* begin <-> end
* start <-> stop
* create <-> destory
* get <-> put, set
* next <-> previous
* source <-> target

## 7.4 루틴 길이에 대한 문제

한 루틴의 길이에 대한 수많은 연구가 진행되었고 몇몇은 오늘날에도 맞지만 맞지 않는것도 있다.

* IBM 한 연구에서는 500줄보다 큰 루틴이면 오류율이 비례하는 경향이 잇었다. 
* 바실리와 페리콘이 진행한 연구에서는 루틴의 











> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MTg5NDc5NzgsNDk0NjAzMjUzLC0xMD
QwMDMzNTcyLDEwMTM4ODE3NCwtMTYwNjQ1MjYxLDIwNzg0OTEz
OCwyOTk3OTIxMCwtMTIwODI1NjA2OCwtMTkwMDA3NTA0MCwyMD
QxNTczNzk3LC02MDQwNjczOTQsLTY5OTE2NDEwNiw3NzA4Mzgy
NjcsMTkzNzYwMTg2MiwtMzM5NTA2ODM4LDU2MjY2MTU2OCw0Mz
M0MjE2OTgsLTE4OTA0NzQwNTMsLTIxMjY0Mzk4NDUsNjAzMzM1
NDMwXX0=
-->