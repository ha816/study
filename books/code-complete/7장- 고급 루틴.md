# 7장 고급 루틴

루틴 : 한 가지 목적만을 위해서 호출할 수 있는 개별 메서드나 프로시저를 말한다. 예를 들면, 자바에서는 메서드, C++에서는 함수
루틴은 공간을 절약하고 성능을 향상하기 위해 가장 훌륭한 기법이다.  이번 장에서는 좋은 루틴과 나쁜 루틴을 만드는 특성을 공부한다.

## 7.1 루틴을 작성하는 이유

* 프로그램의 복잡성을 줄인다.
	* 구체적인 루틴의 내부 구현사항에 신경 쓰지않고 루틴 사용이 가능.
	
* 이해하기 쉬운 중간 단계의 추상화 도입
	* 코드의 일부를 이해하기 쉬운 이름의 다른 루틴으로 만든다. 
* 중복코드를 피한다. 
	* 중복되는 코드를 더 일반화된 형태로 변경하여 코드 공간을 절약하고 변경도 쉽게 한다. 또한 한 코드만 검사하면 되므로 더 신뢰할 수 있다. 
* 서브클래싱을 지원한다.
	* 구조적으로 완성도가 높은 루틴을 오버라이드 하면 변경할 내용이 적다. 
* 코드의 실행순서를 감춘다. 
	* 이벤트가 처리되는 순서를 숨기는 것이 좋다. 
* 이식석을 높인다.
	* 루틴을 사용하면 미래에 이식이 가능한 기능과 그렇지 않은 기능을 구분할 수 있다. 
	* 복잡한 불린 테스트를 단순화한다. 
		* 프로그램의 흐름을 이애하기 위해서 복잡한 불린 테스트를 상세하게 이해할 필요 없다. 그러한 테스트를 함수로 작성하면 코드를 이해하기가 쉽다.

## 루틴으로 작성하기에는 너무 단순해 보이는 연산

효과적인 루틴을 작성할때 주저하는 상황 : 간단한 작업을 처리하는 단순한 루틴을 만들때 
경험상 작은 루틴도 매우 유용하다. 

길이가 짧은 루틴의 장점 
* 가독성 향상
* 단순한 작업이 점차 복잡한 작업이 되는 경향이 있기 때문에 

# 7.2 루틴 수준의 설계

응집성이란? 

사실 추상화나 캡슐화 같은 개념은 클래스 수준에서 고려해야 할 사항이고 개별적인 루틴 수준에서는 응집성이라는 개념을 잣대로 활용 가능하다. 

루틴에서의 응집성은 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다. 

루틴은 한가질 목적을 잘 처리하도록 만드는 것이지 여러가지 일을 처리하는데는 적합하지 않다. 즉 한가지 목적만을 위한 연산이 밀접하게 모여 있을때 응집성이 높다고 한다. 

응집성의 종류 

기능적 응집성 : 루틴이 오직 하나의 연산만 처리하는 경우처럼 가장 강하고 바람지갛ㄴ 응집성이다. 예로는 sin(), getCustomerName()등이다. 이름에서 설명하고 있는 기능을 처리할때만 ㅇ응집성이 높다라고 한다. 

순차적 응집성 : 루틴이 특정한 순서대로 수행되어야 하고 단계마다 정보를 공유하며 동시에 수행될때 완전히 기능을 제공하지 못하는 연산을 포함할때 존재한다. 즉 계산시 앞의 계산을 통해서 뒷 계산이 된다. 

통신적 응집성 : 루틴이 있는 연산들이 같은 데이터를 사용하지만, 서로 아무런 연관성이 없을때 생긴다. 

시간적 응집성 : 여러 연산이 동시에 수행되어야해서 하나의 루틴으로 결합할때 발쌩. 

지양해야 하는 응집성

* 절차적 응집성 : 루틴에 있는 연산들을 순서대로 처리할때 발생한다. 이 기능은 순차적으로 처리하는 것 외에는 결합할 필요가 없기 때문에 독립적인 기능을 별도의 루틴에 구현한다. 즉 온전한 하나의 기능으로 나눈다. 
* 
* 논리적 응집성 : 여러가지 기능을 한 루티네서 수행할때 루틴에 전달되는 조건에 따라 수행하는 기능이 다른 경우 발생. 논리적 흐름에 따라 각 기능을 처리한다고 해서 논리적 응집성 이라고 한다. 각 기능이 논리적으로 서로 연관이 있기 때문이 아니다. 작업이 서로 연관이 없다는 점을 고려하면 비논리적 응집성이라고 말하는게 낫다. 

일반적으로 루틴의 유일한 기능이 if 문에 의해서 정해진 명령을 처리하는 것일 뿐이라면 좋은 설계이다. 이러한 종류의 루틴 기술을 이벤트 핸들러라고도 한다. 

## 7.3 좋은 루틴 이름

### 루틴이 하는 모든것을 표현하라. 

루틴 이름에 모든 출력과 부수적인 효과를 설명해라. 
만약 전체보고서를 계산하고 출력 파일을 여는 루틴을 만들었다면...
* ComputeReportTotals()
* ComputeReportTotalsAndOpenOutputFile(): 자세히 하는 역활을 전부 표현했지만, 너무 길고 우스꽝스러운 이름이다. 더 나은 이름을 갖기위해 노력하는 대신 루틴이 가급적 부수적 영향을 갖지 않도록 코드를 수정해서 루틴의 역할을 좀더 분명하게 하자.

### 의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 마라. 

어떤 동사는 너무 포괄적이고 유연해서 많은 뜻을 포함한다.
Handle, Perform, output, process, dealWith 등등 이런 루틴이름은 루틴이 무슨일을 하는 구체적으로 알려주지 않는다. 

어떤 경우는 루틴이 처리하는 연산 자체가 모호해서 동사도 모호하게 사요아기도 한다. 원래 루틴의 목적이 불분명하다는 점이 원인이고 그런 경우라면 루틴을 고쳐 모든 루틴이 분명한 목적을 갖도록 고치고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하는 것이 가장 좋은 해결책이다. 

### 루틴 이름을 숫자만으로 구분하지 말라.

연구하면 적절한 길이는 문자로 9자에서 15자 사이다. 루틴이 하는일은 변수보다 복잡하기 때문에 이롬도 더 복잡하고 길다. 한편 루틴이 특정 객체와 연관된 작업을 처리할 경우에는 객체 이름까지 들어가야 한다. 전반적으로 이름은 명료함에 초점을 맞춰야 하고, 따라서 이름의 길이 제약을 받지 않고 이해하기 쉽게 이름을 지어야 한다. 

### 함수 이름을 지을때는 리턴 값에 관해서 설명해라

기능적 응집성을 갖는 프로시저는 일반적으로 하나의 객체에 대해서 한 가지 연산을 수행한다. 프로시저 이름은 프로시저가 무슨일을 하는지 반영해야 하기 대문에 객체에 대한 연산은 동사에 객체 이름을 붙여 쓴 형태의 이름을 갖는다. 

### 반의어를 정확하게 사용하라 

반의어에 대한 이름 규약을 사용하면 일관성을 유지하는데 도움을 주고 이해하기가 쉽다. 

* add <-> remove
* begin <-> end
* start <-> stop
* create <-> destory
* get <-> put, set
* next <-> previous
* source <-> target

## 7.4 루틴 길이에 대한 문제

한 루틴의 길이에 대한 수많은 연구가 진행되었고 몇몇은 오늘날에도 맞지만 맞지 않는것도 있다.

* IBM 한 연구에서는 500줄보다 큰 루틴이면 오류율이 비례하는 경향이 잇었다. 
* 바실리와 페리콘이 진행한 연구에서는 루틴의 크기와 오류가  반비례 관계를 갖는다는 것을 발견했다. 즉 루틴의 길이가 길어질수록 최대 200줄 한 줄당 오류의 수는 감소한다. 

객체지향 프로그램에서 많은 부분을 차지하는 루틴은 접근자 루틴이며 이 루틴은 매우 짧다. 때때로 복잡한 알고리즘으로 인해 긴 루틴이 만들어지기도 하는데, 그러한 환경에서는 루틴의 길이를 100줄에서 200줄까지 유지적으로 커지도로 허용해야 한다. 

결과적으로 200줄 이상의 긴 루틴을 작성하고자 할때는 주의해야 한다. 
200줄 이상의 큰 루틴에서 비용이 절감된다거나 오류 발생률이 감소한다거나, 또는 두 가지 경우가 모두 생긴다고 밝혀진 연구는 없었고 코드가 200줄 이상 넘어가면 이해하기도 쉽지 않다. 


## 7.5 루틴 매개변수 처리

바실리와 페리콘이 수행한 연구에서는 전체 오류의 39%가 내부 인터페이스 오유 즉, 루틴끼리 서로 호출할때 발생하는 오류였다. 다음은 인터페이스 문제를 초소화하는 몇 가지 지침이다. 

### 매개변수를 입력-수정-출력 순서로 입력한다.

매개변수를 무작위나 알파벳 순으로 정렬하는 대신에 입력만 가능한것을 첫번째로, 입출력이 가능한것을 두번째로, 마지막으로 출력만 가능한 것을 세번째로 나열한다. 

### 유사한 매개변수가 여러 루틴에서 사용된다면 해당 매개변수를 항상 같은 순서로 입력한다. 

### 모든 매개변수를 사용한다.

루틴에 매개변수를 전달하면 매개변수를 반드시 사용해야 한다. 사용하지 않는다면 루틴 인터페이스에서 매개변수를 제거한다. 사실 당연한 이야기다. 

### 루틴의 매개변수를 연산을 위한 변수로 사용하지 않는다.

매개변수를 연산을 위한 지역변수처럼 사용하지 않아야 한다. 

### 매개변수에 대한 제약사항을 주석으로 작성한다. 

루틴에서 입력받는 데이터가 특정한 조건을 만족해야 한다면 그러한 제약사항에 관해서 설명해야 한다. 막상 루틴을 작성하고 나면 애초에 생각했던 제약사항이 생각나지 않을수도 잇기 때문에 루틴을 완성할때까지 기다리지말고 처음 루틴을 개발할때 주석을 작성해야 한다. 

매개변수를 주석으로 작성해야 할것

* 매개변수가 입력을 위한것인지, 변경되는지 값을 반환하기 위한것인지 내용
* 숫자 매개변수의 단위
* 열거형이 아닌 경우 상태코드와 오류값 의미
* 값읨 범위
* 절대로 가질 수 없는 값

### 루틴 매개변수의 수를 7개 정도로 제한한다.

일반적으로 연구에 따르면 7개 이상의 정보 묶음을 추적할수 없다고 한다. 이러한 발견이 여러 규칙에 적용되었고 같은 논리로  7개 이상의 매개변수를 지양하는 것이 좋다. 

### 루틴이 인터페이스 추상화를 유지하도록 변수나 객체를 전달한다.

무슨말인지 잘 모르겠네 

## 7.6 함수를 사용할때특별히 고려할 사항

C++, 자바, 비주얼 베이직과 같은 언어는 함수와 프로












> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzg5MTU5MDg5LDI1MDE3MjMyMiwxODkwOT
A3NTkwLDY5NzE1MjE5Miw2NzI0NDM3MzUsLTE2OTI5MjkwMjIs
LTM3NTU2Nzg4OCw0OTQ2MDMyNTMsLTEwNDAwMzM1NzIsMTAxMz
g4MTc0LC0xNjA2NDUyNjEsMjA3ODQ5MTM4LDI5OTc5MjEwLC0x
MjA4MjU2MDY4LC0xOTAwMDc1MDQwLDIwNDE1NzM3OTcsLTYwND
A2NzM5NCwtNjk5MTY0MTA2LDc3MDgzODI2NywxOTM3NjAxODYy
XX0=
-->