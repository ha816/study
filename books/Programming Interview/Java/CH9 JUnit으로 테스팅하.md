# JUnit으로 테스팅하기

테스트를 먼저 작성한 후 빌드 환경에 완벽하게 통합된 것을 확인했다면 테스트는 코드를 검사할 때나 출시용 버전을 빌드할 때처럼 빌드가 생성되었을때 항상 문제없이 작동할것이다. 그런데 알 수 없는 이유로 테스트에 문제가 발생한다면 새로 작성한 코드가 문제가 일어 났다는 것이고, 이를 회귀 라고 한다. 

> JUnit 테스트를 통해 얻는 가치는 무엇인가?

JUnit 테스트는 보통 TDD(Test-Driven Development)라는 개발 방법론에 기반을 둔다. 코드가 어떻게 작동하길 바라는지에 관한 예상이나 가정을 기반으로 짧은 실행을 반복하는 테스트를 만드는 절차다.

## JUnit 생명주기

> JUnit 테스트를 실행할때 어떤 일이 일어나는가? 

JUnit 테스트는 독립적이고 원자적이어야만 한다. 
 
@BeforeClass
: 이 어노테이션이 붙은 메서드는 public static이고 void 타입을 반환해야 한다. 클래스 (객체) 생성 전에 호출되므로 정적 메서드만 처리가 가능하다.

테스트 클래스의 인스턴스 생성. 모든 자바 클래스 처럼 매개변수가 없는 단일 생성자를 선언한다. 

@Before
:  객체 생성이 끝난 후에 이 어노테이션과 void 타입을 반환하는 모든 public 메서드가 실행된다. 대게 목(mock)객체나 상태를 갖는 객체처럼 모든 테스트에 공통으로 설정된다. 각 테스트 이전에 이 단계가 반복해서 수행하기 때문에 객체가 올바른 상태를 유지하는데 이용이 가능하다. 

테스트가 수행된다. @Test 어노테이션으로 정의된 테스트는 public이고 void타입이 반환된다. 

@After
: 테스트가 성공 또는 실패일 경우, 이 어노테이션이 붙은 메서드가 호출된다. 

@AfterClass
: 모든 테스트가 완료된 후에 실행 하는 메서드.


@Ignore 어노테이션을 선언한 모든 테스트 메서드는 무시된다. 일부 테스트를 이 어노테이션으로 선언하려면 정당한 이유가 있어야 한다. 왜 테스트를 무시하는지, 언제 어떻게 이 부분을 수정해야 하는지

> 테스트가 성공인지 실패인지 어떻게 증명하는가? 

JUnit 라이브러리의 핵심 클래스 중 하나는 Assert 클래스다. 이 클래스는 가정을 표현하는데 사용하는 많은 정적 메서드가 있다. 그리고 가정이 참이라는 것을 증명한다. 

* assertEquals 
* assertTrue
* assertNotNull
* assertArrayEquals

가정이 맞지 않으면 예외가 발생한다. 이미 예상 할 수 있는 예외가 아니라면 JUnit 테스트를 통과하지 못한다. 

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyMDE1MDg4NjEsLTEyMzkwOTQ0ODksLT
E1NDQ5MTU0MjUsLTE3NzU2NTI3MzQsMTk4NDkwMjM1Myw3MzA5
OTgxMTZdfQ==
-->