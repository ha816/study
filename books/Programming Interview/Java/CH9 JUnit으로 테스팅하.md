# JUnit으로 테스팅하기

테스트를 먼저 작성한 후 빌드 환경에 완벽하게 통합된 것을 확인했다면 테스트는 코드를 검사할 때나 출시용 버전을 빌드할 때처럼 빌드가 생성되었을때 항상 문제없이 작동할것이다. 그런데 알 수 없는 이유로 테스트에 문제가 발생한다면 새로 작성한 코드가 문제가 일어 났다는 것이고, 이를 회귀 라고 한다. 

> JUnit 테스트를 통해 얻는 가치는 무엇인가?

JUnit 테스트는 보통 TDD(Test-Driven Development)라는 개발 방법론에 기반을 둔다. 코드가 어떻게 작동하길 바라는지에 관한 예상이나 가정을 기반으로 짧은 실행을 반복하는 테스트를 만드는 절차다.

## JUnit 생명주기

> JUnit 테스트를 실행할때 어떤 일이 일어나는가? 

JUnit 테스트는 독립적이고 원자적이어야만 한다. 
 
@BeforeClass
: 이 어노테이션이 붙은 메서드는 public static이고 void 타입을 반환해야 한다. 클래스 (객체) 생성 전에 호출되므로 정적 메서드만 처리가 가능하다.

테스트 클래스의 인스턴스 생성. 모든 자바 클래스 처럼 매개변수가 없는 단일 생성자를 선언한다. 

@Before
:  객체 생성이 끝난 후에 이 어노테이션과 void 타입을 반환하는 모든 public 메서드가 실행된다. 대게 목(mock)객체나 상태를 갖는 객체처럼 모든 테스트에 공통으로 설정된다. 각 테스트 이전에 이 단계가 반복해서 수행하기 때문에 객체가 올바른 상태를 유지하는데 이용이 가능하다. 

테스트가 수행된다. @Test 어노테이션으로 정의된 테스트는 public이고 void타입이 반환된다. 

@After
: 테스트가 성공 또는 실패일 경우, 이 어노테이션이 붙은 메서드가 호출된다. 

@AfterClass
: 모든 테스트가 완료된 후에 실행 하는 메서드.


@Ignore 어노테이션을 선언한 모든 테스트 메서드는 무시된다. 일부 테스트를 이 어노테이션으로 선언하려면 정당한 이유가 있어야 한다. 왜 테스트를 무시하는지, 언제 어떻게 이 부분을 수정해야 하는지

> 테스트가 성공인지 실패인지 어떻게 증명하는가? 

JUnit 라이브러리의 핵심 클래스 중 하나는 Assert 클래스다. 이 클래스는 가정을 표현하는데 사용하는 많은 정적 메서드가 있다. 그리고 가정이 참이라는 것을 증명한다. 

* assertEquals 
* assertTrue
* assertNotNull
* assertArrayEquals

가정이 맞지 않으면 예외가 발생한다. 이미 예상 할 수 있는 예외가 아니라면 JUnit 테스트를 통과하지 못한다. 

> 어떻게 특정 예외를 예상할 수 있는가?

@Test 에노테이션의 매개변수는 이 테스트가 예외를 처리해야만 한다고 테스트 실행기에 알려준다. 
```
@Test(expected=NoSuchFileException.class)
```
매개변수로 Exception같은 예외를 하면 어떤 예외도 통과하기 때문에 대부분 하나의 예외를 정확하게 처리한다. 

>테스트가 예상시간 보다 오래 걸리면 테스트가 실패한것으로 취급하기

@Test애노테이션은 두개의 매개변수를 받을 수 있다. 하나는 expected 또 하나는 timeout이다. timeout의 매개변수는 long타입 값을 받고 밀리세컨드가 단위다. 이 정해진 시간보다 오래 걸리면 테스트가 실패한다.

>@RunWith 어노테이션은 어떻게 작동하는가?

@RunWith 어노테이션은 클래스 수준의 어노테이션으로 테스트 실행기의 기본동작을 변경할 수 있다. 이 매개변수는 Runner 클래스의 하위 클래스다. JUnit은 기본적으로 몇가지 실행기가 있고 일반적으로 Parameterized 클래스다.

JUnit 실행기는 Runner 추상 클래스의 실제 구현이다. 따라서 Runner 클래스를 직접 만들어 사용하는 것도 가능하다. 

## 목으로 의존성 제거하기

> 단위 테스트와 통합 테스트의 차이는 무엇인가?

사실 JUnit은 단위 테스트와 통합 테스트 모두에 사용 가능하여 JUnit(유닛)이라는 이름은 부적절할때가 있다. 
클래스를 외부의존성을 귾기 위해서는 의존성 주입(Depencency Injection)과 목 두가지를 사용할 수 있으며 둘 사이에는 협력 관계가 있다. 

mockito라는 자바 라이브러리인데 목은 매우 유연하다. 다른 라이브러리들은 단지 목 인터페이스만 구현하지만 Mockito 목은 목을 구체적으로 구현한다.






> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNTAyMTUxODksLTgzNDc4MjM2LC0xOT
M5MDk5MzM5LC0xMjM5MDk0NDg5LC0xNTQ0OTE1NDI1LC0xNzc1
NjUyNzM0LDE5ODQ5MDIzNTMsNzMwOTk4MTE2XX0=
-->