# 원시타입

> 몇 가지 자바 원시 타입의 이름을 말하고 이 타입이  JVM에서 어떻게 처리되는지 설명하라.

원시타입(primitive type)은 Null이 될수 없다. 즉 언제나 값을 가지는 상태다. 

int, long 원시타입은 숫자 값 뒤에 L을 붙이면 long이다.  안붙이면 자연스럽게 int이다. 비슷하게 float, double도 숫자값 뒤에 D를 붙이면 double, F를 붙이면 float이다.

원시 타입의 크기

| type| 크기(bit)  |
|--|--|
|boolean | 1bit |
|char | **16(2byte)** |
|short | 16(2byte) |
|int | 32(4byte) |
|long | 64(8byte) |
|float | 32(4byte) |
|double | 64(8byte) |

char는 unsigned이므로 0 ~ 65535 까지 담을수 있다. 

> 왜 Integer.MIN_VALUES에 대응하는 양수가 없는가?
> Integer값은 $2^{32}$가지의 값을 표현할수 있다. 그리고 signed이기 때문에 절반 만큼은 음수를 위해 써야한다.  그런데 0도 양수의 표현해야하기 때문에 $2^{31}-1$만큼은 양수로 나머지는 음수로 표현한다.

> 오토 박싱이란?

오토 박싱(Auto Boxing)은 원시 타입을 원시타입에 대응하는 참조 타입으로 자동 변경하는 것이다. 

자바 5이전에는 수동으로 원시 타입을 참조 타입으로 바꿧는데 이를 박싱(Boxing)이라고 한다. 반대로 언박싱(Unboxing)은 참조 타입을 대응하는 원시 타입으로 바꾼다. 

# 객체 이용하기

원시 타입을 제외하면 자바 언어의 모든 변수들은 참조 타입이다. 이것들은 객체로 원시타입과 차이점은 빈객체를 의미하는 null 표현이 존재한다는 것이다.

원시 타입은 값을 메모리에 그대로 저장한다. 그에 반해 참조 값은 객체가 할당된 메모리의 주소(위치)를 저장한다. 표면적으로 둘다 비슷하게 동작하는 것으로 보이지만 실제로는 그렇지 않다. 

> 자바에서는 배열을 어떻게 표현하는가?

중요한 점은 자바에서 배열을 객체로 취급한다는 것이다. 배열은 toString()을 호출할수 있고 다양한 방법으로 이용이 가능하다. 또 배열이 객체라는 의미는 참조로 전달될 수 있다는 뜻이다. 따라서 해당 객체는 참조하는 모든 것에 의해서 변경이 발생할 수 있다. 따라서 사용에 주의해야 한다. 

> final 키워드는 객체 참조에 어떤 영향을 미치는가?

객체에 선언하는 final 키워드는 원시타입에 선언하는 final 키워드와 동일하다. 즉 메모리 변수에 값이나 메모리 주소가 할당되면 그 값과 메모리 주소는 변하지 않는다. 변수에 할당된 메모리 주소는 변경하지 못하지만 객체 자체는 당연히 수정이 가능하다.

> 객체의 가시성 수정자(visibility modifier)는 어떻게 작동하는가? 

가시성 수정자는 객체의 정보은닉에 도움을 준다. 필드나 메서드, 중첩 클래스(nested class), 중첩 인터페이스(nested interface) 같은  멤버(필드, 메서드)의 접근 권한은 크게 4가지 종류가 있다. 

| 접근 권한 수정자 | 설명 |
|--|--|
|private| 선언된 멤버는 선언된 같은 클래스에서만 접근가능 |
|package-private| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능; 기본 접근 권한으로 알려져 있음 |
|protected| 선언된 멤버는 같은 패키지 안에 모든 클래스가 접근가능할 뿐만 아니라 (다른 패키지에서) 선언된 클래스를 확장하는 하위 클래스에서도 접근가능|
|public| 선언된 멤버는 어디서도 접근가능|

private의 일반적인 오해는 private으로 선언한 변수는 해당 인스턴스만 접근할 수 있다고 생각하는 것이다. 같은 인스턴스는 아니지만 같은 타입의 모든 인스턴스가 private 멤버 변수에 접근이 가능하다. 

> 메서드와 변수에 사용되는 static 키워드의 역할은 무엇인가?

static은 정적 변수와 메서드를 만드는데 사용하느 키워드이다. 정적이란 인스턴스가 생성되기 전에 이미 존재하는걸 의미하는데, 대개 특정 인스턴스 보다는 클래스 이름을 통해 정적 메서드와 정적 변수에 접근한다. 정적변수 또는 정적메서드는 그 클래스를 통틀어서 하나만 공통으로 사용한다.

> 다형성과 상속이란 무엇인가

다형성(polymorphism)과 상속은 객체 지향 개발의 두가지 핵심 개념이다. 
다형성은 하나의 클래스가 수많은 클래스가 되도록 한다.
상속은 부모클래스에서 행동과 정의를 가져와 사용할 수 있게 해준다. 이전 클래스의 행동과 정의를 가져와 새로운 행동을 추가하거나 기존 행동을 재정의(오버라이드)해서 사용이 가능하다. 

> 객체의 일부 메서드가 오버라이드되었을 때 어떻게 사용되는지 설명하라. 

JVM에서 실행되는 모든 클래스는 Object를 상속하므로 final 메서드를 제외한 public, protected 메서드는 오버라이드 할 수 있다. 

hashCode와 equals 메서드 관계에서 반드시 지켜야하는 규칙은 두 메서드 중 하나를 오버라이딩 할때 반드시 둘다 함께 오버라이드 해야한다. 왜냐하면 HashSet 같은 경우, equals 메서드가 구현되어 있지 않아서, 그냥 쓰면 객체 참조 값만 비교 한다. 

> @Override 애노테이션은 어떤 역할을 하는가? 

컴파일러에게 상위 클래스의 메서드가 오버라이드 되었다는 것을 알려주므로 컴파일 할때 유용하다. 일반적으로 메서드를 오버라이딩 할때 이 애노테이션으로 실수하지 않게 하는 용도로 쓰인다. 만약 상위 클래스에 일치하는 메서드 시그니처가 없으면 에러가 발생한다. 

# String 이용하기

>String은 메모리에 어떻게 저장되는가?

String 클래스는 자바 라이브러리에 간단히 저장된 클래스지만 매우 중요하고 광범위하게 사용된다. JVM과 컴파일러는 특정 상황에서 특별한 방법으로 String 객체를 처리한다. 

String 객체는 원시 타입처러 취급된다. String 리터털이 원시 타입처럼 취급되는 String 객체다. String 릴터럴을 생성 할때 new 키워드를 사용할 필요가 없다. 실제 컴파일할때 쌍따옴표로 표현된 String 리터럴은 모두 객체로 생성된다. 

> String 객체의 값을 변경할 수 있는가?

String 클래스에서 String 객체 값을 변경하는 것처럼 보이는 모든 메서드가 실제로는  String 인스턴스를 반환한다. 

**String 값은 절대 변하지 않으며 바꿀수 없다**

이러한 불변성은 많은 장점이 있다. 하나는 스레드에 안전하다는 것이다. 참고로 String 뿐만 아니라 Integer, Double, Charactrer, BigInteger와 같은 모든 숫자형 클래스도 불변형이다. 

> 인터닝이란 무엇인가?

String 리터럴은 실행할때 JVM이 특별히 관리를 한다. 클래스가 JVM에 로드되면 모든 리터럴이 상수 풀에 위치한다. 그리고 **String 리터럴의 모든 반복은 풀안의 같은 상수를 참조하는데 이를 String Interning(인터닝) 이라 한다.**

String 인턴 풀은 컴파일 할때 단지 String 리터럴을 가져오는게 아니라 intern메서드로 모든 String 인스턴스를 풀에 추가한다. intern메서드는 해제에는 사용할 수 없다. String이 힙에 저장되어 있지 않더라도 어딘가에 저장되어야 하는데, 저장 장소는 PermGem이다.

String 상수 풀은 플라이 웨이트 패턴을 구현한것으로 Integer.valueOf와 비슷하다. 

# 제네릭 이해하기

> 컬렉션 API에서 제네릭을 어떻게 사용하는지 설명하라. 

제네릭은 `매개변수화된 타입`이라고도 알려져 있다. 매개변수를 받는 타입? 컬렉션 클래스에서 제네릭을 사용했을때 컴파일러는 특정 타입만 포함될 수 있게 컬렉션을 제한한다. 

컬렉션 API에 있는 모든 클래스는 제네리릭을 사용해서 만들었다. List인터페이스와 그 구현은 한 가지 타입의 매개변수만 받는다. Map인터페이스는 두가지 타입 매개변수를 받는다. 

> 타입의 변화는 제네릭에 어떤 영향을 미치는가? 

클래스 B가 A를 확장하면 B는 A의 하위 타입이다. 하지만 `List<B>`는 `List<A>`의 하위 타입이 아니다. 공분산이라 알려진 자바의 제네릭 시스템이는 이에 관한 모델링 방법이 없다. 

제네릭 타입을 다룰때는 때때로 클래스의 하위타입을 받아들여야 하는 경우도 있다. 이럴때 `?`인 와이들 카드를 사용한다. 

예를들어 List<? extends A>는 컴파일러에게 A 클래스를 확장한 모든 인스턴스를 List원소로가지는 매개변수 타입이다.  

> 구상화한다는 건 어떤 의미인가? 

본래 구상화 (reified)는 것은 실행 시에 이용할 수 있다는 것이다. **기본적으로 자바의 제네릭 타입은 구상화가 아니다.** 왜냐하면 .class 파일 정의의 일부가 아닌, 제네릭 매개변수를 직접 사용하는 구현 코드의 모든 타입 정보를 컴파일러가 확인하기 때문이다. 

실제 제네릭을 사용한 코드로 만든 실행 코드를 자바 디컴파일러인 JAD를 이용해서 디컴파일하면 모든 제네릭 타입 정보가 사라진다. 

# 명명규칙 이해하기

클래스는 카멜 케이슬 

# 예외처리 하기

# 표준 라이브러리 사용하기 

# 자바 8


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgxMDIyOTkzMiwxNjU4NzY2OTAwLDIxMT
M3NjE4NzEsLTEyNjI3NzMxNTgsNjQwMzQ5NTkyLDE1OTkwMzUx
NjEsLTc5MzgzOTQ3NCwxMDY5NTUyOTYxLC0xNTI0NzA1Mjk1LD
ExMTM1NDExMjYsLTY2MDk5ODMwMiwtNzE3Mzk2NzIwLDQxOTYz
MDgzMyw0MTE4ODczNTEsNjQ5NTM4ODg1LC0xMzE4NTU5NTQ2LD
gxMTE5NjQwOCwtMTY1MTk0MTgxMSwtNTQ4NDU1NzAxLC0xMDM2
MDUxODcyXX0=
-->