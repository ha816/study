# publishOn

간단히 말해 런타임 실행의 일부를 지정된 워커로 이동할 수 있습니다. 

리액터는 런타임에 데이터를 처리할 워커를 지정하기 위해 스케쥴러라는 개념을 도입했습니다. 

이 스케쥴러는 인터페이스 인데, 이 인터페이스가 현재 스트림에 대해서 특정 워커를 선택하는 용도로 사용됩니다. 

```
Scheduler scheduler = 

Flux.range(0, 100) 
	.map(String.valueOf)
	.filter(s -> s.length() > 1)
	// 메인 스레드 구간

	.publishOn(scheduler) // 
		
	.map(this.calculateHash)
	.subscribe()
	// 스케쥴러가 정한 스레드 구간
```
 
publishOn 연산자가 실행되기 전 단계는 메인스레드에서 처리가 됩니다. 그리고 그 이후에는 스케쥴러가 지정한 다른 스레드(워커)에서 작업이 실행됩니다. 

![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.3.RELEASE/src/docs/marble/publishon.png)


# SubscribeOn

publishOn과는 달리 해당 스트림을 구독할 때 동작하는 스케줄러를 지정할 수 있습니다. 구독체인에서 워커의 작업 위치를 변경할 수 있습니다. 
이 연산자는 함수를 실행해 스트림 소스를 만들때 유용합니다. 
일반적으로 이러한 실행은 구독 시간에 수행되므로 .subscribe 메서드를 실행하기 위한 원천소스를 제공하는 함수가 호출됩니다. 

```
Scheduler sheduler = ;
Mono.fromCallbe()
	.subscribeOn(scheduler)
	.subscribe();
```

# Parallel

다수의 병렬 처리를 위한 parallel 연산자는 하위 스트림에 대한 플로 분할과 분할된 플로우 간 균형 조정 역할을 합니다.

```
Flux.range(0, 10000)
	.parallel()
	.runOn(Schedulers.parallel())
	.map()
	.filter()
	.subscribe()
```

여기서 중요한 부분은 Schedulers.paralle()입니다.  parrallel 연산자를 사용하여 ParallelFlux라는 다른 유형의 Flux를 동작시킵니다. 

# Scheduler

스케쥴러는 Scheduler.schedule과 Scheduler.createWroker라는 두 가지 핵심 메서드를 가진 인터페이스 입니다. schedule 메서드를 사용하면 Runnable 작업을 예약하는 것이 가능합니다. 

Scheduler 인터페이스와 Worker 인터페이스의 주요 차이점은 Scheduler 인터페이스가 워커 풀을 나타내는 반면 Wroker는 Thread 또는 리소스를 추상화 한것 입니다. 

* SingleScheduler
	* 모든 작업을 한 개의 전용 워커에 예약합니다. 
	* Sheduler.single()을 호출해 생성합니다.
* ParallelScheduler
	* 고정된 크기의 작업자 풀에서 동작합니다. (기본적으로 크기는 CPU 코어 수)
	* Sheduler.parallel()을 호출해 생성합니다.

# 리액터 컨텍스트

Context는 스트림을 따라 전달되는 **인터페이스** 입니다. Context 인터페이스의 핵심은 
	* 
* 


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNjMyNDQ5NTAsMjk2MTI4ODAsLTE3Nz
EwMjIxLC00OTMxNzIxNjQsMTk0MTE0MzI3NCwtNzI4MjM1MzE5
LDIxMDM2MzYzNDQsOTE3ODkzNzI2LDEyNDM1Nzg5OTksNTY2ND
U0NjQxLDE3OTU5NDc2ODAsMTUyNDgzMjAxMiwtMTM5NjA2MDkw
NSw3MzA5OTgxMTYsMTg3ODM0MTE2Niw3MzA5OTgxMTZdfQ==
-->