# Overview

이제 리액티브 스트림의 생명 주기, 멀티 스레딩, 리택터 프로젝트의 내부 최적화 동작 방식을 자세히 공부해 봅시다. 

# 스트림 생명 주기

## Assembling(조립 단계)

언뜻보면 리액터가 제공하는 API는 처리 흐름에 사용하는 연산자를 조합한 빌더 API 처럼 보입니다. 빌더 패턴은 가변적인 임시 객체 정보를 가지고 있다가 , 객체 생성을 위해선 build와 같은 최종함수를 호출해야 합니다. 그러나 리액터 API는 가공 결과로 불변 객체를 제공합니다. 즉 불변성을 위해 각 연산자가 새로운 객체를 생성합니다. 

리액티브 스트림 실행 흐름을 계획하고 구성하는 단계를 조립 단계라고 합니다. 이 단계에서는 스트림의 타입을 확인해 연산자를 바꾸어 성능 향상 이루거나 몇 가지 훅을 사용하여 디버깅이나 모니터링, 메트릭 수집등의 기능을 사용할 수 있습니다. 

예를 들면 아래와 같이 FluxConcatArray(FluxA, FluxB, FluxC)로 동작하여 성능향상을 꾀합니다.
```
FluxConcatArray(FluxConcatArray(FluxA, FluxB), FluxC)
FluxConcatArray(FluxA, FluxB, FluxC)
```

## Subscription(구독 단계)

구독은 특정 Publisher를 구독(subscribe())할때 발생합니다. 예를 들어 아래 코드는 앞에서 만든 실행 플로를 구독합니다. 

```
...
filteredFlux.subscribe(Subscriber); // filteredFlux(Publisher)를 파라미터로 받은 Subscriber가 구독
```

실행 플로를 만들기 위해 내부적으로 Publisher를 다른 Publisher에 전달합니다 . 즉 일련의 Publisher들로 구성된 체인이 있습니다.  Publisher들이 일련의 체인으로 묶여있기 때문에,  각 Publisher마다 대응하는 Subscriber를 만들고 다시 Subscriber를 체인으로 묶음으로써 Subscriber의 구독 전파가 가능해집니다.

먼저 최상위 Publisher(filteredFlux)를 구독하면, 해당 모든 Publisher 체인의 구독 프로세스가 시작됩니다. 

```
filteredFlux.subscribe(Subscriber){
	mapflux.subscribe(new FilterSubscriber(Subscriber)){
		arrayFlux.subscribe(new MapSubscriber(FilterSubscriber(Subscriber))) {
			... //실제 데이터 송신 시작
			// array -> map -> filtered
		}
	}
}
```
Publisher 체인을 따라 subscribe()가 전파가 되기 때문에, 다음 체인의 Subscriber 생성자에 자기 자신을 파라미터로 전달하고, 그에 따라 Publisher 체인과는 반대 순서로 체인이 형성됩니다.
```
ArraySubscriber(
    MapSubscriber(
        FilterSubscriber(
            Subscriber
        )
    )
)
```

구독 단계는 앞서 조립단계(Assembling)과 유사하게 성능 향상을 꾀할 수 있습니다. 
멀티스레딩을 지원하는 일부 리액티브 연산자로 구독 작업자(워커; Subscriber)를 변경할 수 있습니다. 이 변경은 구독단계에서 Subscriber 체인 생성 과정에서 이루어집니다. 

## Runtime(런타임 단계)

이 단계에서 Publisher와 Subscriber가 onSubscribe() 시그널과 request() 시그널을 교환하면서 스트림 시작됩니다. 앞서 구독단계에서 보았던 예제에서 최상위 Subscriber는 ArraySubscriber이고 거기서부터 onSubscribe()가 전파됩니다.

```
//Subscriber.onSubscribe(Subscription) // 구독자가 구독할 준비를 한다. (Subscription 생성)
MapSubscriber(FilterSubscriber(Subscriber)).onSubscribe(
    new ArraySubscription
) {
    FilterSubscriber(Subscriber).onSubscribe(
        new MapSubscription(ArraySubscription(...))
    ) {
        Subscriber.onSubscribe(
            FilterSubscription(MapSubscription(ArraySubscription(...)))
        ) {
            // 데이터 요청
        }
    }
}
```

모든 구독자 체인(ArraySubcriber -> MapSubscriber -> FilterSubscriber)을 통과하고, 체인에 각 Subscriber가 지정된 구독을 자신의 표현으로 래핑하면 최종적으로 아래와 같이 Subscription 체인의 피라미드를 얻습니다. 
```
FilterSubscription(
    MapSubscription(
        ArraySubscription()
    )
)
```

위 체인을 따라 request(n) 요청이 전파되고, 가장 안 쪽에 있는 ArraySubscription에서 데이터 송신이 시작됩니다. 

```
FilterSubscription(MapSubscription(ArraySubscription(...)))
	.request(10) {
		MapSubscription(ArraySubscription(...))
		.request(10) {
			ArraySubscription(...)
			.request(10) {
				//데이터 전송 시작
			}
		}
	}
```
런타임 단계에서도 request() 호출 횟수를 줄이는 등의 최적화가 이루어집니다. 이를 마이크로 퓨전이라고 합니다.

![Java 9 Flow API - Reactive Streams » grokonez](https://grokonez.com/wp-content/uploads/2017/04/reactive-stream-flow-interface-behavior.png)

# 리액터 쓰레드 스케줄링 모델

리액터 멀티쓰레딩을 위해 사용하는 연산자들을 공부해 봅시다. 현재 실행 중인 쓰레드가 아닌 쓰레드로 실행을 전환할 수 있는 연산자는 크게 네가지가 있습니다.  

## publishOn

publishOn 연산자는 실행의 일부를 지정된 워커(쓰레드)로 이동할 수 있습니다. 

리액터는 런타임에 데이터를 처리할 워커를 지정하기 위해 스케쥴러라는 개념을 도입했습니다. 

이 스케쥴러는 인터페이스 인데, 이 인터페이스가 현재 스트림에 대해서 특정 워커를 선택하는 용도로 사용됩니다. 

```
Scheduler scheduler = 

Flux.range(0, 100) 
	.map(String.valueOf)
	.filter(s -> s.length() > 1)
	// 메인 스레드 구간

	.publishOn(scheduler) // 
		
	.map(this.calculateHash)
	.subscribe()
	// 스케쥴러가 정한 스레드 구간
```
 
publishOn 연산자가 실행되기 전 단계는 메인스레드에서 처리가 됩니다. 그리고 그 이후에는 스케쥴러가 지정한 다른 스레드(워커)에서 작업이 실행됩니다. 

![](https://raw.githubusercontent.com/reactor/reactor-core/v3.1.3.RELEASE/src/docs/marble/publishon.png)


## SubscribeOn

publishOn과는 달리 해당 스트림을 구독할 때 동작하는 스케줄러를 지정할 수 있습니다. 구독체인에서 워커의 작업 위치를 변경할 수 있습니다. 
이 연산자는 함수를 실행해 스트림 소스를 만들때 유용합니다. 
일반적으로 이러한 실행은 구독 시간에 수행되므로 .subscribe 메서드를 실행하기 위한 원천소스를 제공하는 함수가 호출됩니다. 

```
Scheduler sheduler = ;
Mono.fromCallbe()
	.subscribeOn(scheduler)
	.subscribe();
```

## Parallel

다수의 병렬 처리를 위한 parallel 연산자는 하위 스트림에 대한 플로 분할과 분할된 플로우 간 균형 조정 역할을 합니다.

```
Flux.range(0, 10000)
	.parallel()
	.runOn(Schedulers.parallel())
	.map()
	.filter()
	.subscribe()
```

여기서 중요한 부분은 Schedulers.paralle()입니다.  parrallel 연산자를 사용하여 ParallelFlux라는 다른 유형의 Flux를 동작시킵니다. 

## Scheduler

스케쥴러는 Scheduler.schedule과 Scheduler.createWroker라는 두 가지 핵심 메서드를 가진 인터페이스 입니다. schedule 메서드를 사용하면 Runnable 작업을 예약하는 것이 가능합니다. 

Scheduler 인터페이스와 Worker 인터페이스의 주요 차이점은 Scheduler 인터페이스가 워커 풀을 나타내는 반면 Wroker는 Thread 또는 리소스를 추상화 한것 입니다. 

* SingleScheduler
	* 모든 작업을 한 개의 전용 워커에 예약합니다. 
	* Sheduler.single()을 호출해 생성합니다.
* ParallelScheduler
	* 고정된 크기의 작업자 풀에서 동작합니다. (기본적으로 크기는 CPU 코어 수)
	* Sheduler.parallel()을 호출해 생성합니다.

## Context 

Context는 스트림을 따라 전달되는 **인터페이스** 입니다. 핵심 아이디어는 나중에 런타임 단계에서 필요한 컨텍스트 정보에 엑세스할 수 있도록 하는 것입니다. 

ThreadLocal이 같은 역할을 하는데 왜 Context가 필요한지 궁금할 수 있습니다. 



#  리액터 내부 구조

## 매크로 퓨전









> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMxNzQxMTU0OCwxNjU2MjY0MTgxLC04Nz
AzMjk2NjBdfQ==
-->