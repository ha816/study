# Spring Data

이번 장에서는 Spring Data(스프링 데이터) 모듈을 사용해 리액티브 방식으로 데이터에 엑세스하는 방법을 알아봅시다. 

**스프링 데이터 모듈은 응답성이 뛰어난 리액티브 응용 프로그램을 개발하는데 필수적 입니다.** 

선택한 데이터베이스가 리액티브 또는 비동기 드라이버를 제공하지 않는다 하더라도 전용 스레드 풀을 사용해 리액티브 응용 프로그램을 구축하는 방법을 알아봅시다. 블로킹 방식의 데이터 베이스에 대해서도 리액티브 접근법을 사용할 수 있지만, 블로킹 방식의 I/O는 리액티브 응용 프로그램에서 사용하면 안됩니다. 


## 도메인 주도 설계 

에릭 에반스가 쓴 도메인 주도 설계는 모든 소프트웨어 엔지니어의 책장에 꽂아둬야 합니다. DDD(Domain-driven design)은 공통어휘(즉, 컨텍스트, 도메인, 모델 및 유비쿼터스 언어)를 설정하고 모델의 무결성을 유지하기 위한 원칙을 공식화 합니다. 

DDD의 가장 중요한 결과는 DDD관점에서 정의한 각 바운디드 컨텍스트가 하나의 마이크로 서비스로 매핑된다는 점입니다. DDD는 비즈니스 핵심 도메인에 집중합니다. 특히 도메인 모델을 표현, 생성, 검색하는 수단에 중점을 두고 있습니다. 

## 마이크로서비스 시대의 데이터 저장소

마이크로서비스 아키텍처가 도입되어 영속 계층에 생긴 가장 큰 변화는 서비스간에 데이터 저장소를 공유하지 않게 된것 입니다. 즉 논리적으로 분할된 각 서비스가 데이터를 소유하고 관리하는 경우, 서비스 API를 호출을 제외한 방식으로는 다른 서비스의 데이터에 접근할 수 없는 것이 이상적입니다. 

물리적으로 보면 스토리지를 서비스 마다 나눌때 다양한 방식으로 구현할 수 있습니다. 가장 간단한 방법은 하나의 데이터베이스 서버를 두고 각 서비스에 대해 독립적인 별도의 스키마(마이크로서비스마다 스키마)를 할당하는 것입니다. 이런 구성은 구현이 쉽고 서버 리소스를 적게 필요로 하며, 실제 운영환경에서 많은 관리 노력이 필요치 않아 초기 개발 단계에서 좋습니다. 

구현이 쉬운 방면에 규칙이 무너지기도 쉽습니다. 데이터가 동일한 데이터베이스에 저장되기 때문에 개발자가 둘 이상의 서비스에 겹치는 데이터를 검색하거나 변경할 수 있습니다. 

이럴때 각 서비스가 하나의 데이터베이스를 공유하지만 다른 엑세스 권한을 가져 서비스에 맞는 데이터 베이스에 엑세스 하도록 만들수 있습니다. 

심지어 요구사항에 따라 혼합해서 사용할 수도 있습니다. 
일부 서비스는 독립적인 데이터베이스 서버로 묶고 나머지는 메인 데이터 베이스 서버로 묶고 서버 안의 DB를 서비스에 맞게 만듭니다. 

심지어 다른 종류의 데이터베이스 서버를 동시에 사용하는 것도 가능하며, 다른 종류의 데이터베이스 엔진(SQL 및 NoSQL) 함께 사용해 최상의 결과를 얻을 수 있습니다. 이 접근법을 다중 저장소 영속화(polyglot persistence)라 합니다.

요즘에는 시스템이 둘 이상의 서로 다른 데이터베이스를 사용하는것이 거의 일상입니다. 

대부분의 관계형 데이터베이스는 ACID원칙을 토대로 구축되었으며 스토리지와 통신하기 위해 거의 유사한 SQL언어를 제공합니다. 일반적으로 RDBMS는 광범위한 응용 프로그램에 적합하지만, 그래프 저장, 분산 저장소에 대해선 최상의 기능을 제공하진 않습니다.  반면 NoSQL 데이터베이스는 광범위한 기본 원칙을 가져 범용 데이터 저장소로는 적합하진 않지만 몇 가지 사례에서는 좋은 성능을 보입니다. 

또한다중 언어 영속성은 복잡성으로 인해 추가 비용이 듭니다. 

스프링 데이터는 데이터 영속성을 위한 하위 프로젝트를 가지고 있습니다. 앞으로 이 스프링 데이터에서 사용할 수 있는 다양한 디자인 접근법과 데이터 베이스 커넥터에 대해서 알아봅시다. 

## 서비스로서의 데이터베이스 

적절히 설계된 마이크로서비스 아키텍처에서 모든 서비스가 상태에 의존적이지 않으며, 모든 상태 정보는 데이터 지속성을 관리하는 방법을 알고 있는 특수 서비스에 저장됩니다. 

클라우드용으로 설계되지 않은 데이터베이스 서버를 효율적으로 관리하고 조정하는 것은 꽤나 어려운 일입니다. 대부분 클라우드 제공 업체는 데이터베이스를 서비스(DBaas)로 제공해 이런 문제를 해결합니다. 이런 스토리지 솔루션은 일반 데이터베이스(MySQL, PostgreSQL 및 Redis)를 약간 수정하여 제공하거나 애초에 클라우드용으로 설계되었습니다. 

## 마이크로서비스 사이의 데이터 공유

실제 비즈니스 시스템에서는 요청을 처리하기 위해 두 개 이상의 서비스가 소유한 DB에 쿼리를 해야하는 경우가 있습니다. 마이크로 서비스 아키텍처 이전에는 이 작업을 단일 조인 쿼리로 구현했겠지만, 마이크로 서비스에서는 금지되는 방식입니다. 

그리고 데이터를 조회하는 것은 매우 간단하지만, 한 번에 몇 가지 서비스를 동시에 업데이트하는 것은 훨씬 어렵습니다. 거기다가 두 개 이상의 마이크로 서비스의 데이터베이스가 트랜잭션으로 묶여야 한다면 그것 또한 어려워 집니다.

이런 문제를 해결하기 위해선 크게 분산 트랜잭션과 이벤트 기반 아키텍처로 해결할 수 있습니다. 

### 분산 트랜잭션

분산 트랜잭션은 두개 이상의 독립적인 시스템의 데이터를 동시에 업데이트하는 트랜잭션 입니다. 분산 트랜잭션은 데이터 저장소를 원자적으로 업데이트하기 위해 사용됩니다.

분산 트랜잭션은 다른 데이터 저장소에 안정적으로 데이터를 저장하기 위해 자주 사용했습니다. 그리고 이 방식은 장애복구에도 유용합니다. 

하지만 **분산 트랜잭션은 최근과 같이 여러 마이크로 서비스로 구성된 시스템에서는 권장되지 않습니다.** 그 이유는 아래와 같습니다. 

* 분산 트랜잭션을 사용하는 서비스에서는 2단계 커밋을 지원하는 API가 있어야 합니다. (Two-phase Locking을 통한 글로벌 직렬성을 보장하는 API)
* 분산 트랜잭션을 사용하는 마이크로서비스는 서로 강하게 결합되고 있고, 이는 마이크로 서비스 아키텍처에서 권장하지 않는 방식입니다. 
* 분산 트랜잭션은 확장이 되지 않습니다. 이로 인해 대역폭이 제한되고 확장성이 저하됩니다. 

## 이벤트 기반 아키텍처

마이크로 서비스 환경에서 **분산된 비즈니스 트랜잭션을 구현하는 가장 좋은 방법은 이벤트 중심 아키텍처를 사용하는 것 입니다.** 

시스템의 상태를 변경하는 경우, 먼저 서비스 자체의 데이터베이스에서 데이터를 변경하고 내부 트랜잭션에서 이벤트를 메세지 브로커에 전달합니다. 따라서 트랜잭션과 관련됬더라도 서비스 경계를 넘지 않습니다. 

이벤트 메세지를 받은 두 번째 서비스는 이벤트를 수신하고 자신의 저장된 데이터를 변경합니다. 필요하면 다시 이벤트를 송신할 수도 있습니다. 서비스는 동시에 블로킹 되지 않으며 상호 의존성이 없습니다. 

시스템에 있는 유일한 결합 지점은 교환하는 메세지라고 할 수 있는데 분산 트랜잭션과는 다르게 이벤트 기반 아키텍처를 사용하면 첫번째 시스템이 동작하는 시점에 두번째 시스템이 실행 중이 아니더라도 요청에 대한 처리를 계속해서 할 수 있습니다. 

이런 특성은 시스템 복원력에 직접 영향을 주기 때문에 중요하며 분산 트랜잭션에서는 모든 컴포넌트(마이크로서비스)가 동작 중이어야 하며, 트랜잭션이 진행되는 동안 정상 동작해야 합니다. 따라서 마이크로 서비스 수가 많아지거나 분산 트랜잭션에 참여하는 서비스가 많아질 수록 시스템의 확장성 및 성능이 떨어지게 됩니다. 

### 일반적인 분산 트랜잭션 분석

분산 트랜잭션을 사용하면 시스템 상태에 대한 확신을 가지게 됩니다. 즉 시스템의 모든 데이터에 대해 항상 일관성을 보장합니다. 그러나 DDD의 저자 반 버논은 불확실성을 도메인 모델에 포함할것을 이야기 합니다. 즉 시스템은 어떤 방식으로든 언제나 일관성 없는 상태가 될 수 있고 이런 불확실성이 계속 발생하더라도 이를 비즈니스 워크플로의 일부로 포함하는 것이 좋다는 이야기 입니다. 

예를 들어 '결제 정보 확인중'이라는 새로운 상태를 도입해 결제 정보 확인 없이 주문을 생성할 수 있다고 합시다. 이 새로운 상태는 불확실한 상황(결제 정보는 유효하거나 유효하지 않을 수 잇음)을 한정된 시간 동안(결제 정보가 확인 될때까지) 유지되는 별도의 비즈니스 이벤트로 취급됩니다. 이런 접근 방식을 사용하면 시스템에서 항상 일관성을 유지할 필요가 없습니다. 

미래의 일관성(eventual consistency)란 언젠가 미래에 일어날 일관성을 뜻합니다. 대게 eventual consistency를 보장한다는 것은 운영을 성공적으로 할 수 있는 안정적인 시스템 구축이라는 목적을 달성할 수 있다는 것을 말합니다. 











> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1OTk0NjI3NDMsMTU1NjEwOTAyNSwxOD
QzMTkyOTYyLDEyNTc4MzM4NjUsODQzNjAwNTc4LC0xMTE2NzE0
MjQ5LC04NDE4OTgyMzEsLTE1NzQ0ODk1NTUsMTU3NzQxMjYyMC
wtMTAzNzIwMjE2MSwtNTA3NzgzNDE1LDI0NDc0MzExMCwtMTQ2
NjU1MzA3MSwtOTgxNjgxNTQ5LDEyMTk4NDg5MzYsLTc3Mzg1MD
AyNiwyMTI2ODA5NTA4LDQyNTYyNzM0MF19
-->