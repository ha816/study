# Overview

이번 장에서는 Spring Data(스프링 데이터) 모듈을 사용해 리액티브 방식으로 데이터에 엑세스하는 방법을 알아봅시다. 

**스프링 데이터 모듈은 응답성이 뛰어난 리액티브 응용 프로그램을 개발하는데 필수적 입니다.** 

선택한 데이터베이스가 리액티브 또는 비동기 드라이버를 제공하지 않는다 하더라도 전용 스레드 풀을 사용해 리액티브 응용 프로그램을 구축하는 방법도 있습니다. 블로킹 방식의 데이터 베이스에서도 리액티브 비동기 접근법을 사용할 수 있습니다만, 기본적으로 **블로킹 방식의 I/O는 리액티브 응용 프로그램에서 사용하면 안됩니다.** 

# 데이터 처리 패턴 

현재 대다수의 시스템은 마이크로 서비스로 설계되고 전환되고 있습니다. 잠깐 마이크로서ㅓ비스의 관점에서 데이터 저장에 대한 기본 개념, 가능한 전략, 구현 방법 및 데이터 영속화의 권장 사항을 알아봅시다. 

[데이터 영속성](https://siyoon210.tistory.com/138#:~:text=%EC%98%81%EC%86%8D%ED%99%94%EC%9D%98%20%EC%82%AC%EC%A0%84%EC%A0%81%20%EC%9D%98%EB%AF%B8,DB%EC%97%90%20%EC%A0%80%EC%9E%A5%EB%90%9C%20%EA%B2%83%EC%9D%80%20%EC%95%84%EB%8B%99%EB%8B%88%EB%8B%A4.)
: 영속화의 사전적 의미는 '사라지지 않고 지속되게 한다' 입니다. 쉽게 말하자면 DB에 저장된다는 의미입니다. 하지만 '영속'이라는 말에 현혹되어서는 안됩니다. 반드시 '영속화'되어 DB에 저장된 것은 아니라 영속화 될 수 있는 가능성이 있을 뿐입니다.

## 도메인 주도 설계(DDD)

에릭 에반스가 쓴 도메인 주도 설계(DDD, Domain-Driven Design)은 공통어휘(즉, 컨텍스트, 도메인, 모델 및 유비쿼터스 언어)를 설정하고 모델의 무결성을 유지하기 위한 원칙을 공식으로 만듭니다.

DDD는 비즈니스의 핵심 도메인에 집중합니다. 특히 도메인 모델을 표현, 생성, 검색하는 수단에 중점을 두고 있습니다. DDD관점에서 정의한 각 바운디드 컨텍스트는 하나의 마이크로 서비스에 대응합니다. (바운디드 컨텍스트 = 마이크로 서비스)

## 마이크로서비스의 데이터 저장소 및 다중 영속화

마이크로서비스 아키텍처가 도입되어 데이터 영속 계층(데이터 저장)에 생긴 가장 큰 변화는 서비스간에 데이터 저장소를 공유하지 않게 된것 입니다. 즉 논리적으로 분할된 각 서비스가 데이터를 소유하고 관리하는 경우, 서비스 API를 호출을 제외한 방식으로는 다른 서비스의 데이터에 접근할 수 없는 것이 바람직합니다.

물리적 관점에서 서비스 마다 스토리지를 나눌때 다양한 방식으로 구현할 수 있습니다. 가장 간단한 방법은 하나의 데이터베이스 서버를 두고 각 서비스에 대해 독립적인 별도의 스키마(마이크로서비스마다 스키마)를 할당하는 것입니다. 이 구성은 구현이 쉽고 서버 리소스를 적게 필요로 하며, 실제 운영환경에서 많은 관리 노력이 필요치 않아 초기 개발 단계에서 좋습니다. 

구현이 쉬운 방면에 규칙이 무너지기도 쉽습니다. 데이터가 동일한 데이터베이스에 저장되기 때문에 개발자가 둘 이상의 서비스에 겹치는 데이터를 검색하거나 변경할 수 있습니다. 이럴때는 각 서비스가 하나의 데이터베이스를 공유하지만 다른 엑세스 권한을 가져 서비스에 맞는 데이터 베이스에 엑세스 하도록 만들수 있습니다. 

다른 방법으로는 일부 서비스는 독립적인 데이터베이스 서버로 묶고 나머지 서비스는 각각 독립적인 메인 데이터 베이스 서버를 가지도록 구성합니다. 심지어 다른 종류의 데이터베이스 서버를 동시에 사용하는 것도 가능하며, 다른 종류의 데이터베이스 엔진(SQL 및 NoSQL) 함께 사용해 최상의 결과를 얻을 수 있습니다. 이러한 **다른 종류의 데이터 베이스를 사용하는 접근법을 다중 저장소 영속화(polyglot persistence)라 합니다.** 요즘 시스템은 둘 이상의 서로 다른 데이터베이스를 사용하는것이 거의 일상입니다. 

대부분의 관계형 데이터베이스는 ACID원칙을 토대로 구축되었으며 스토리지와 통신하기 위해 거의 유사한 SQL언어를 제공합니다. 일반적으로 RDBMS는 광범위한 응용 프로그램에 적합하지만, 그래프 저장, 분산 저장소에 대해선 최상의 기능을 제공하진 않습니다. 반면 NoSQL 데이터베이스는 광범위한 기본 원칙을 가져 범용 데이터 저장소로는 적합하진 않지만 몇 가지 사례에서는 좋은 성능을 보입니다.

스프링 데이터는 데이터 영속성을 위한 하위 프로젝트를 가지고 있습니다. 앞으로 이 스프링 데이터에서 사용할 수 있는 다양한 디자인 접근법과 데이터 베이스 커넥터에 대해서 알아보겠습니다.

## 클라우드 서비스로서의 데이터베이스 

적절히 설계된 마이크로서비스 아키텍처에서는 모든 서비스가 상태에 의존적이지 않으며, 모든 상태 정보는 데이터 영속성을 관리하는 방법을 알고 있는 특수 서비스에 저장됩니다. 

클라우드용으로 설계되지 않은 데이터베이스 서버를 효율적으로 관리하고 조정하는 것은 꽤나 어려운 일입니다. 대부분 클라우드 제공 업체는 데이터베이스를 서비스(DBaas)로 제공해 이런 문제를 해결합니다. 이런 스토리지 솔루션은 일반 데이터베이스(MySQL, PostgreSQL 및 Redis)를 약간 수정하여 제공하거나 애초에 클라우드용으로 설계되었습니다. 

## 마이크로서비스간 데이터 공유

실제 비즈니스 시스템에서는 요청을 처리하기 위해 두 개 이상의 서비스가 소유한 DB에 쿼리를 해야하는 경우가 있습니다. 마이크로 서비스 아키텍처 이전에는 이 작업을 단일 조인 쿼리로 구현했겠지만, 마이크로 서비스에서는 금지되는 방식입니다. 

일반적으로 데이터를 조회하는 것은 매우 간단하지만, 한 번에 몇 가지 서비스를 동시에 업데이트하는 것은 훨씬 어렵습니다. 거기다가 두 개 이상의 마이크로 서비스의 데이터베이스가 트랜잭션으로 묶여야 한다면 훨씬 어려운 문제가 됩니다. 이런 문제를 해결하기 위해 크게 분산 트랜잭션과 이벤트 기반 아키텍처를 사용합니다.

### 분산 트랜잭션

분산 트랜잭션은 두개 이상의 독립적인 시스템의 데이터를 동시에 업데이트하는 트랜잭션 입니다. 분산 트랜잭션은 데이터 저장소를 원자적으로 업데이트하기 위해 사용됩니다.

분산 트랜잭션은 다른 데이터 저장소에 안정적으로 데이터를 저장하기 위해 자주 사용했습니다. 그리고 이 방식은 장애복구에도 유용합니다. 

하지만 **분산 트랜잭션은 최근과 같이 여러 마이크로 서비스로 구성된 시스템에서는 권장되지 않습니다.** 그 이유는 아래와 같습니다. 

* 분산 트랜잭션을 사용하는 서비스에서는 2단계 커밋을 지원하는 API가 있어야 합니다. (Two-phase Locking을 통한 글로벌 직렬성을 보장하는 API)
* 분산 트랜잭션을 사용하는 마이크로서비스는 서로 강하게 결합되고 있고, 이는 마이크로 서비스 아키텍처에서 권장하지 않는 방식입니다. 
* 분산 트랜잭션은 확장이 되지 않습니다. 이로 인해 대역폭이 제한되고 확장성이 저하됩니다. 

### 이벤트 기반 아키텍처

마이크로 서비스 환경에서 **분산된 비즈니스 트랜잭션을 구현하는 가장 좋은 방법은 이벤트 중심 아키텍처를 사용하는 것 입니다.** 

시스템의 상태를 변경하는 경우, 먼저 서비스 자체의 데이터베이스에서 데이터를 변경하고 내부 트랜잭션에서 이벤트를 메세지 브로커에 전달합니다. 따라서 트랜잭션과 관련됬더라도 서비스 경계를 넘지 않습니다. 

이벤트 메세지를 받은 두 번째 서비스는 이벤트를 수신하고 자신의 저장된 데이터를 변경합니다. 필요하면 다시 이벤트를 송신할 수도 있습니다. 서비스는 동시에 블로킹 되지 않으며 상호 의존성이 없습니다. 

시스템에 있는 유일한 결합 지점은 교환하는 메세지라고 할 수 있는데 분산 트랜잭션과는 다르게 이벤트 기반 아키텍처를 사용하면 첫번째 시스템이 동작하는 시점에 두번째 시스템이 실행 중이 아니더라도 요청에 대한 처리를 계속해서 할 수 있습니다. 

이런 특성은 시스템 복원력에 직접 영향을 주기 때문에 중요하며 분산 트랜잭션에서는 모든 컴포넌트(마이크로서비스)가 동작 중이어야 하며, 트랜잭션이 진행되는 동안 정상 동작해야 합니다. 따라서 마이크로 서비스 수가 많아지거나 분산 트랜잭션에 참여하는 서비스가 많아질 수록 시스템의 확장성 및 성능이 떨어지게 됩니다. 

### 일반적인 분산 트랜잭션 분석

분산 트랜잭션을 사용하면 시스템 상태에 대한 확신을 가지게 됩니다. 즉 시스템의 모든 데이터에 대해 항상 일관성을 보장합니다. 그러나 DDD의 저자 반 버논은 불확실성을 도메인 모델에 포함할것을 이야기 합니다. 즉 시스템은 어떤 방식으로든 언제나 일관성 없는 상태가 될 수 있고 이런 불확실성이 계속 발생하더라도 이를 비즈니스 워크플로의 일부로 포함하는 것이 좋다는 이야기 입니다. 

예를 들어 '결제 정보 확인중'이라는 새로운 상태를 도입해 결제 정보 확인 없이 주문을 생성할 수 있다고 합시다. 이 새로운 상태는 불확실한 상황(결제 정보는 유효하거나 유효하지 않을 수 잇음)을 한정된 시간 동안(결제 정보가 확인 될때까지) 유지되는 별도의 비즈니스 이벤트로 취급됩니다. 이런 접근 방식을 사용하면 시스템에서 항상 일관성을 유지할 필요가 없습니다. 

미래의 일관성(eventual consistency)란 언젠가 미래에 일어날 일관성을 뜻합니다. 대게 eventual consistency를 보장한다는 것은 운영을 성공적으로 할 수 있는 안정적인 시스템 구축이라는 목적을 달성할 수 있다는 것을 말합니다. 

### SAGA 패턴

마이크로서비스 분야에서 분산 트랜잭션에 가장 널리 사용되는 패턴 중 하나는 SAGA 패턴입니다. 1987년 데이터베이스에서 장기간 트랜잭션을 관리하기 위해 도입되었습니다. 

SAGA는 소수의 작은 트랜잭션으로 구성되며, 각 트랜잭션은 하나의 마이크로 서비스에 국한됩니다. 외부 요청이 SAGA를 시작하고, 첫번째 작은 트랜잭션을 시작합니다. 성공하면 두번재 트랜잭션이 시작됩니다. 트랜잭션 중간에 실패하면 이전 트랜잭션이 롤백됩니다. 이를 구현하는 패턴에는 코레오그래피(events-based choregraph)와 오케스트레이션 두가지가 있습니다. 

### 이벤트 소싱

마이크로 서비스응용 프로그램의 이벤트 플로를 처리하기 위해 이벤트 소싱을 사용할 수 있습니다. **이벤트 소싱은 각 비즈니스 엔티티의 상태 변화 순서를 저장합니다.** 

각 비즈니스틔 상태변화 순서를 저장하면 업데이트 이벤트를 순차적으로 복기해 현재 상태를 계산할 수 있을 뿐만 아니라 엔티티의 상태를 신뢰할 수 있는 로그를 제공할 수 도 있습니다. 또한 쿼리를 통해 과거 특정 시점의 엔티티의 상태를 확인해 볼 수 있습니다. 일반적으로 이벤트 소싱을 구현하는 서비스는 다른 서비스가 엔티티 업데이트를 구독할 수 있도록 하는 API를 제공합니다. 

현재 상태를 계산하는데 필요한 시간을 최적화 하기 위해 응용 프로그램은 스냅샷을 주기적으로 작성하고 저장할 수 있습니다. 저장소 크기를 줄이기 위해 이전 스냅샷을 삭제할 수도 있습니다. 

이런 장점에도 불구하고 개발자들은 익숙하지 않다는 점과 일반적인 프로그래밍 방식과 차이, 러닝 커브가 크다는 이유로 이벤트 소싱이 잘 사용되지 않습니다. 또한 상태를 지속적으로 재계산해야 하기 때문에 이벤트 소싱을 사용하면 쿼리가 복잡할때 효율적인 쿼리를 수행할 수 없습니다. 이 경우 명령 및 쿼리 책임 분리(CQRS)가 도움이 됩니다. 

### 명령 및 쿼리 책임 분리(CQRS)

CQRS는 크게 두 크게 쓰기/읽기 두 부분으로 구성됩니다. 

쓰기
: 상태 변경 명령을 수신해 기본 이벤트 저장소에 저장합니다. 하지만 엔티티 상태를 반환하지는 않습니다.

읽기
: 상태를 변경하지 않고 쿼리 결과를 반환합니다. 별개의 쿼리에 대한 상태 표현은 뷰로 저장되며, 갱신 이벤트가 명령으로 수신된 후에 비동기 식으로 다시 계산 됩니다. 

책에서 CQRS예시로는 이벤트 저장소로 NoSQL인 카산드라를 사용합니다. 이벤트 저장소에는 엔티티의 상태 변화를 저장하며 쓰기 파트에 해당합니다. 카산트라에 쌓인 데이터를 바탕으로 비동기적으로 상태를 재계산한 결과를 쿼리 저장소에 해당하는 엘라스틱서치에 저장합니다. 여기서 쿼리 저장소는 쿼리 결과를 반환하며 엘라스틱서치가 쓰기파트 역할을 수행합니다. 

**CQRS패턴은 대량의 데이터를 스트리밍 방식으로 처리하도록 해주고 동시에 현재 시스템 상태와 다양한 쿼리에 신속하게 응답할 수 있습니다.** 

### 충돌 없는 복제 데이터 타입(CRDT)

잘 정의된 마이크로서비스라고 하더라도 응용 프로그램이 커지면 커질 수록 더 많은 데이터를 처리해야 합니다. 언급했듯이 트랜잭션은 확장성이 좋지 않으며 응용 프로그램이 늘어나면 한 마이크로 서비스에서 클로벌 상태를 일관되게 유지하는 게 점점 힘들어 집니다. 따라서 성능 및 시스템 확장성을 위해 클로벌 룩이나 트랜잭션 일관성 없이 여러 서비스 인스턴스에서 동시에 데이터를 업데이트하는 경우가 발생할 수 있습니다. 이러한 접근법을 낙관적 복제(Optimistic Replication)이라고 하며, 나중에 발생할 불일치를 감수하면서 데이터 복제본을 병행해서 사용할 수 있습니다. 이러한 시나리오에서는 복제본이 병합될때 복제본 간의 일관성이 다시 설정됩니다. 병합 시점에서 충돌을 해결해쟈 하지만, 이는 대개 사용자의 입장에서 받아 들일 수 없는 일부 변경 사항을 되돌려야 한다는 것을 의미합니다. 병합 과정이 항상 성공하도록 하는 데이터 구조도 있는데 이러한 데이터 구조를 충돌 없는 복제 데이터 타입(CRDT)이라고 합니다. 

**CRDT는 여러 번의 계산에 걸쳐 복제되고 조정 없이 동시에 업데이트된 다음에 병합되더라도 일관된 상태를 유지할 수 있는 데이터 타입을 말합니다.** 

### 데이터 저장소로서의 메시징 시스템

이벤트 소싱에 대한 아이디어를 토대로 메세지를 위한 영속적 스토리지를 가진 메시지 브로커가 개별 마이크로서비스를 위한 전용 데이터에 대한 필요성을 감소 시킬 수 있습니다. 실제로 모든 엔티티에 대한 업데이트가 충분한 시간동안 메시지 브로커에 저장되고 언제든 다시 읽을 수 있다면 이 이벤트만으로도 시스템의 전체 상태를 정의할 수 있습니다. 

시스템이 기동하는 동안 각 서비스는 최근 이벤트 기록을 읽어들여 엔티티 상태를 다시 계산할 수 있습니다. 따라서 서비스는 새로운 업데이트 명령을 처리하고 쿼리를 읽고 때때로 브로커에 엔티티 스냅샷을 생성하고 보내는 것만으로 동작할 수 있습니다. 

**아파치 카프카는 가장 널리 사용되는 분산 메세지 브로커입니다. 신뢰할 수 있는 영속석 계층이 있어 시스템의 주 데이터 저장소로 사용할 수 있고 시스템 내의 유일한 데이터 저장소로도 활용할 수 있습니다.** 

# 데이터 조회를 위한 동기식 모델

리액티브 영속성의 이점과 문제점을 이해하기 위해 먼저 리액티브 이전 시대의 애플리케이션 데이터 엑세스의 접근법을 살펴봅시다. 또한 쿼리를 실행하고 처리하는데 클라이언트와 데이터베이스가 어떤 상호작용을 동하는지, 어떤 부분에서 비동기적으로 수행할 수 있는지 알아봅시다. 

데이터 베이스의 영속성은 몇가지 추상화 계층으로 이루어져 있으므로 차근차근 알아봅시다. 

## 와이어 프로토콜(Wire Protocol)

대부분의 소프트웨어는 서버에서 별도의 프로세스로 실행되는 데이터베이스를 사용합니다. 응용 프로그램은 **데이터베이스 드라이버**라고 하는 특수한 클라이언트 라이브러리를 사용해 외부 데이터베이스와 통신합니다. 또한 이 과정에서 사용되는 프로토콜이 와이어 프로토콜 입니다.

와이어 프로토콜
: 데이터베이스 드라이버와 데이터베이스가 통신하는 방법을 정의합니다. 구체적으로는 전송되는 메세지의 정렬 형식을 정의합니다. 
일반적으로 TCP/IP를 사용하도록 설계되어 블로킹 방식으로 동작할 필요가 없습니다. 
대다수의 와이어 프로토콜은 언어에 독립적이므로 자바 응용 프로그램이 C++로 만들어진 데이터베이스로 쿼리를 보낼 수 있습니다. 

TCP/IP
: 일종의 통신 규약이며 TCP와 IP 두가지의 프로토콜로 이루어져 있습니다. TCP가 데이터의 추적을, IP가 배달을 처리하는 방식으로 동작합니다. 이 중 TCP는 슬라이딩 윈도우 방식으로 구현된 흐름 제어를 통해 배압을 지원하는 비동기 프로토콜 입니다.

데이터베이스 와이어 프로토콜을 기반으로 더 높은 수준의 프로토콜을 사용할 수도 있습니다. 예를 들어, HTTP2, WebSocket, gPRC, RScocket등을 사용할 수 있습니다. 

* 한 번에 처리 
	* 데이터베이스 측에서 전체 결과 집합을 계산한 후 쿼리가 끝나자마자 데이터를 컨테이너에 넣고 컨테이터를 클라이언트에 전달하는 방식입니다. 논리적으로 전혀 배압을 고려하지 않고 통째로 데이터를 보내기 때문에 클라이언트에서 커다란 버퍼를 필요로 합니다. 또한 클라이언트는 전체 쿼리가 실행되고 완료된 후에 결과를 받을 수 있습니다. 이 방식은 구현이 쉽습니다. 또한 쿼리 실행 프로세스가 아주 길지도 않으며, 업데이트된 쿼리가 동시에 발생하는 경합이 줄어들 수 도 있습니다. 
* 청크로 나누어 처리
	* 클라이언트가 요청할때 청크로 결과 집합을 보낼 수도 있습니다. 데이터베이스 요청에 의해 청크가 채워지거나 클라이언트가 요구한 양의 데이터를 전달한 후에만 실행을 계속할 수 있습니다. 이 방법은 메모리 버퍼 사용량을 줄일 수 있고 쿼리가 실행중일때 첫번째 행을 반환할 수 있으며 논리적인 배압을 전파 가능하게 하고 쿼리를 취소하도록 할 수 있습니다. 
* 스트림 처리
	* 쿼리 실행 중 결과를 얻자마자 스트림으로 보내는 방법도 있습니다. 또한 클라이언트는 데이터베이스에 데이터 요구량을 알려주고, 쿼리 실행 프로세스에 영향을 줄 수 있는 논리적 배압을 줄 수 있습니다. 이러한 접근법은 추가적인 버퍼가 거의 필요 없고, 클라이언트는 매우 빠르게 쿼리의 첫 번째 행을 수신할 수 있습니다. 그러나 이러한 방법은 매우 수다스러운 통신 방식으로 빈번한 시스템 호출로 네트워크와 CPU를 과도하게 사용할 수도 있습니다. 

일반적인 데이터 베이스는 하나 이상의 접근법을 이용해 와이어 프로토콜을 구현합니다. 예를 들어, MySQL은 전체 또는 스트림으로 행 단위로 결과를 보낼 수 있습니다. 반면에 PostgreSQL 데이터베이스는 PostgreSQL 포털이라는 개념으로 클라이언트가 수신할 수 있는 만큼의 데이터 행을 요청할 수 있습니다. 

이제 잘 설계된 와이어 프로토콜은 리액티브에서 필요한 모든 특성을 가지고 있다는 것을 알았습니다. 

## 데이터베이스 드라이버(DB Driver)

**데이터베이스 드라이버**는 와이어 프로토콜을 메서드 호출이나 콜백, 리액티브 스트림과 같은 프로그래밍 언어로 구현한 라이브러리 입니다. 










> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MTgzMTc4MzcsMjA1ODk4ODA3MSwtMj
I5OTIxMjQ1LDczNzQ4MDA0LC0xNTE4ODAzNTc1LC0xNDAwNzkw
NjIzLDM1MTM0NDIyNywtMTA0MjgzNTY4NSwtMjAyMzA4MzEyNy
wtMjE0MDk2OTc0LDQ5NzY2ODMxNiwtMTUxNzE2ODQ3MiwzMDQ3
ODQ5ODAsLTEwOTYzNTQxNTAsNjI0MzIxNTczLDEyNTMwNTY5Ni
wxNTU2MTA5MDI1LDE4NDMxOTI5NjIsMTI1NzgzMzg2NSw4NDM2
MDA1NzhdfQ==
-->