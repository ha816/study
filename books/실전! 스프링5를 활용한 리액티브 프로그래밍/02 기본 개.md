
# Publisher - Subscriber 패턴

**publihser - subscriber패턴**은 **observer 디자인 패턴**과 유사한 부분이 많다.
하지만 결코 같은 패턴이 아니라는 점을 유의하자. 

![](https://k.kakaocdn.net/dn/bqLWNV/btqBtFtFi9z/EwApKeBgffUuryMUlMpEIK/img.png)

![](https://k.kakaocdn.net/dn/cXQrI4/btqBtMTDnAn/KS6tHYZA7Qz7J5qSYz2O6K/img.png)

  
publisher-subscriber 패턴에서 메시지 송신자(publisher)는 정해진 수신자(specific receivers called subscriber)와 직접적 메시지를 통신하지 않는다. 그 둘 사이에 추가 구성요소가 있습니다. 이 구성요소는 이벤트 채널(메세지 브로커, 이벤트 버스)라고도 합니다. 

구독자는 알림이 오는 이벤트 채널을 알고 있지만, 발행자가 누구인지에는 신경쓰지 않습니다. 그리고 발행자는 다수가 될 수 있습니다. 

# RxJava의 역사 및 기본 개념

사실 RxJava는 자바 플랫폼에서 리액티브 프로그래밍을 위한 표준 라이브러리 였습니다. 그리고  RxJava가 사실상 자바 진영에 리액티브 프로그래밍의 길을 개척했습니다. 

RxJava 라이브러리는 ReactiveExtensions(ReactiveX)의 자바 구현체 입니다. 동기식 또는 비동기식 스트림에 관계없이 명령형 언어를 이용해 데이터 스트림을 조작할 수 있는 도구들 입니다. 

명령형 언어에 익숙하다면 리액티브 프로그래밍은 어려울 수 있습니다. 하지만 핵심은 간단합니다. 

## Netflix

2015년 넥플릭스는 스트리밍 미디어에서 발생하는 엄청난 트랜픽을 처리해야 했습니다. 이  과정에서 RxJava 비동기 리액티브 라이브러리를 사용하게 되었고   아래와 같은 아키텍처를 만들어 라이브러리에 구현해야 했습니다. 

Ribbon
: 로드 밸런서를 지원하는 RPC 라이브러리
Zuul
: 동적 라우팅, 보안, 복원력, 모니터링 기능을 제공하는 게이트웨이 서비스
RxNetty
: NIO 클라이언트-서버 프레임워크인 네티의 리액티브 어댑터


오늘날 RxJava는 Couchbase와 MongoDB와 같은 일부 NoSQL 자바 드라이버에서도 사용되고 있습니다. 

# Reactive Stream

Reactive Stream은 스트림 처리의 새로운 표준입니다. 

리액티브 초기 단계에서 모든 라이브러리의 데이터 흐름은 소스에서 구독자로 푸시되는 방식이었다. 

푸시 방식의 단점은 프로듀서와 컨슈머의 성능에 따라 달아진다. 

따라서 컨슈머의 성능을 고려한 Back pressure 배압 제어 메커니즘이 중요하다 

## 기본 스펙

회사 내용 위키


# Reactor Project

리액티브 프레임워크 중에 가장 유명한 라이브러리인 리액터 프로젝트에 대해 알아보겠습니다. 

프로젝트는 처음부터 비동기 논블러킹 처리를 지원하기 위해 설계되었습니다. 추가적으로 리액터 패턴, 함수형 프로그래밍, 리액티브 프로그래밍과 같은 메세지 처리에 대한 모범 사례들을 통합해 만든 프로젝트 입니다. 

리액터 패턴
: 


* Version 1.x
	* 스프링 프레임워크와 완벽한 통합 및 네티와 결합으로 비동기 및 논블로킹 메세지 처리를 제공하는 고성능 시스템을 개발 가능하게 되었습니다. 
	* 하지만 1.x에는 단점이 있었습니다. 먼저 라이브러리에 배압 조절 기능(Back Pressure)이 없었습니다. 그리고 오류 및 실패처리가 상당히 복잡했습니다.

* Version 2.x
	* 가장 중요한 변화는 이벤트 버스 및 스트림 기능을 별도 모듈로 추출하였습니다. 그리고 새로운 리액터 스트림 라이브러리가 리액티브 스트림 스펙을 완벽히 준수하도록 핵심 모듈 까지 다시 설계하였습니다. 
* Version 3.x
	* 자바 8을 기준으로 재편되었습니다. 

## Features

리액리브 라이브러리는 비동기 파이프라인을 구축할때 콜백 지옥과 깊게 중첩된 코드를 생략하기 위한 목적이 있었습니다. 

```
 리액티브 응용 프로그램을 통해 처리된 데이터는 마치 조립 라인을 통히 이동하는 것과 유사하다. 리액터는 컨베이어 벨트와 워크스태이션의 역할이라 할 수 있다.
``` 

리액티브 라이브러리의 목표는  가독성을 높이고 정의된 워크플로에 좋은 조합을 추가하는 것입니다. 
워크 플로우란  다양한 종류의 연산자를 뜻합니다. 어셈블리 영역의 비유에서 이를 워크 스테이션이라 합니다. 

리액터 API는 연산자를 연결해서 사용하는 것을 권장합니다. 이로서 재사용가능한 실행 그래프를 작성할 수 있습니다. 실행 그래프는 실행 흐름만 정의하지만, 구독자가 실제로 구독을 만들때 까지 아무 일도 발생하지 않으므로 실제 구독했을때만 데이터 플로가 기동합니다. 

라이브러리는 상황에 따라 올바른 배압 전파 모드를 모두 지원합니다.

* 푸시전용(PUSH)
	* subscription.request(Long.MAX_VALUE) 
	* 최대한 가능한 만큼 발행자에게 데이터 요청
* 풀 전용(PULL)
	* subscription.request(1)
	* 구독자가 이전 요소를 받은 후에 다음요소를 호출하는 경우
* 풀-푸시
	* 구독자가 수요를 실시간 제어하고 발행자가 그에 적응 하는 경우

 
## Reactive Type

앞서 보았던 4가지 인터페이스의 실제 구현체를 차례대로 공부해보자. 

### Flux

Publisher의 구현체 입니다. 
FLUX는 0,1 또는 여러 요소를 가지는 일반적인 리액티브 스트림을 정의합니다. 무한대의 요소를 가질 수도 있습니다.

```
// 메서드 시그니처
onNext x 0..N [onError | onComplete]
```

명령형 프로그램에서는 무한한 데이터를 가진 컨테이너로 작업하는 게 흔치 않지만 함수형에서는 굉장히 흔합니다. 다음 코드는 무한대의 리액티브 스트림을 만듭니다.
1에서 5까지의 숫자를 반복적으로 생성합니다. 
```
Flux.range(1,5).repeat()
```

또한 구독자는 언제든 구독을 취소할 수 있고 효과적으로 무한 스트림을 유한 스트림으로 변환할 수 있습니다. 

### Mono

Publisher의 구현체 입니다.  최대 하나의 요소를 생성할 수 있는 스트리밍 입니다. 

```
// 메서드 시그니처 
onNext x 0..N [onError | onComplete]
```

Flux와 Mono의 차이는 버퍼 중복과 값비싼 동기화 작업을 생략하기 때문에 Mono가 더 효율적 입니다. 

결과적으로 봤을때 CompletableFutre<T>와 의미가 동일하기 때문에 비슷한 용도로 사용될 수 있습니다. 하지만 CompletableFutre는 즉시 처리를 시작하고 Mono는 구독자가 나타날때까지 아무 작업도 수행하지 않습니다. 

Mono의 이점은 리액티브 연산자를 더 많이 사용 가능하고, 더 큰 규모의 워크플로와도 완벽히 통합된다는 점입니다. 

Mono와 Flux는 서로 쉽게 변환됩니다. 
```
Mono.from(Flux.from(mono))
```

### Flux, Mono 스트림 만들기

Flux와 Mono는 데이터를 기반으로 리액티브 스트림을 만드는 많은 팩터리 메서드를 제공합니다.

```
Flux<String> stream1 = Flux.just("hello", "world");  
Flux<Integer> stream2 = Flux.fromArray(new Integer[]{1,2,3});  
Flux<Integer> stream3 = Flux.fromIterable(Arrays.asList(4,5,6));  
Flux<Integer> stream4 = Flux.range(2010, 9);  
  
Mono<String> stream5 = Mono.just("One");  
Mono<String> stream6 = Mono.justOrEmpty(null);  
Mono<String> stream7 = Mono.fromCallable(() -> httpRequest());  
Mono<String> stream8 = Mono.fromCallable(this::httpRequest);
```

Mono는 Http 요청이나 DB 쿼리와 같은 비동기 작업을 래핑하는데 유용합니다. fromCallable, fromRunnable, fromSupplier, fromFuture, fromCompleteStage 등의 메서드를 제공합니다. 
이 코드는 적절한 스케쥴러와 함께 HTTP 요청을 비동기적으로 만들뿐만 아니라 onError로 전파되는 오류도 함께 처리합니다.

```
Flux<String> empty = Flux.empty();  
Flux<String> never = Flux.never();  
Mono<String> error = Mono.error(new RuntimeException("Wrong Type"));
```

Flux와 Mono 모두 empty()라는 팩터리 메서드가 있습니다. 빈 인스턴스를 각각 생성합니다. 
never()라는 메서드도 있는데 이 스트림은 완료 메세지와 데이터, 오류에 대한 신호를 보내지 않음을 확실하게 합니다.
error(Throwable) 은 구독할때 각 구독자의 onError() 메서드를 통해 항상 오류를 전파하는 시퀀스를 생성합니다. 오류는 Flux또는 Mono선언 중에 생성되므로 각 구독자는 동일한 Throwable 인스턴스를 받게 됩니다. 

```
Mono<User> requestUserDate(String sessionId){
	return Mono.defer(() ->
		isValidSession(sessionId)
		? Mono.fromCallable(() -> requestUser(sessionId))
		: Mono.error(new RuntimeException("Invalid user session")));
// 위 코드는 실제 구독이 발생할때 까지 유효성 검사를 미루어 둡니다.
// 그러다 데이터가 들어오면 처리를 하게 됩니다.
Mono<User> requestUserDate(String sessionId){
	return isValidSession(sessionId)
		? Mono.fromCallable(() -> requestUser(sessionId))
		: Mono.error(new RuntimeException("Invalid user session"));
// requestUserDate 메서드가 호출될때 마다 유효성 검사를 수행합니다.
// 즉 실제 구독 이전에도 호출할 수 있습니다.(구독이 전혀 발생하지 않아도 가능)
}
```
defer는 지연하다, 연기하다라는 뜻입니다. defer는 구독하는 순간에 행동을 결정하는 시퀀스를 생성하는 메서드로, 
결과적으로 서로 다른 구독자에 대해 다른 데이터를 생성할 수 있습니다. 







## 스트림 시퀀스


## RxJava2의 리액티브 타입

RxJava 2 라이브러리와 리액터 프로젝트는 동일한 아이디어로 구현되었지만 형태가 다소 다릅니다. 간단하게 리액티브 타입의 차이를 짚고 가겠습니다.

Observable
: Back Pressure가 지원되지 않고, Publisher 인터페이스를 구현하지 않습니다. 그래서 직접적으로 리액티브 스트림 스펙과 호환되지 않습니다. 따라서 여러 요소를 다루는 스트림에서 조심해야 합니다. 반면 Flowable 타입보다 오버헤드가 적습니다. 사용자가 원하는 배압 전략을 적용해 Flowable타입으로 전환이 가능합니다. 

Flowable
: 리액터의 Flux와 동일한 역할을 하며, Publisher 인터페이스를 구현합니다.

Single
: 정확히 하나의 요소를 생성하는 스트림을 나타냅니다. Publisher 인터페이스를 구현하지 않습니다. toFlowable 메서드를 가지나 배압 전략이 필요 없습니다. 

Maybe
: Mono와 동일한 의도를 구현하기 위해 존재합니다. 하지만 Publisher를 구현하지 않기 때문에 스트림과 호환성이 없습니다. toFlowable이 존재합니다. 

Completable	
: 이 타입은 특이하게 onNext 신호를 생성할 수 없습니다. Publisher를 지원하지 않고 toFlowable을 지원합니다. 의미적으로는 onNext를 가질 수 없는 Mono(void)에 대응합니다. 

요약하자면, Flowable 타입만 리액티브 스트림과 호환됩니다. 






<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0NzUwNzA3OTQsMTY1OTYzMTU5Nyw3Nj
M2MzI3MSw2MDU0MzA0ODIsODA5Mzc0ODkwLC03OTUwMDgwMzIs
NTEzMzQ4NjY0LC0xMDA0MTE4ODI2LDIwNzgwOTc3NDEsLTE1OT
k0MTU2MzcsNjY1NTg5NTI2LDEyNDA0MjU0NjYsLTM4NjAzNjI5
LC0xMzM5MjE4Mzc3LC0xMTYwNjk5NTc3LDg4OTY2NDE5NCwxND
g0MTgxNTEsNzE4Mzc3ODIxLC0xMTI1NjE0Nzc0LC0xNTI4NDUx
NTE1XX0=
-->