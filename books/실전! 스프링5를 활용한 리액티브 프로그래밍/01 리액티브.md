# Reactive(반응성)?

리액티브(반응성)이란 용어를 최근 빈번하게 들을 수 있습니다. 리액티브란 프로그래밍 모델의 일종입니다. 보다 구체적으로 리액티브를 이해하기 위해선 탄력성과 복원력을 이해할 필요가 있습니다. 

시스템 구축시 예상하는 부하 수준이 있을 것인데,  특정 시점의 부하가 예상치를 아득히 뛰어넘는 경우가 있습니다. 이렇게 과부하 상황에서 서비스를 정상적으로 제공하지 못하면 회사에선 큰 피해를 입기 마련입니다. 과연 이런 문제를 어떻게 대응해야 할까요? 간단한 답은 **애플리케이션이 이러한 변화에 대응을 해야 합니다.**

좀 더 구체적으로는 애플리케이션에 탄력성(elasticity)을 부여하는 것입니다. 탄력성이란 작업 부하에서 응답성을 유지하는 능력. 즉 많은 사용자 요청이 들어올때는 탄력적으로 시스템 처리량이 늘어나야하고 수요가 감소하면 감소해야 한다는 것을 말합니다.  시스템 처리량을 늘릴려면 수평적 또는 수직점으로 확장을 통해 탄력성을 달성할 수 있습니다. 

**탄력성(Resilient):**  시스템이  [장애](https://www.reactivemanifesto.org/ko/glossary#Failure)  에 직면하더라도 응답성을 유지 하는 것을 탄력성이 있다고 합니다. 탄력성은 고가용성 시스템, 미션 크리티컬 시스템에만 적용되지 않습니다. 탄력성이 없는 시스템은 장애가 발생할 경우 응답성을 잃게 됩니다. 탄력성은  [복제](https://www.reactivemanifesto.org/ko/glossary#Replication), 봉쇄,  [격리](https://www.reactivemanifesto.org/ko/glossary#Isolation),  [위임](https://www.reactivemanifesto.org/ko/glossary#Delegation)에 의해 실현됩니다. 장애는 각각의  [구성 요소](https://www.reactivemanifesto.org/ko/glossary#Component)  에 포함되며 구성 요소들은 서로 분리되어 있기 때문에 이는 시스템이 부분적으로 고장이 나더라도, 전체 시스템을 위험하게 하지 않고 복구 할 수 있도록 보장합니다. 각 구성 요소의 복구 프로세스는 다른(외부의) 구성 요소에 위임되며 필요한 경우 복제를 통해 고가용성이 보장됩니다. 구성 요소의 클라이언트는 장애를 처리하는데에 압박을 받지 않습니다.

**유연성(Elastic):**  시스템이 작업량이 변화하더라도 응답성을 유지하는 것을 유연성이라고 합니다. 리액티브 시스템은 입력 속도의 변화에 따라 이러한 입력에 할당된  [자원](https://www.reactivemanifesto.org/ko/glossary#Resource)을 증가시키거나 감소키면서 변화에 대응합니다. 이것은 시스템에서 경쟁하는 지점이나 중앙 집중적인 병목 현상이 존재하지 않도록 설계하여, 구성 요소를 샤딩하거나 복제하여 입력을 분산시키는 것을 의미합니다. 리액티브 시스템은 실시간 성능을 측정하는 도구를 제공하여 응답성 있고 예측 가능한 규모 확장 알고리즘을 지원합니다. 이 시스템은 하드웨어 상품 및 소프트웨어 플랫폼에 비용 효율이 높은 방식으로  [유연성](https://www.reactivemanifesto.org/ko/glossary#Elasticity)  을 제공합니다.


그러나 장애 발생과 무관하게 응답성을 유지하는 능력을 갖추지 않고 확장 가능한 분산 시스템을 구축하는 것은 어렵습니다. 시스템에 대한 허용 기준은 시스템 실패에도 반응성을 유지할 수 있는 능력, 다시 말해서 시스템 본원력을 유지해야 합니다. 이는 시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성할 수 있습니다. 

예를 들어, 결제 서비스가 중단되어도 일단 사용자 주문을 접수하고 이후에 자동으로 재시도 함으로써 원치 않는 장애를 보호할 수 있습니다. 

탄력성과 복원력은 밀접하게 결합 되어 있으며, 이 두가지 모두를 달성해야 시스템의 진정한 응답성을 달성 할 수 있습니다. 

## 리액티브 선언문

![리액티브(Reactive) 시스템이란? | Kwangshin's Positive Blog](https://lh3.googleusercontent.com/proxy/cIbw6p8a5jRH-kUiN4hpn7JEH4sJA39kS5cjwYCPanPh5DTPozXkUF3ek_MS2n1pBM057zqA0yZIu7bawCoJj-qxugDQAXPBaKGe_JjnmLDDyOMmupkLR9oAT0ChsLgQzho)



> 리액티브 시스템에 대한 수요 증가로 스프링 클라우드(Spring Cloud)라는 새로운 프로젝트가 시작되었다. 스프링 클라우드 프레임워크는 몇 가지 문제점을 해결하고 분산 시스템 구축을 단순화하는 기반 프로젝트입니다. 



## [Future](http://wiki.webnori.com/display/AKKA/Future+and+Promice) 

Future(미래)와 Promice(약속)은 비동기처리에 있어서 중요한 개념입니다.

현재에서 미래로는 블록킹이 없기 때문에 어느시점 사용가능한 함수의 결과(성공또는 실패등을)를 담을수 있는 용기라고 보면 됩니다.

퓨쳐는 읽기전용이며, 퓨쳐에 담긴 값을 외부에서 변경할수 없습니다.
함수 실행이 끝나면 퓨쳐에 성공 또는 실패에 따른 결과가 들어갑니다. 
퓨쳐에 담긴 결과는 완료된 다음부터는 바뀌지 않으며, 외부에서 여러번 읽을수 있고 매번 같은 값을 돌려줍니다.

결과가 들어갈 용기가 있으므로 비동기적으로 실행되는 여러 함수들을 쉽게 조합할수가 있습니다.

@FunctionalInterface 
: 인터페이스의 목적 뿐만 아니라 컴파일러로 하여금 인터페이스 조건이 맞지 않으면 에러를 생성하도록 힌트를 줍니다. 단일 추상 메서드(SAM; Single Abstract Method)인 모든 인터페이스가 FunctionalInterface를 가지고 람다 표현식으로 처리가 될지도 모릅니다. 


```  
  //선언부  
  @FunctionalInterface  
  interface FuncB {  
        public int calc(int a, int b);  
  }  
  
    @FunctionalInterface  
  interface FuncA {  
        public int calc(int a);  
  }  
  
    //사용부  
  FuncA F1 = (int a) -> a + 1;  
  FuncA F2 = (int a) -> a + 1;  
  FuncA F3 = (int a) -> a + 1;  
  FuncB F4 = (int a, int b) -> a + b;  
  
  Integer input = 1;  
  CompletableFuture<Integer> futureB  
  = CompletableFuture.supplyAsync(() -> F1.calc(1));  
  
  CompletableFuture<Integer> futureD  
  = CompletableFuture.supplyAsync(() -> F3.calc(F2.calc(1)));  
  
  CompletableFuture<Void> combinedFuture  
  = CompletableFuture.allOf(futureB, futureD)  
            .thenAccept(r -> {  
                // 최종 연산로직을 비동기로 처리한 케이스  
  Integer value1 = futureB.join();  
  Integer value2 = futureD.join();  
  log(String.format("async result:%d", value1 + value2));  
  });  
combinedFuture.join(); //연산을 비동기적으로 시작하려면 join명령을 사용합니다.  
// 최종 연산로직을 동기처리로 변환한 예  
combinedFuture.get(); //동기처리로 진행하려면 get을 사용합니다.  
  Integer sresult = futureB.get() + futureD.get();  
  
  log(String.format("sync result:%d", sresult) );
```

## [CompletableFuture, Promise](https://www.hungrydiver.co.kr/bbs/detail/develop?id=2&scroll=comment)


프로미스와 퓨처 모두 미래의 어떤 결과를 가지고 있는 것 처럼 행동한다.
프로미스는 자바 8에서 CompletableFuture로 불린다. 

Promise
: A Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion.

포르미스는 퓨처의 일종으로 퓨처의 값이나 상태를 정하여 확실하게 완료가 될지도 모른다. 그리고 완성단계에서 완성을 위한 여러 의존 함수와 행동을 수행하는 트리거를 지원하는데 사용된다. 

사실 퓨처와 프로미스는 모두 비슷한 컨셉이다.

퓨처는 읽기 전용 컨테이너로 아직 존재하지 않는 결과를 담는다. 
반면에 프로미즈는 여러번 덮어 씌워질 수 있다. 프로미즈는 completed라는 상태를 가지며, Future 인터페이스를 구현하기 때문에 클라이언트 입장에서는 퓨처와 차이가 없다. 

퓨처의 결과는 비동기적으로 다른 쓰레드에서 계산된 결과로 미래에 채워진다. Callable 또는 Runnable을 이용해서 진행하고 결과는 읽기 전용이다.

프로미스의 결과는 어떤 쓰레드(일반적으로 스스로)에 의해서 결과가 채워진다. 왜냐하면 public  setter 메서드를 가지기 때문이다. 

CompletableFutre는 어떤작업에서도 생성될 수 있고 언제는 수정될 수 있다. 
프로미즈는 클라이언트에 제공하고 나중에 원하는 대로 수정할 수도 있다.


WebFlux를 사용하기 위해선 Reactive Streams를 이해할 필요가 있습니다.

Reactive Streams는  [reactive-streams.org](http://reactive-streams.org/)에서 아래와 같이 정의하고 있습니다.

Reactive Streams is a standard for asynchronous data processing in a streaming fashion with non-blocking back pressure.

> Reactive Streams은 논블로킹(Non-blocking), 백 프레셔(Back Pressure)를 이용한 비동기 데이터 처리의 표준이라고 이야기 합니다.

논블로킹(Non-blocking), 백 프레셔(Back Pressure)는 [LCS - Spring WebFlux - Introduction](https://wiki.linecorp.com/display/ContentsAI/LCS+-+Spring+WebFlux+-+Introduction)를 참고하시면 좋습니다.



# Publisher - Subscriber 패턴

**publihser - subscriber패턴**은 **observer 디자인 패턴**과 유사한 부분이 많다.
하지만 결코 같은 패턴이 아니라는 점을 유의하자. 

![](https://k.kakaocdn.net/dn/bqLWNV/btqBtFtFi9z/EwApKeBgffUuryMUlMpEIK/img.png)

![](https://k.kakaocdn.net/dn/cXQrI4/btqBtMTDnAn/KS6tHYZA7Qz7J5qSYz2O6K/img.png)

  
publisher-subscriber 패턴에서 메시지 송신자(publisher)는 정해진 수신자(specific receivers called subscriber)와 직접적 메시지를 통신하지 않는다. 그 둘 사이에 추가 구성요소가 있습니다. 이 구성요소는 이벤트 채널(메세지 브로커, 이벤트 버스)라고도 합니다. 

구독자는 알림이 오는 이벤트 채널을 알고 있지만, 발행자가 누구인지에는 신경쓰지 않습니다. 그리고 발행자는 다수가 될 수 있습니다. 

# RxJava의 역사 및 기본 개념

사실 RxJava는 자바 플랫폼에서 리액티브 프로그래밍을 위한 표준 라이브러리 였습니다. 그리고  RxJava가 사실상 자바 진영에 리액티브 프로그래밍의 길을 개척했습니다. 

RxJava 라이브러리는 ReactiveExtensions(ReactiveX)의 자바 구현체 입니다. 동기식 또는 비동기식 스트림에 관계없이 명령형 언어를 이용해 데이터 스트림을 조작할 수 있는 도구들 입니다. 

명령형 언어에 익숙하다면 리액티브 프로그래밍은 어려울 수 있습니다. 하지만 핵심은 간단합니다. 

## Netflix

2015년 넥플릭스는 스트리밍 미디어에서 발생하는 엄청난 트랜픽을 처리해야 했습니다. 이  과정에서 RxJava 비동기 리액티브 라이브러리를 사용하게 되었고   아래와 같은 아키텍처를 만들어 라이브러리에 구현해야 했습니다. 

Ribbon
: 로드 밸런서를 지원하는 RPC 라이브러리
Zuul
: 동적 라우팅, 보안, 복원력, 모니터링 기능을 제공하는 게이트웨이 서비스
RxNetty
: NIO 클라이언트-서버 프레임워크인 네티의 리액티브 어댑터


오늘날 RxJava는 Couchbase와 MongoDB와 같은 일부 NoSQL 자바 드라이버에서도 사용되고 있습니다. 

# Reactive Stream

Reactive Stream은 스트림 처리의 새로운 표준입니다. 

리액티브 초기 단계에서 모든 라이브러리의 데이터 흐름은 소스에서 구독자로 푸시되는 방식이었다. 

푸시 방식의 단점은 프로듀서와 컨슈머의 성능에 따라 달아진다. 

따라서 컨슈머의 성능을 고려한 Back pressure 배압 제어 메커니즘이 중요하다 

## 기본 스펙

회사 내용 위키


# Reactor Project

리액티브 프레임워크 중에 가장 유명한 라이브러리인 리액터 프로젝트에 대해 알아보겠습니다. 

프로젝트는 처음부터 비동기 논블러킹 처리를 지원하기 위해 설계되었습니다. 추가적으로 리액터 패턴, 함수형 프로그래밍, 리액티브 프로그래밍과 같은 메세지 처리에 대한 모범 사례들을 통합해 만든 프로젝트 입니다. 

리액터 패턴
: 


* Version 1.x
	* 스프링 프레임워크와 완벽한 통합 및 네티와 결합으로 비동기 및 논블로킹 메세지 처리를 제공하는 고성능 시스템을 개발 가능하게 되었습니다. 
	* 하지만 1.x에는 단점이 있었습니다. 먼저 라이브러리에 배압 조절 기능(Back Pressure)이 없었습니다. 그리고 오류 및 실패처리가 상당히 복잡했습니다.

* Version 2.x
	* 가장 중요한 변화는 이벤트 버스 및 스트림 기능을 별도 모듈로 추출하였습니다. 그리고 새로운 리액터 스트림 라이브러리가 리액티브 스트림 스펙을 완벽히 준수하도록 핵심 모듈 까지 다시 설계하였습니다. 
* Version 3.x
	* 자바 8을 기준으로 재편되었습니다. 

## Features

리액리브 라이브러리는 비동기 파이프라인을 구축할때 콜백 지옥과 깊게 중첩된 코드를 생략하기 위한 목적이 있었습니다. 

```
 리액티브 응용 프로그램을 통해 처리된 데이터는 마치 조립 라인을 통히 이동하는 것과 유사하다. 리액터는 컨베이어 벨트와 워크스태이션의 역할이라 할 수 있다.
``` 

리액티브 라이브러리의 목표는  가독성을 높이고 정의된 워크플로에 좋은 조합을 추가하는 것입니다. 
워크 플로우란  다양한 종류의 연산자를 뜻합니다. 어셈블리 영역의 비유에서 이를 워크 스테이션이라 합니다. 

리액터 API는 연산자를 연결해서 사용하는 것을 권장합니다. 이로서 재사용가능한 실행 그래프를 작성할 수 있습니다. 실행 그래프는 실행 흐름만 정의하지만, 구독자가 실제로 구독을 만들때 까지 아무 일도 발생하지 않으므로 실제 구독했을때만 데이터 플로가 기동합니다. 

라이브러리는 상황에 따라 올바른 배압 전파 모드를 모두 지원합니다.

* 푸시전용(PUSH)
	* subscription.request(Long.MAX_VALUE) 
	* 최대한 가능한 만큼 발행자에게 데이터 요청
* 풀 전용(PULL)
	* subscription.request(1)
	* 구독자가 이전 요소를 받은 후에 다음요소를 호출하는 경우
* 풀-푸시
	* 구독자가 수요를 실시간 제어하고 발행자가 그에 적응 하는 경우

 






<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwOTYxMjIzMCwtMjA1NjAxMDkwNl19
-->