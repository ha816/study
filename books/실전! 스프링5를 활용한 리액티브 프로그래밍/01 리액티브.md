# Reactive?

시스템 구축시 예상하는 부하 수준이 있을 것인데,  특정 시점의 부하가 예상치를 아득히 뛰어넘는 경우가 있습니다. 이렇게 과부하 상황에서 서비스를 정상적으로 제공하지 못하면 회사에선 큰 피해를 입기 마련입니다. 과연 이런 문제를 어떻게 대응해야 할까요? 간단한 답은 **애플리케이션이 이러한 변화에 대응을 해야 합니다.**

좀 더 구체적으로는 애플리케이션에 탄력성(elasticity)을 부여하는 것입니다. 탄력성이란 작업 부하에서 응답성을 유지하는 능력. 즉 많은 사용자 요청이 들어올때는 탄력적으로 시스템 처리량이 늘어나야하고 수요가 감소하면 감소해야 한다는 것을 말합니다.

> 리액티브 시스템에 대한 수요 증가로 스프링 클라우드(Spring Cloud)라는 새로운 프로젝트가 시작되었다. 스프링 클라우드 프레임워크는 몇 가지 문제점을 해결하고 분산 시스템 구축을 단순화하는 기반 프로젝트입니다. 



## [Future](http://wiki.webnori.com/display/AKKA/Future+and+Promice) 

Future(미래)와 Promice(약속)은 비동기처리에 있어서 중요한 개념입니다.

현재에서 미래로는 블록킹이 없기 때문에 어느시점 사용가능한 함수의 결과(성공또는 실패등을)를 담을수 있는 용기라고 보면 됩니다.

퓨쳐는 읽기전용이며, 퓨쳐에 담긴 값을 외부에서 변경할수 없습니다.
함수 실행이 끝나면 퓨쳐에 성공 또는 실패에 따른 결과가 들어갑니다. 
퓨쳐에 담긴 결과는 완료된 다음부터는 바뀌지 않으며, 외부에서 여러번 읽을수 있고 매번 같은 값을 돌려줍니다.

결과가 들어갈 용기가 있으므로 비동기적으로 실행되는 여러 함수들을 쉽게 조합할수가 있습니다.

@FunctionalInterface 
: 인터페이스의 목적 뿐만 아니라 컴파일러로 하여금 인터페이스 조건이 맞지 않으면 에러를 생성하도록 힌트를 줍니다. 단일 추상 메서드(SAM; Single Abstract Method)인 모든 인터페이스가 FunctionalInterface를 가지고 람다 표현식으로 처리가 될지도 모릅니다. 


```  
  //선언부  
  @FunctionalInterface  
  interface FuncB {  
        public int calc(int a, int b);  
  }  
  
    @FunctionalInterface  
  interface FuncA {  
        public int calc(int a);  
  }  
  
    //사용부  
  FuncA F1 = (int a) -> a + 1;  
  FuncA F2 = (int a) -> a + 1;  
  FuncA F3 = (int a) -> a + 1;  
  FuncB F4 = (int a, int b) -> a + b;  
  
  Integer input = 1;  
  CompletableFuture<Integer> futureB  
  = CompletableFuture.supplyAsync(() -> F1.calc(1));  
  
  CompletableFuture<Integer> futureD  
  = CompletableFuture.supplyAsync(() -> F3.calc(F2.calc(1)));  
  
  CompletableFuture<Void> combinedFuture  
  = CompletableFuture.allOf(futureB, futureD)  
            .thenAccept(r -> {  
                // 최종 연산로직을 비동기로 처리한 케이스  
  Integer value1 = futureB.join();  
  Integer value2 = futureD.join();  
  log(String.format("async result:%d", value1 + value2));  
  });  
combinedFuture.join(); //연산을 비동기적으로 시작하려면 join명령을 사용합니다.  
// 최종 연산로직을 동기처리로 변환한 예  
combinedFuture.get(); //동기처리로 진행하려면 get을 사용합니다.  
  Integer sresult = futureB.get() + futureD.get();  
  
  log(String.format("sync result:%d", sresult) );
```

## [CompletableFuture, Promise](https://www.hungrydiver.co.kr/bbs/detail/develop?id=2&scroll=comment)


프로미스와 퓨처 모두 미래의 어떤 결과를 가지고 있는 것 처럼 행동한다.
프로미스는 자바 8에서 CompletableFuture로 불린다. 

Promise
: A Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion.

포르미스는 퓨처의 일종으로 퓨처의 값이나 상태를 정하여 확실하게 완료가 될지도 모른다. 그리고 완성단계에서 완성을 위한 여러 의존 함수와 행동을 수행하는 트리거를 지원하는데 사용된다. 

사실 퓨처와 프로미스는 모두 비슷한 컨셉이다.

퓨처는 읽기 전용 컨테이너로 아직 존재하지 않는 결과를 담는다. 
반면에 프로미즈는 여러번 덮어 씌워질 수 있다. 프로미즈는 completed라는 상태를 가지며, Future 인터페이스를 구현하기 때문에 클라이언트 입장에서는 퓨처와 차이가 없다. 

퓨처의 결과는 비동기적으로 다른 쓰레드에서 계산된 결과로 미래에 채워진다. Callable 또는 Runnable을 이용해서 진행하고 결과는 읽기 전용이다.

프로미스의 결과는 어떤 쓰레드(일반적으로 스스로)에 의해서 결과가 채워진다. 왜냐하면 public  setter 메서드를 가지기 때문이다. 

CompletableFutre는 어떤작업에서도 생성될 수 있고 언제는 수정될 수 있다. 
프로미즈는 클라이언트에 제공하고 나중에 원하는 대로 수정할 수도 있다.


WebFlux를 사용하기 위해선 Reactive Streams를 이해할 필요가 있습니다.

Reactive Streams는  [reactive-streams.org](http://reactive-streams.org/)에서 아래와 같이 정의하고 있습니다.

Reactive Streams is a standard for asynchronous data processing in a streaming fashion with non-blocking back pressure.

> Reactive Streams은 논블로킹(Non-blocking), 백 프레셔(Back Pressure)를 이용한 비동기 데이터 처리의 표준이라고 이야기 합니다.

논블로킹(Non-blocking), 백 프레셔(Back Pressure)는 [LCS - Spring WebFlux - Introduction](https://wiki.linecorp.com/display/ContentsAI/LCS+-+Spring+WebFlux+-+Introduction)를 참고하시면 좋습니다.


beta-tropicana-proxy002-ccs-jp2v-dev







> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTc3MTk1OTcxXX0=
-->