# DevOps 친화적인 앱의 중요성

모든 소프트웨어는 세 가지 관점에서 볼 수 있습니다. 각 관점은 시스템과 상호작용하는 사용자들의 요구사항을 보여줍니다.

소프트웨어 시스템을 운영 측면에서 보면, 데브 옵스 구성원이 운영 환경의 시스템을 지원/유지 보수하는 것이 쉽다면 그 시스템을 DevOps 친화적이라고 표현합니다. 

DevOps한 시스템은 시스템의 상태 점검 및 운영 지표를 제공하고 성능을 측정할 수 있는 방법을 가져야 하며, 서로 다른 컴포넌트를 유연하게 업데이트할 수 있어야 한다는 의미입니다. 

오늘날의 마이크로 서비스 아키텍처는 범용 소프트웨어 개발 기술이기 때문에 클라우드에 배포할 수 있도록 적절한 모니터링 기능을 갖춰야 합니다. 제대로 된 모니터링 인프라가 없다면 소프트웨어는 운영환경에서 며칠이상 생존할 수 없을 것 입니다. 

클라우드 환경에 애플리케이션을 배포할 수 있게 되면서 복잡한 소프트웨어 설계도 쉽게 적용 가능한 인프라를 제공하게 되고, 이로 인해 소프트웨어 설치 및 운영 프로세스가 단순화되고 누구나 쉽게 소프트웨어를 설치하고 운영할 수 있게 되었습니다. 

Iaas, PaaS 및 쿠버네티스와 같은 컨테이너 관리 시스템은 OS 및 네트워크 구성, 파일 백업, 메트릭 수집과 관련된 많은 골칫 거리를 제거했으며, 자동 확장을 비롯해 많은 기능을 제공합니다. 그러나 이러한 외부 서비스 및 기술을 사용하면 비즈니스 응용 프로그램이 가지는 서비스 품질이 외부 요인에 의존해 조직 스스로 결정하지 못하게 됩니다. 게다가 클라우드 공급자는 설치된 시스템이 수행하는 작업에 따라 리소스가 효율적으로 사용되는지 확약 할 수 없습니다. 이러한 책임은 여전히 개발자와 데브옵스 팀에 달려 있습니다. 

## 운영을 효율적으로 하기 위해 고려할 사항

성공적인 운영을 위해선 아래 사항을 만족하는 기법들이 모두 필요합니다. 그게 아니더라도 운영팀에서는 모든 것을 원하게 됩니다. 다행스럽게도 스프링에서는 스프링 부트 actuator를 제공합니다. 스프링 부트 actuator를 사용하면 일반적인 서블릿 기반 애플리케이션에 대해 쉽게 적용할 수 있고 리소스도 많습니다. 하지만 리액티브의 경우 아직 보편적인 기술이 아니다보니 기법을 사용하는데 코드를 수정하거나 전혀 다른 접근법이 필요 할 수 도 있습니다. 

그렇지만 리액티브로 구현된 서비스를 운영하는 것이 일반적인 서블릿 기반의 동기식 서비스를 운영하는 것과 다르지 않아야 합니다. 서비스 운영은 12팩터 앱방법론을 따라야 하고 데브옵스 친화적이어야 하며 운영 및 개선이 쉬워야 합니다. 

### 서비스 식별

서비스 식별은 마이크로서비스 아키텍처의 필수 요소 입니다. 대부분 쿠버네티스와 같은 오케스트레이션 시스템이 여러 노드에 서비스 인스턴스를 생성하고 클라이언트 수요 증감에 따라 노드의 개수를 늘리거나 줄이기 때문에 반드시 필요합니다. 

컨테이너 실행 가능한 JAR파일은 일반적으로 의미 있는 이름을 가지고 있지만, 실행 시점에 소스 코드의 서비스 이름, 종류, 버전, 빌드 시간 및 커밋 리비전 등을 식별할 수 있어야 합니다. 그로 인해 운영환경에 올바르지 않거나 버그가 있는 서비스 버전을 식별 할 수 있어야 합니다. 그로 인해 운영환경에서 올바르지 않거나 버그가 있는 서비스 버전을 찾아 내어 회귀 테스트를 통해 변경사항을 추적하고 동일한 다른 버전과의 성능 지표를 자동으로 추적/비교 할 수 있습니다.

런타임에 각 서비스를 구별할 수 있다면, 모든 서비스가 정상적으로 동작하는지도 알고 싶을 것 입니다. 또한 서비스가 비정상 도앚ㄱ한다면 서비스가 얼마나 중요하고 핵심적인 역할을 하는지 알고 싶을 것입니다. 서비스 상태 검사 엔드포인트는 때때로 오케스트레이션 시스템에서 실패한 서비스를 식별하고 서비스를 재시작하는데 사용합니다.(Resilient)

이분법적으로 정상, 비정상 두가지 상태만 있는 것은 아닙니다. 대부분 상태에서 검사에 대한 전체적인 성능 측정치를 제고앟지만, 측정치 중 일부는 중요하지 않습니다. 

전반적인 상태를 계산할때는 큐 크기, 오류율, 사용 가능한 디스크 공간 및 메모리 처리에 따라 상태가 다르게 계산 될 수 있습니다. 전반적인 상태를 계산할때는 필수 측정 항목만으로 판별하는 것이 바람직합니다. 중요치 않은 측정치를 상태 계산에 포함하게 되면 상태가 정상인지 아닌지 판단하기 어려워질 수 있습니다. 

일반적으로 상태를 체크하는 것은 해당 서비스가 요청을 받아 들일 수 있는 수준이 되는지 아닌지를 의미합니다. 이 특성은 컨테이너의 관리 시스템에서 서비스 가용성을 확인해 서비스를 재시작할지 판단하는데 결정적입니다. 

### 서비스 상태 확인

서비스가 잘 동작하고 있는 상태에서도 시스템의 내부사항을 자세히 알고 싶을때가 있습니다. 훌륭한 시스템은 컴포넌트가 잘 동작할 뿐만 아니라 사용자가 예측 가능한 방식으로 작동합니다. 

시스템의 주요 메트릭에는 평균 응답시간, 오류율 및 과부하 상황에서 요청을 처리하는데 걸리는 시간 등이 있습니다. 과부하 상황에서 시스템이 어떻게 동작하는지ㅣ 이해하면 시스템을 적절히 확장할 수 있을 뿐만아니라 인프라 비용에 대한 적절한 계획을 수립할 수 있습니다. 부적절하게 병목을 야기하는 코드, 비효율적인 알고리즘 및 확장성을 제한하는 요인을 찾아 낼 수도 있습니다. 

### 운영 메트릭 모니터링

운영 메트릭은 시스템의 현재 상태에 대한 스냅샷을 제공하고 많은 가치를 제공합니다. 지속해서 수집하면 추세 및 경향성을 제공하고 가동 시간에 따른 서비스 메모리 사용량과 같은 상호 연관 관계가 있는 특성에 대해 통창력을 제공할 수 있습니다. 

통계 보고서를 만드는 것은 많은 서버 리소스를 소비하지 않지만, 시간에 따른 누적된 기록을 유지하려면 별도의 시계열 데이터베이스가 필요합니다. 이런 시계열 데이터베이스로는 Graphite, Prometheus등이 있습니다. 

시계열자료를 효율적으로 시각화 하고 긴급한 상황에서 경고 또는 알람을 설정하려면 Grafana, Zabbix와 같은 모니터링 소프트웨어가 좋습니다. 몇몇 클라우드 플랫폼은 종종 유사한 서비스를 이미 제공하고 있습니다. 

### 로그를 살펴보고 로그 수준 동적 변경

서비스 운영을 모티러링하고 장애 상황을 점검할때 데브옵스팀은 로그를 활용합니다. 요즘 모든 애플리케이션 로그는 한 위치에 저장하거나 시스템을 이용해 분석할 수 있어야 합니다. 이를 위해 자바 생태계에서는 ELK 스택(Elastic Search, LogStash, Kibana) 구성이 가장 널리 사용됩니다. 이러한 소프트웨어 스택은 수십개의 서비스를 하나의 시스템으로 취급할 수 있지만, 네트워크를 통해 로그를 전송하거나 모든 로그를 저장하는 것은 매우 비효율적입니다. 
일반적으로 INFO 레벨 이상의 로그를 저장하는 것으로 충분하고 DEBUG 또는 TRACE 레벨은 반복적인 이상이나 오류를 조사하는 경우만 일시적으로 수집합니다. 동적으로 로그 레벨을 변경하기 위해서 사용하기 번거롭지 않은 수준의 인터페이스를 제공해야 합니다. 

### 사용자 요청 또는 데이터 흐름 추적

로그가 전체 내용을 표현할 정도로 충분치 않다면 고달픈 디버깅 작업을 하기전 최후의 수단으로 소프트웨어 내부 프로세스를 추적할 수도 있습니다. 프로세스를 추적하는 작업은 최근 서버 요청에 대한 자세한 로그를 살펴보는 일, 대기시간, DB 요청, 각각의 소요시간 관련한 외부 호출등을 포함해 전체적인 구조와 흐름을 따라가는 일도 있습니다. 

이러한 추적은 요청 처리를 실시간으로 시각화 하는데 매우 유용하며 소프트웨어 성능을 향상 시키기에는 필수적입니다. 분산형 추적 시스템은 모든 요청, 메세지, 네트워크 지연, 오류등을 추적할 수 있습니다. 대표적으로 스프링 클라우드 슬루스 및 집킨이 있습니다. 

# 리액티브 스프링 애플리케이션 모니터링

스프링 프레임워크는 데브옵스에 친숙한 애플리케이션을 만드는 도구를 제공합니다. 이 도구 모음은 스프링 부트 엑추에이터라고 합니다. 스프링 부트 의존성을 하나 추가하는 것만으로 중요한 기능을 사용할 수 있습니다. 동시에 모니터링 인프라 측면에서 중요한 기본 뼈대를 제공합니다.

## Spring Boot Actuator

스프링 부트 엑추에이터는 스프링 부트 애플리케이션 운영을 위한 기능을 제공하는 스프링 부트의 서비스 프로젝트입니다. 이 프로젝트는 서비스 정보, 상태 확인, 메트릭 수집, 트래픽 추적, 데이터 베이스 상태 확인 등이 포함됩니다. 부트 엑추에이터의 핵심 아이디어는 애플리케이션 운영에 필요한 필수 메트릭을 제공하고 확장을 쉽게 할 수 있도록 도와주는 것 입니다. 

부트 엑추에이터는 HTTP 엔드 포인트와 JMX 빈을 이용해 많은 운영 정보를 제공하므로 다수의 모니터링 소프트웨어와 완벽한 통합이 가능합니다. 

HTTP 엔드포인트란 보통 Restful API의 URL을 의미합니다. 사전적인 의미로 엔드포인트는 클라이언트 애플리케이션에서 접근 가능한 서비스 URL을 말합니다.

기본적으로 액추에이터는 /actuator URL이하의 엔드포인트를 사용하지만 변경할 수도 있습니다. 

### info 엔드포인트

기본적으로 스프링 엑추에이터는 시간에 따라 시스템 모니터링, 확장 및 개선에 필요한 중요정보를 제공합니다. 애플리케이션 설정에 의해 달라질수도 있지만, 실행 파일에 대한 정보 및 Git 정보를 제공합니다. 물론 필요하면 추가 정보를 더 포함할 수 도 있습니다. 

/actuator/info 엔드포인트는 애플리케이션 정보를 표시합니다. 이 엔드포인트는 기본적으로 사용하도록 설정되어 있고 management.endpoint.info.enabled 속성으로 활성/비활성화 할 수 있습니다. 

스프링 부트 엑추에이터는 기본적으로 리액티브 또는 비동기 API를 제공하지 않기 때문에 리액티브 서비스에 대한 엔드포인트도 블로킹 서비스 입니다. 

### health 엔드포인트

시스템 모니터링을 위해 중요한 것은 서비스 상태를 확인하는 기능입니다. 가장 단순하게 접근하면 서비스 상태는 서비스가 요청에 응답하는가에 대한 답변으로 해석할 수 있습니다. 중요한 문제가 하나 있다면 네트워크를 통해 액세스를 해야한다는 점이 단점입니다. 그러나 하드 드라이브, 데이터베이스 또는 종속된 서비스와 같은 일부 중요한 구성 요소 중 하나에 엑세스할 수 없을 수도 있습니다. 이 때문에 완전히 정상상태라고 말할 수 없습니다. 

운영 관점에서 보면 상태 확인은 단순히 서비스가 살아 있는지를 확인하는 것 이상을 의미합니다. 우선 정상적인 서비스라면 모든 하위 컴포넌트가 정상적이며 사용 가능한 상태여야 합니다. 또한 상태 정보는 운영팀이 가능한 빨리 장애의 잠재적 위험에 대응할 수 있도록 모든 세부 정보가 포함되어야 합니다. 데이터베이스를 사용할 수 없거나 디스크 여유 공간이 부족하면 데브옵스가 즉시 해당 조치를 취할수 있어야 합니다. 따라서 상태 정보에는 연관된 자원에 대한 자세한 내용도 포함되어야 합니다. 

스프링 부트 액추에이터는 상태 모니터링에 대한 제대로된 접근 방식입니다. 서비스 상태에 대한 필수적인 세부 정보는 /actuator/health 엔드 포인트를 통해 접근할 수 있습니다. 이 엔드포인트는 기본적으로 사용가능하게 설정되어 있습니다. 또한 스프링 부트 액추에이터는 스프링 생태계에 통합된 카산드라, 몽고DB, JMS 및 기타 주요 서비스에 대한 광범위한 상태표시를 포함합니다. 

내장된 상태 지표와 함께 HealthIndicator를 직접 구현해 추가 정보를 제공할 수 있습니다. 아울러 스트링 부트 액추에이터 2.0의 흥미로운 부분은 스프링 웹플럭스 및 리액터 3와 통합입니다. 이러한 통합을 통해 ReactiveHealthIndicators라는 상태 지표에 대한 리액티브 인터페이스를 제공합니다. 

```
@Component
class batteryHealthIndicator implements ReactiveHealthIndicator {
	
	@Ovverride
	public Mono<Health> health() {
		if(...) {
			return new Health.Builder().up().withDetail("level", level).build();
		} else {
			return new Health.Builder().status(newStatus("Low Batter")).withDetail("level", level).build())
		}
		...
	}
	
}
```

ReactiveHealthIndicator 인터페이스를 구현하면 Battery 상태를 알려주는 인디케이터를 만들수 있습니다. health() 메서드를 구현합니다. 사실 상태 정보를 확장하거나 정해진  UP, DOWN, OUTOFSERVICE, UNKNOWN만 선택하도록하는 몇 가지 모드가 있습니다. 사용할 수 있는 옵션에 대해선 문서를 확인합시다. 

### metrics 엔드포인트

애플리케이션을 모니터링 하기 위해선 운영 메트릭을 수집하는 것 입니다. 당연히 스프링 부트 액추에이터도 이를 지원하고 있으며 프로세스 가동 시간, 메모리 사용량, CPU 사용량 및 GC 일시 중이와 같은 JVM 특성을 모니터링 합니다. 또한 웹 플럭스는 HTTP 요청 처리와 관련된 몇 가지 통계를 제공합니다. 그러나 비즈니스 과점에서 서비스 내부 상황에 대해 의미 있는 통찰을 제공하려면 직접 운영 메트릭을 확장해야 합니다. 

스프링 부트 2.0부터 액추에이터에서 메트릭 수집에 사용되는 기본 라이브러리가 마이크로미터 라이브러리로 변경되었습니다. (micrometer.io)

/actuactor/metrics REST 엔드 포인트는 제공하는 메트릭 목록을 제공하고, 원하는 측정 항목 및 시간대를 변경해가면서 태그의 형태로 컨텍스트 정보를 제공해줍니다.

기본적으로 actuator/metrics 엔드포인트는 기본적으로 노출되어 있지 않습니다. 기본 설정으로는 info와 health만 노출합니다. 따라서 application propery의 management.endpoints.web.exposure.include 속성에 모든 엔드포인트를 추가해야 합니다.

### loggers 

스프링 액추에이터는 로그 관리를 위한 두개의 중요한 엔드포인트를 제공합니다. 첫번째는 /actuator/loggers로 애플리케이션을 다시 시작하지 않고도 런타임에 로깅 레벨을 확인하고 변경할 수 있습니다. 서비스 재시작 업이 로그 레벨을 전환하는 것이 애플리케이션 운영에 필수적이기 때문에 이 엔드포인트는 매우 유용합니다. 

리액티브 애플리케이션을 운영하면서 복잡한 디버그 경험을 해본 사람이면 로그 레벨을 전환해 즉시 결과를 분석할수 있다는 것이 얼마나 중요한지 알 수 있습니다.

리액티브 앱 기반에서 설명한 리액터 log() 연산자를 사용해 동적으로 생성된 로그를 활성화 또는 비활성화 할 수 있습니다. 

### 그밖에 유용한 엔드포인트

* configprops 
	* 애플리케이션 설정 정보를 확인이 가능할 수 있다.
* env
	* 환경변수에 엑세스할 수 있다. 
* mappings
	* 애플리케이션의 열려 있는 모든 웹 앤드포인트에 대한 정보를 제공합니다.
* httptrace
	* 서버쪽과 클라이언트쪽에서 기록된 HTTP 상호작용에 대해 정보를 제공합니다.
* auditevents
	* 애플리케이션에 대한 감사 이벤트에 대한 정보를 제공합니다. 
* beans
	* 스프링 컨텍스트에서 사용 가능한 빈 목록을 제공합니다
* caches
	* 애플리케이션 캐시에 대한 정보를 제공합니다.
* sessions
	* 활성 HTTP 세션 목록을 제공합니다
* threaddump 
	* 애플리케이션 JVM에 대한 스레드 덤프를 볼 수 있습니다.
* heapdump
	* 힙 덤프를 생성하고 내려발을 수 있습니다. 

## 마이크로미터(Micrometer)

스프링부트 2.0부터 스프링 프레임워크는 메트릭수집에 사용되는 기본 라이브러리를 변경했습니다. 이전에는 드롭 위저드 메트릭을 사용했지만, 이제는 마이크로 미터라는 새로운 라이브러리를 사용합니다. 

마이크로미터는 외부 의존성을 최소화한 독립형 라이브러리입니다. 이 라이브러리는 별도의 프로젝트로 개발됬지만, 스프링 프레임워크에서 사용을 주 목표로 사용하고 있습니다. 라이브러리는 가장 널리 사용되는 모니터링 시스템에 대한 퍼사드(facade) 패턴을 제공합니다.  마이크로미터는 SL4J가 로깅을 위한 API를 제공하는 것과 같은 방법으로, 벤더 중립적인 모니터링 API를 제공합니다. 

현재 마이크로미터는 프로메테우스(Prometheus), 인플럭스(Influx), 넷플릭스 아틀라스(Atlas) 및 여덟 가지 모니터링 시스템과 훌륭하게 통합되어 있습니다. 또한 외부 모니터링 시스템 없이도 라이브러리를 사용할 수 있도록 임베디드 메모리 저장소에 메트릭을 저장도 가능합니다. 

마이크로 미터는 이름 외에 각 메트릭이 키/값 태그를 이용해 다차원 메트릭을 지원할 수 있습니다. 이런 접근 방식을 사용하면 집계된 값을 개략적으로 볼 수 있으며, 필요한 경우 태그를 통해 상세 메세지를 볼 수 있습니다. 

스프링 부트 액추에이터는 /actuator/metrics 엔드포인트를 통해 마이크로 미터를 사용해 집계된 애플리케이션 메트릭을 서비스 합니다. 액추에이터 모듈을 사용하면 기본적으로 MeterRegistry 타입의 빈을 자동으로 생성합니다. MeterRegistry는 모든 메트릭이 저장되는 방법과 세부사항을 정의하고 클라이언트 코드로부터 보호하는 마이크로미터 인터페이스 입니다. 

예를 들어, Prometheus 지원을 위해 애플리케이션은 PrometheusMeterRegistry 클래스를 인스턴스화하여 사용해야 합니다.

### 리액티브 스트림 모니터링 하기

리액터 프로젝트는 마이크로미터 라이브러리 없이도 잘 동작하지만, 클래스 패스에 마이크로미터가 있으면 애플리케이션 동작에 대한 중요한 내용을 볼 수 있는 몇 가지 메트릭을 보여줍니다. 

Flux와 Mono 타입에는 metrics() 연산자가 있습니다. 이 연산자를 이용하면 스트림과 관련된 운영 메트릭을 볼 수 있습니다. metrics() 연산자는 log() 연산자와 비슷하게 동작합니다. name() 연산자와 함께 사용하면 메트릭이름을 만들고 태그를 추가할 수 있습니다. 

```
@GetMapping(path= "/stream", produces = MediaType.TEXTEVNETSTREAMVALUE)
	public Flux<Temperature> events() {
		return temperatureSensor.temperatureStream().name("temperatureStream").metrics();
	}
}
```
위 temperatureStream은 Flux<Temperature>를 반환하고 name("temperatureStream") 메서드는 모니터링 지점 지표에 대한 이름을 추가합니다. metrics() 메서드는 MeterRegistry 인스턴스에 새 메트릭을 등록합니다. 

그 결과로 리액터 라이브러리는 reactor.subscribed, reactor.requsted라는 두 카운터와 reactore.flow.duration, reactor.onNext.delay라는 두 타이머를 등록해줍니다. 

### 리액터 스케쥴러 모니터링하기

리액티브 스트림은 일반적으로 서로 다른 리액터 스케줄러에서 작동하기 대문에 각 동작에 관한 세분화된 메트릭을 추적하는 것이 좋습니다. 



# 스프링 클라우드 슬루스를 사용한 분산 추적

성공적인 리액티브 시스템 운영을 위한 또 다른 중요한 요소는 서비스에서 이벤트가 어떻게 전달되는지, 요청이 어떻게 쌓이는지, 그리고 쌓인 요청을 해소하는데 얼마나 오래 걸리는지를 확인하는 것 입니다. 

서비스간의 통신은 분산 시스템의 필수적인 부분이며, 문제가 발생했을때 데이터 흐름에 대한 전체적인 이해 없이는 해결할 수 없습니다. 하지만 분산 시스템에서 통신의 복잡성을 고려하면 모든 데이터 흐름에 대해 이해하는 것은 매우 복잡합니다. 스프링 클라우드에서는 Spring-cloud-sleuth라는 훌륭한 모듈이 있습니다. 스프링 슬루스는 스프링 부트인프라와 완벽하게 통합된 프로젝트로, 자동 설정을 위해 몇 가지 추가하는 것으로도 분산형 추적이 가능해집니다. 

우선 TraceWebFilter라는 웹플럭스용 필터가 WebMVC필터를 완벽히 대체합니다. 이 필터는 시스템으로 유입되는 http 요청을 분석하고 추적을 위한 헤더가 발견되면 즉시 집킨에 보고합니다. 









> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjQxODA3MDg2LDU1MTc3NTEyOSwtNDg0Nz
E4ODEyLDE1MTM0MDQ0Nyw1NzU0ODIxMjgsLTE4NTgxNjIxOTks
LTE5NTE5Mzg0ODksLTEwODg4MjIyMjAsLTE4NDA3NTMyMTgsLT
IyNzI4NDY3NywxNDA3ODk2NDUxLC03NDg5NTEzOTQsMTkxMzQw
MTAzOCwzOTQwMjA1OTQsMTcyODQwMTI0OCwyMDI4MjIyNjYwLC
0yNTMzNTk2MCwxMzcwNTQ2MzAwLC01NzI5MzYxMzgsNjQyMjk4
MDc2XX0=
-->