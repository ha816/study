# Overview

이제 리액티브 스트림의 생명 주기, 멀티 스레딩, 리택터 프로젝트의 내부 최적화 동작 방식을 자세히 공부해 봅시다. 


# 스트림 생명 주기

## Assembling(조립 단계)

언뜻보면 리액터가 제공하는 API는 처리 흐름에 사용하는 연산자를 조합한 빌더 API 처럼 보입니다. 빌더 패턴은 가변적인 임시 객체 정보를 가지고 있다가 , 객체 생성을 위해선 build와 같은 최종함수를 호출해야 합니다. 그러나 리액터 API는 가공 결과로 불변 객체를 제공합니다. 즉 불변성을 위해 각 연산자가 새로운 객체를 생성합니다. 

리액티브 스트림 실행 흐름을 계획하고 구성하는 단계를 조립 단계라고 합니다. 이 단계에서는 스트림의 타입을 확인해 연산자를 바꾸어 성능 향상 이루거나 몇 가지 훅을 사용하여 디버깅이나 모니터링, 메트릭 수집등의 기능을 사용할 수 있습니다. 

예를 들면 아래와 같이 FluxConcatArray(FluxA, FluxB, FluxC)로 동작하여 성능향상을 꾀합니다.
```
FluxConcatArray(FluxConcatArray(FluxA, FluxB), FluxC)
FluxConcatArray(FluxA, FluxB, FluxC)
```

## Subscription(구독 단계)

구독은 특정 Publisher를 구독할때 발생합니다. 예를 들어 아래 코드는 앞에서 만든 실행 플로를 구독합니다. 

```
...
filteredFlux.subscribe(...); // 앞서 만든 실행플로 구독하기 
```

실행 플로를 만들기 위해 내부적으로 Publisher를 다른 Publisher에 전달합니다 . 즉 일련의 Publisher 체인이 있습니다.

먼저 최상위 래퍼를 구독하면, 

## Runtime(런타임 단계)






> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTMxNDUyNTMwOCwxMjUzNjg2NjEzXX0=
-->