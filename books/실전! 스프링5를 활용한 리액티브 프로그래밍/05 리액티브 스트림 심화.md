# Overview

이제 리액티브 스트림의 생명 주기, 멀티 스레딩, 리택터 프로젝트의 내부 최적화 동작 방식을 자세히 공부해 봅시다. 


# 스트림 생명 주기

## Assembling(조립 단계)

언뜻보면 리액터가 제공하는 API는 처리 흐름에 사용하는 연산자를 조합한 빌더 API 처럼 보입니다. 빌더 패턴은 가변적인 임시 객체 정보를 가지고 있다가 , 객체 생성을 위해선 build와 같은 최종함수를 호출해야 합니다. 그러나 리액터 API는 가공 결과로 불변 객체를 제공합니다. 즉 불변성을 위해 각 연산자가 새로운 객체를 생성합니다. 

리액티브 스트림 실행 흐름을 계획하고 구성하는 단계를 조립 단계라고 합니다. 이 단계에서는 스트림의 타입을 확인해 연산자를 바꾸어 성능 향상 이루거나 몇 가지 훅을 사용하여 디버깅이나 모니터링, 메트릭 수집등의 기능을 사용할 수 있습니다. 

예를 들면 아래와 같이 FluxConcatArray(FluxA, FluxB, FluxC)로 동작하여 성능향상을 꾀합니다.
```
FluxConcatArray(FluxConcatArray(FluxA, FluxB), FluxC)
FluxConcatArray(FluxA, FluxB, FluxC)
```

## Subscription(구독 단계)

구독은 특정 Publisher를 구독할때 발생합니다. 예를 들어 아래 코드는 앞에서 만든 실행 플로를 구독합니다. 

```
...
filteredFlux.subscribe(...); // 앞서 만든 실행플로 구독하기 
```

실행 플로를 만들기 위해 내부적으로 Publisher를 다른 Publisher에 전달합니다 . 즉 일련의 Publisher들로 구성된 체인이 있습니다.  Publisher들이 일련의 체인으로 묶여있기 때문에,  각 Publisher마다 대응하는 Subscriber를 만들고 다시 Subscriber를 체인으로 묶음으로써 Subscriber의 구독 전파가 가능해집니다.

먼저 최상위 Publisher(filteredFlux)를 구독하면, 해당 모든 Publisher 체인의 구독 프로세스가 시작됩니다. 

```
filteredFlux.subscribe(Subscriber){
	mapflux.subscribe(new FilterSubscriber(Subscriber)){
		arrayFlux.subscribe(new MapSubscriber(FilterSubscriber(Subscriber))) {
			... //실제 데이터 송신 시작
			// array -> map -> filtered
		}
	}
}
```
Publisher 체인을 따라 subscribe()가 전파가 되기 때문에, 다음 체인의 Subscriber 생성자에 자기 자신을 파라미터로 전달하고, 그에 따라 Publisher 체인과는 반대 순서로 체인이 형성됩니다.
```
ArraySubscriber(
    MapSubscriber(
        FilterSubscriber(
            Subscriber
        )
    )
)
```

구독 단계는 앞서 조립단계(Assembling)과 유사하게 성능 향상을 꾀할 수 있습니다. 
멀티스레딩을 지원하는 일부 리액티브 연산자로 구독 작업자(워커; Subscriber)를 변경할 수 있습니다. 이 변경은 구독단계에서 Subscriber 체인 생성 과정에서 이루어집니다. 

## Runtime(런타임 단계)

이 단계에서 Publisher와 Subscriber가 onSubscribe() 시그널과 request() 시그널을 교환하면서 스트림 시작됩니다. 앞서 구독단계에서 보았던 예제에서 최상위 Subscriber는 ArraySubscriber이고 거기서부터 onSubscribe()가 전파됩니다.

```
MapSubscriber(FilterSubscriber(Subscriber)).onSubscribe(
    new ArraySubscription
) {
    FilterSubscriber(Subscriber).onSubscribe(
        new MapSubscription(ArraySubscription(...))
    ) {
        Subscriber.onSubscribe(
            FilterSubscription(MapSubscription(ArraySubscription(...)))
        ) {
            // 데이터 요청
        }
    }
}
```

모든 구독자 체인(ArraySubcriber -> MapSubscriber -> FilterSubscriber)을 통과하고

이 과정을 통해 다시 한 번 Subscription의 체인이 다음과 같이 형성된다.

```
FilterSubscription(
    MapSubscription(
        ArraySubscription()
    )
)
```

위 체인을 따라 request(n) 요청이 전파되고, 가장 안 쪽에 있는 ArraySubscription의 데이터 송신이 시작된다. 런타임 단계에서도 request() 호출 횟수를 줄이는 등의 최적화가 이루어진다. (마이크로 퓨전)

참고

Subscription::request() 메소드는 호출 시 요청 수요 정보를 volatile 필드에 쓴다. 이는 비용이 많이 드는 연산이므로 request() 호출이 적을수록 좋다.






> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTUyNzg5NDY2LDE1MzAyMjk5MjMsLTE2Mj
gyMDI5OTgsMTMyNDE3OTUwMSwtMTIwODUyNzIyNiwtMTQwMjY5
ODQ3LDE2MTkxNjU4OTAsMTM4MzU1ODY1LDEyNTM2ODY2MTNdfQ
==
-->