# Reactive?

시스템 구축시 예상하는 부하 수준이 있을 것인데,  특정 시점의 부하가 예상치를 아득히 뛰어넘는 경우가 있다. 이렇게 과부하 상황에서 서비스를 정상적으로 제공하지 못하면 회사에선 큰 피해를 입기 마련이다. 

과연 이런 문제를 어떻게 대응해야 할까? 
애플리케이션은 변화에 대응을 해야 한다. 

일차적인 목표는 탄력성(elasticity)을 해결방법입니다. 이는 다양한 작업 부하에서 응답성을 유지하는 능력. 즉 많은 사용자 요청이 들어올때 시스템 처리량이 늘어냐하하고 수요가 감소하면 자동으로 감소해야 한다. 

>리액티브 시스템에 대한 수요 증가로 스프링 클라우드(Spring Cloud)라는 새로운 프로젝트가 시작되었다. 
>스프링 클라우드 프레임워크는 몇 가지 문제점을 해결하고 부산 시스템 구축을 단순화하는 기반 프로젝트입니다. 

## [Futre, Promise Class](http://wiki.webnori.com/display/AKKA/Future+and+Promice) 

Future(미래)와 Promice(약속)은 비동기처리에 있어서 중요한 개념입니다.

현재에서 미래로는 블록킹이 없기 때문에 어느시점 사용가능한 함수의 결과(성공또는 실패등을)를 담을수 있는 용기라고 보면 됩니다.

퓨쳐는 읽기전용이며, 퓨쳐에 담긴 값을 외부에서 변경할수 없습니다.
함수 실행이 끝나면 퓨쳐에 성공 또는 실패에 따른 결과가 들어갑니다. 
퓨쳐에 담긴 결과는 완료된 다음부터는 바뀌지 않으며, 외부에서 여러번 읽을수 있고 매번 같은 값을 돌려줍니다.

결과가 들어갈 용기가 있으므로 비동기적으로 실행되는 여러 함수들을 쉽게 조합할수가 있습니다.

@FunctionalInterface 
: 인터페이스의 목적 뿐만 아니라 컴파일러로 하여금 인터페이스 조건이 맞지 않으면 에러를 생성하도록 힌트를 줍니다. 단일 추상 메서드(SAM; Single Abstract Method)인 모든 인터페이스가 FunctionalInterface를 가지고 람다 표현식으로 처리가 될지도 모릅니다. 


java.util.concurrent.Future 클래스는 폴링을 필요로하며 결과를 얻기위해 블로킹 get 메서드를 사용해야만 한다. 









> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQ5MzIwODEyMSwxNzk2NzA5ODc0LDIwND
cyMjYyMzcsLTkxNTMxMzA3MCw0OTg0MzA1MDBdfQ==
-->