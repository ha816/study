# 1 리액트 시작

## 1.1 왜 리액트인가?

자바스크립트는 단순히 웹 브라우저에서 간단한 연산을 하거나 시각적인 효과를 주는 스키립트 언어에서 시작했지만, 현재는 웹 어플리케이션에서 가장 핵심적인 역할을 한다.

페이스 북팀에서는 어떤 뷰단의 데이터가 변할때마다 어떤 변화를 줄지 고민하는것이 아니라 그냥 기존 뷰를 날려버리고 처음부터 새로 렌더링하는 방식을 생각했다. 

그런데 이런 방법은 컴퓨터 리소스 사용이 많기 때문에, 페이스 북팀은 최대한 성능을 아끼고 편안한 유저 경험을 제공하면서 개발할것이 바로 리액트이다. 

### 1.1.1 리액트의 이해

리액트는 자바스크립트 라이브러리로 유저 인터페이스를 만드는데 사용한다. 다른 프레임워크와 달린 오직(View)만 신경 쓰는 라이브러리이다. 

렌더링
: 사용자 화면에 뷰를 보여주는 것을 렌더링이라고 한다.

리액트 컴포넌트가 최초로 실행한 초기 렌더링과 리렌더링을 이용한 성능을 아끼고 최적의 유저 경험을 제공.

#### 초기 렌더링

처음에 어떻게 보일지 초기 렌더링이 있고 리액트에서는 render함수가 있다. 이 렌더 함수는 컴포넌트가 어떻게 생겼는지 정의하는 역할을 한다. html형식의 문자열을 반환하는게 아니라, 뷰가 어떻게 생기고 동작하는지 정보를 지닌 객체를 반환한다. 함수를 실행하면 내부에 있는 컴포넌트도 재귀적으로 렌더링 하면, 최사윙 컴포넌트의 렌더링 작업이 끝나면 HTML 마크업을 만들고, 실제 페이지 DOM 요소안에 주입한다.

#### 조화 과정

리액트에서 뷰를 업데이트할때는 조화(reconciliation)을 거친다고 하는것이 더 정확한 표현이다. 
데이터의 변화가 생길때 뷰에 따라 변형되는것처럼 보이지만, 사실은 새로운 요소로 갈아 끼우기 때문이다. 이 작업 또한 렌더 함수가 맡아서 한다. 초기 렌더링 다음에 데이터가 변경이 일어 났을때 결과를 바로 DOM에 반여하지 않고, 이전에 컴포넌트 정보와 현재 컴포넌트 정보를 비교한다. 최소한의 연산으로 두가지 뷰를 비교하고, 최소한의 연ㅅ나으로 DOM을 업데이트 한다. 

## 리액트 특징

### Virtual DOM
먼저 DOM(Document Object model)은 객체를 문서 구조로 표현하는 방법으로 XML이나 HTML로 작성한다. 

DOM은 과연 느릴까?
DOM의 문제점은 동적 UI에 최적화 되어 있지 않다는 점이다. DOM 자체는 빠르지만, 웹 브라우저 단에서 DOM 변화가 생기면 웹 브라우저가 다시 연산하고, 레이아웃을 구성하고 리페인트 하기 때문에 느려진다. 

이것의 해결법은 DOM을 최소한으로 조학하여 작업을 처리하는 방식으로 한다. 리액트는 Virtual Dom방식을 사용하여 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행한다. 

리액트가 실제 DOM 업데이트를 할때는 다음 세 가지 절차를 밟습니다.

* 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링한다.
* 이전 Virtual DOM에 있던 내용과 현재 내용을 비교합니다.
* 바뀐 부분만 실제 DOM에 적용합니다.

리액트에 대한 오해: Virtual DOM을 사용한다고 해서 사용하지 않을때와 비교하여 무조건 빠른것은 아니다. 

**우리는 다음 문제를 해결하고 리액트를 만들었습니다. 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축하기**

리액트를 사용하지 않아도 코드를 잘 짜면 DOM 작업이 느려지는 문제를 개선할 수 있다. 그리고 매우 작업이 간단할대는 리액트를 사용하지 않는게 더 좋기도 한다. 

리액트와 Virtual DOM이 언제나 약속하는 것은 업데이트 처리 간경설이다. UI를 업데이트 하는 과정에서 생기는 복잡함을 모두 해소하고, 더욱 쉽게 업데이트에 접근할 수 있다. 

### 기타 특징

다시 강조하면 리액트는 프레임워크가 아니라 라이브러리이다. 그렇기 때문에 다른 웹 프레임워크가 Ajax, 데이터 모델링, 라우팅 등 기능을 내장하고 있지만, 리액트는 정말 뷰만 신경쓰는 라이브러리 이므로 다른 것들은 직업 구현하거나 여러 라이브러리를 가져와서 사용해야 한다. 

라우팅에는 리액트 라우터, Ajax 처리에는 Axios나 fetch, 상태관리에는 리덕스(redux)나 MoBX를 사용하여 빈 자리를 채운다. 

리액트는 다른 웹 프레임워크와 함께 혼용할수도 있다. Backbone.js나 AngularJS등 과 함께 

## Node.js와 npm

Node.js는 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임이다. Node.js를 통해서 웹 브라우저 환경이 아닌 곳에서도 자바스크립트를 사용하여 연산을 할 수 있다. 
리액 애플리케이션은 웹 브라주저에서 실행되기 때문에 Node.js와 직접적인 연관은 없지만, 개발에 필요한 도구들이 주로 Node.js를 사용하기 때문에 필요하다.

webpack
: 모듈화된 코드를 한 파일로 합치고(번들링) 코드를 수정할때마다 웹 브라우저를 리로딩하는 등 여러 기능을 지닌  패키지

npm
: Node.js 패키지 매니저로 수많은 개발자가 만든 모듈(재사용 가능한 코드)를 설치하고 해당 모듈 버전을 관리하는 도구입니다. 

yarn
: npm 문제점을 개선한 패키지 매니저로 npm을 대체할 수 있다. npm은 의존하는 라이브러리 개숙 많으면 속도가 늦어지고, 의존하는 버전이 설치되는 시점을 기준으로 결정하기 때문에 시기에 따라 다른 버전을 설치할 가능성이 있다. 

리액트 프로젝트를 만들면 yarn start 명령어로  프로젝트 개발 서버를 실행할 수 있습니다. 개발 서버는 3000 포트로 열리고, 파일 수정할때마다  프로젝트를 다시 빌드하고 웹 브라우저를 리로딩한다. 

> 빌드한다는 것?
> 리액트 프로젝트를 빌드한다는 것은 여러 파일로 분리된 프로젝트를 한 파일로 합치는 것입니다. 이 과정에는 ES6 형태로 작성된 코드를 구 버전 자바스크립트 엔진이 이해할수 있는 코드로 변환하는 작업도 포함되어 있다. 

# 2장 JSX

## 2.1 코드 이해

Node.js의 주요 특징은 코드를 모듈화하여 재사용할 수 있다는 것이다. 모듈들을 js 파일에서 불러와 사용할 수 있는데 이때 사용하는 코드는 아래와 같다.

```
var fa = require('fs');
```

fs는 Node.js 내장 모듈 중 파일을 일고 쓸대 사용하는 모듈. 2015년 공식으로 업데이트한 자바 스크립트 문법에서는 새로운 키워드가 생겼는데, 바로 import이다. 
```
import fa from 'fs';
```

이렇게 모듈화해서 사용하는 것은 Node.js의 기능이다. 웹 브라우저에서 사용하는 자바스크립트는 Node.js 런타임으로 실행하는 것이 아니기 때문에 자체적으로 이 기능을 지원하지 않는다. 

보통 웹브라우저에서 html 파일안에서 script 태그를 사용해서 여러 파일을 불러오곤 한다. 
이런 특징을 웹 브라우저에서도 비슷하게 사용하는데 번들링 도구를 이용하는 것이다.
webpack이 대표적인 도구인데 이러 번들링 도구를 사용하면 require또는 import로 모듈을 불러왔을때 번들링 되면서 모듈들을 파일 하나로 합쳐 줍니다. 

이렇게 파일들을 불러오는 것은 webpack의 로더가 담당하며 종류도 여러가지이다. css-loader는 css파일을 불러올 수 있고 file-loader는 웹 폰트나 미디어 파일등을 불러 올수 있다. babael-loader는 js파일들을 불러오면서 Es6으로 작성된 코드를 ES5 문법으로 변환해준다. ES5문법으로 변환하는 이유는 구 버전 웹 브라우저와 호환하기 위해서이다. 

```
class App extends Componet{
```
이 코드는 App이라는 클래스를 선언한다. 클래스는 리액트 라이브러리 내부에 있는 Componet 클래스를 상속한다. 새로운 컴포넌트를 만들 때는 이렇게 클래스를 선언한다. redner 함수는 어떻게 내부에서 보일지 render함수를 이용해서 return을 한다.

render함수 안에 코드를 보면 마치 HTML을 작성한 것 같지만 따음표를 쓰지 않은것으로 보아 단순한 문자열 템플릿은 아니다. 이런 코드들을 JSX라고 한다.

## 2.2 JSX란?

JSX는 자바스크립트의 확장 문법으로 XML과 매우 비슷하게 생겼다. 이런 형식으로 작성한 코드는 나중에 코드가 번들링 되면서 babler-loader를 사용하여 자바스크립트로 변환한다. 
> JSX는 리액트 용이기 때문에 공식 자바스크립트 문법은 아니다. 

## 2.3 JSX 장점

* 보기 쉽고 익숙: 문자열이나 XML이 아닌 HTML 그대로 보기 편하다
* 오류 검사: JSX에 오류가 있다면 바벨이 코드를 변환하는 과정에서 이를 감지한다.


## 2.4 JSX 문법

JSX는 정말 편리하지만, 몇 가지 규칙을 준수해야 한다. 

### 2.4.1 감싸인 요소

컴포넌트에 여러 요소가 있다면 부모 요소 하나로 꼭 감싸야 한다. 
```
render() {
	return (
		<div>
			<h1>리액트 안녕!</h1>
		</div>
	);
}
```

하지만 왜 꼭 부모 요소로 감싸야 할까? Virtual DOM에서 컴포넌트 변화를 감지할때 효율적으로 비교하려면 DOM 트리 구조여야한다는 규칙이 있기 때문이다. 

### 2.4.2 Fragment

div와 같은 루트 컴포넌트를 만들기 싫을때 사용할 수 있다. 

```
render() {
	return (
		<Fragment>
			<h1>리액트 안녕!</h1>
		</Fragment>
	);
}
```
위에 처럼하면 불필요한 div를 렌더링하는것을 생ㄱ략 할 수 있다.

## 자바스크립트 표현

JSㅌ안에서는 자바스크립트 표현식을 쓸 수 있다. 자바 스크립트 표현식을 작성하려면 JSX 내부에서 코드를 {}로 감싸면 된다. 

```
render() {
	const text = '당신은 어썸한가요?';
	return (
		<Fragment>
			<h1>리액트 안녕!</h1>
			<h2>{text}</h2>
		</Fragment>
	);
}
```

> const와 let
> ES6 문법에서 새로 도입한 것으로 한번 지정하고 변경이 불가능한 상수를 선언할때 사용하는 키워드가 const.
> let은 동적인 값을 담을 수 있는 변수를 선얼할때 사용하는 키워드
> var은 scope가 함수단위(해당값을 사용할 수 있는 코드 영역 단위가 함수) 이다.
> let과 const는 scope가 블록 단위이다.그리고 블록 내부에서 중복 선언이 불가능하다. 

### 2.4.3 if문 대신 조건부 연산자 

```
render() {
	const text = '당신은 어썸한가요?';
	const condition = true;
	return (
		<Fragment>
			<h1>리액트 안녕!</h1>
			<h2>{text}</h2>
			{
				condition ? '참' : '거짓'
			}
		</Fragment>
	);
}
```

### 2.4.5 인라인 스타일링 

리액트에서 DOM 요소에 스타일을 적용할대는 문자열 적용이 불가하다. 대신 CSS 스타일을 자바 스크립트 객체 형식으로 만들어야 한다. 

```
render() {
	const text = '당신은 어썸한가요?';
	const condition = true;
	const styple = {
		backgroundColor: 'gray',
		border: '',
		width: '',
		...
	}
	return (
		<Fragment>
			<h1>리액트 안녕!</h1>
			<h2>{text}</h2>
			<div style={style}></div>
		</Fragment>
	);
}
```

자바 스크립트의 객체 key에서는 '-'를 사용할수 없다.
- background-color => backgroundColor로 바꾸어 사용한다. 
'-'가 있을때는 접두어인 문자를 대문자로 작성한다.
- -mos, -webkit => Mos, Webkit

### 2.4.6 class 대신 className

```
render() {
	...
	return (
		<div class="my-div">
			<h1>리액트 안녕!</h1>
			<h2>{text}</h2>
			<div style={style}></div>
		</div>
	);
}
```

위에 class my-div처럼 하면, Warning 경고가 뜬다. 리액트에서 class를 설정할때는 class 키워드 대신 className으로 설정해야 한다. 왜냐하면 class 키워드는 이미 자바스크립트에 존재하는 키워드 이기 때문이다. 
자바스크립트로 class를 설정할땐 className키워드를 사용한다. 

### 2.4.7 꼭 닫아야 하는 태그

input과 br같은 태그는 연 후 닫지 않는다. 이럴 태그들을 self-closed 요소라고 부르며 여는 태그와 닫는 태그가 분리되어 있지 않고 자체적으로 닫는 태그로 사용이 가능하다. 

보통 HTML 코드는 웹 브라우저에서 보일때 전혀 문제가 없지만 JSX에서 위의 태그를 닫지 않으면 Virtual DOM은 트리 형태 구조를 만들지 못해 오류가 발생한다. 따라서 JSX에서는 언제나 태그를 닫아 주어야 한다. 

```
<form>
	First name <br/>
	<input type="text" name="firstname"/><br/>
</form>
}
```
### 2.4.8 주석


JSX안에서 주석을 작성하는 방법은 일반 자바스크립트에서 주석을 작성할때와 조금 다릅니다. 
일반적으로 주석을 작성할때는 { /* 이런 형식으로 */}. 일반 자바 스크립트에서 주석을 작성할때처럼 아무데나 // 나 /**/ 작성하면 그 주석은 페이지에 그대로 렌더링 된다. 

### 2.5 정리

JSX는 HTML과 비슷하지만 다르고, XML 형식이지만 실제로는 자바스크립트 객체이다. 용도도 다르고 문법도 조금씩 차이가 난다. 

