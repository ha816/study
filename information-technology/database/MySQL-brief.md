# MySQL Architecture

## ENGINE

MySQL엔진
: 커넥션핸들러와 SQL파서 및 전처리기 그리고 옵티마이저가 중심을 이룬다. 그리고 성능 향상을 위해 MyISAM의 키 캐시나 InnoDB의 버퍼풀과 같은 보조 저장소 기능이 포함되어 있다. MySQL엔진은 DBMS의 두뇌와 같은 처리를 수행한다. 

스토리지 엔진
: 실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 역할은 스토리지 엔진이 담당한다.  MySQL엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있다. 

핸들러 API
: MySQL엔진이 쿼리 수행을 위해 각 스토리지 엔진에게 쓰기 또는 일기를 요청하는데 이러한 요청을 핸들러 요청이라고 한다. 그리고 이때 사용되는 API를 핸들러 API라고 한다. 

```
create table test_table (...) ENGINE =INNODB, MyISAM;
```

## THREAD Structure
MySQL은 프로세스 기반이 아니라 스레드 기반으로 동작한다. 
스레드는 크게 포그라운드 스레드(클라이언트 스레드)와 백그라운드 스레드로 구분할 수 있다.

포그라운드 스레드(Foreground Thread)
: MySQL서버에 접속한 클라이언트의 수 많큼 존재한다. 주로 각 클라이언트에 사용자의 요청쿼리를 처리하는 역할을 한다. 클라이언트의 커넥션이 종료되면 다시 Thread pool로 돌아간다. 

백그라운드 스레드(Background Thread)
: 여러 중요한 작업이 백그라운드 스레드로 수행된다. 버퍼의 데이터를 디스크로 쓰는 쓰기 쓰레드(Write Thread)와 로그 쓰레드(Log Thread)가 대표적이다.

사실 쓰기 작업은 지연(버퍼링, 누적)하여 처리될 수 있지만, 읽기 작업은 절대 지연되면 안된다. 일반적인 DBMS은 쓰기작업을 버퍼링하여 일괄 처리하는 기능이 있다.

## Memory Structure

메모리는 MySQL 파라미터로 설정해 둔 만큼 운영체제로 부터 메모리를 할당 받는다. 메모리 영역은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 두 영역의 차이는 서버 내의 스레드가 공유하는 영역인지 아닌지에 따라 구별된다.

글로벌 메모리 영역(Global Memory Area)
: 모든 스레드가 공유하는 영역이다. 2개 이상의 글로벌 메모리 영역을 받을 수도 있지만, 마찬가지로 모든 스레드가 볼 수 있다.

로컬 메모리 영역(Local Memory Area, Session Memory Area, Client Memory Area)
: 클라이언트 쓰레드가 사용하는 대표적인 메모리 영역이다. 클라이언트 쓰레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역. 또 서버와 커넥션을 맺는 세션이라 하여 세션 메모리 영역이라고도 한다.

## 쿼리 실행 구조
파서 - 전처리기 - 옵티마이저 - 쿼리 실행기 

파서(Parser)
:  들어온 쿼리를 토큰(MySQL이 인식하는 최소 단위의 어휘)으로 분리해 트리 형태의 구조를 만드는 작업을 한다. 이 과정에서 문법 오류가 있으면 오류 메세지를 반환한다.

전처리기
: 파서 과정에서 만들어진 트리를 기반으로 다른 유형의 문제점을 확인한다. 예를 들면, 접근 권한 여부와 컬럼, 테이블등이 존재하는지 여부를 확인한다. 

옵티마이저
: 쿼리를 어떻게 가장 저렴한 비용으로 빠르게 처리할지 결정하는 역할을 담당한다. 어떻게 하면 옵티마이저가 나은 선택을 하도록 유도하는가가 중요하다.

실행기
: 실행기는 옵티마이저에서 만든 계획대로 여러 핸들러에게 필요한 작업을 요청하고 받은 결과를 클라이언트에게 반환한다. 핸들러는 실행기의 요청에 따라 핸들러가 대응하는 스토리지 엔진을 조작하여 필요한 작업을 수행한다. 

## 복제(Replication)
데이터베이스의 데이터가 갈수록 대용량화 되어가는 것을 고려하여 확장성(Scalability)는 DBMS에서 아주 중요한 요소이다. MySQL은 확장성을 위해 다양한 기술을 제공하는데 그중 가장 일반적인 방법이 Replication이다. 

Replication은 2대 이상의 MySQL 서버가 동일한 데이터를 가지도록 동기화하는 기술이다. 하지만 Replication은 동기화가 비동기적으로 발생한다. 따라서 어떤 데이터베이스에는 데이터가 업데이트되어 있지만, 다른 데이터베이스에서는 업데이트되지 않을 수도 있다.  

Master
: 마스터 서버는 주로 데이터변경 작업의 주체이다.  **마스터 서버는 DML, DDL에 해당하는 모든 쿼리 문장을 바이너리 로그에 기록한다.** 슬레이브 서버에서 변경 내역을 요청하면 **바이너리 로그**를 읽어 슬레이브서버에 넘기는데 Binlog dump라는 쓰레드가 이 작업을 수행한다.

Slave
: 바이너리 로그를 받아 마스터 서버의 정보(IP, Port, 접속 계정)를 가지고 있는 경우 슬레이브가 된다. 마스터 서버가 바이너리 로그를 가지고 있다면, 슬레이브 서버는 **릴레이 로그**를 가진다. 마스터 서버와의 동일한 데이터 유지를 위해 슬레이브 서버는 마스터서버에 접속해 변경 내역을 가져와 릴레이 로그에 기록한다.(Slave_IO_Thread). SQL 스레드(Slave_SQL_Thread)가 릴레이 로그의 변경 작업을 재실행(replay)하여 데이터의 일관성을 유지한다. 



## 쿼리 캐시(Query Cache)

쿼리 캐시는 타 DBMS에서는 볼 수 없는 MySQL만의 독특한 기능이다. **쿼리 캐시는 단어의 의미와는 달리 SQL 문장을 캐시하는 것이 아니라 쿼리의 결과를 메모리에 캐시해두는 기능이다.** 
쿼리 캐시 구조는 Map으로 구현되어 있다. 키는 쿼리 문장 자체이고, 값은 해당 쿼리의 결과이다. 실제 쿼리할 때는 복잡한 처리 절차가 있다. 이를 무시하고 동일한 쿼리 문장이 요청되었다고 해서 바로 캐시된 결과를 보내선 안된다. 캐시 결과를 내려보기 전에 아래와 같은 확인 절차를 거친다. 

### 쿼리 캐시 결과 확인 절차

1. 요청된 쿼리 문장이 캐시에 존재하는가?
2. 해당 사용자가 쿼리를 볼 수 있는 권한이 있는가?
3. 트랜잭션 내에 실행된 쿼리의 경우, 그 결과가 범위내의 트랜잭션에서 만들어진 결과인가?
4. 캐시가 만들어지고 난 후 데이터가 다른 사용자에 의해 변경되지 않았는가?
5. 쿼리에 사용된 내장함수, 저장함수등이 캐시되어도 동일한 결과를 보장하는가?
6. 쿼리 결과가 캐시해두기에는 너무 크지 않은가?
7. 그 밖에 캐시를 사용하지 못하게 하는 요소가 있는가?


# InnoDB Storage Engine 
MySQL에서 사용할 수 있는 스토리지 엔진 중에서 **거의 유일하게 레코드 기반 잠금 기능이 있다.** 따라서 높은 동시성 처가 가능하고 안정적이며 성능이 뛰어나다. 

엔진 특성
* 프라이머리 키에 의한 클러스터링
	* 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 즉 프라이머리 키 값의 순서대로 저장된다. 따라서 쿼리 실행 계획에서 프라이머리 키를 사용하면 빠르게 처리가 될 가능성이 크다. 
* 잠금이 필요 없는 일관된 읽기(Non-locking consistent read)
	* MVCC(Multi Version Concurreny Control)이라는 기술로 락을 걸지 않고 읽기 작업을 수행한다. 
* 외래키 지원
	* 외래키는 여라가지 제약사항 때문에 실무에서 많이 사용하지는 않다. 왜냐하면 데이터 변경시 여러 테이블에서 데이터가 있는지 체크하는 작업이 필요해서 잠금이 여러 테이블로 전파되고, 이로 인해 데드락이 발생하는 경우가 많다.
* 자동 데드락 감지
	* 그래프 기반의 데드락 체크 방식을 사용하여, 데드락이 발생하면 바로 감지되고, 감지된 데드락은 관련 트랜잭션 중에서 가장 적게 변경한 또는 가장 복구작업이 적게 드는 트랜잭션을 찾아 강제 종료해버린다. 따라서 데드락 때문에 쿼리 Timeout또는 슬로루 쿼리로 기록되는 경우는 별로 없다. 
* 오라클 아키텍처 적용
	* InnoDB는 오라클 DBMS와 상당히 비슷한 부분이 많다. MVCC, Undo 데이터가 시스템 테이블 스페이스의 개념등 비슷한 부분이 많다.

![enter image description here](https://t1.daumcdn.net/cfile/tistory/99A451505BDFF70729)

## InnoDB Buffer Pool

파일 디스크의 데이터 파일이나 인덱스 정보를 캐시해 두는 메모리 공간이다. Buffer Pool이란 이름에서 알 수 있듯이 다수의 Buffer 공간을 가진다. Buffer는 주로 쓰기 작업을 지연시켜 일괄적으로 처리하여 성능향상을 꾀한다. 일반적인 애플리케이션에서은 테이블의 레코드를 변경하는데 이를 버퍼 풀에 모아서 처리하면 디스크 변경 작업의 횟수를 줄일 수 있다. 

### Insert Buffer

레코드가 INSERT되거나 UPDATE 될때는 데이터 파일을 변경하는 것 뿐만아니라 해당 테이블에 인덱스를 업데이트하는 작업도 필요하다. 이 작업을 위해서 디스크를 읽고 쓰는 작업이 필요한데 이게 리스크하다. 그래서 변경할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하고, 없다면 디스크로부터 읽어와 업데이트를 해야할때는 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상 시킨다. 이때 사용하는 임시 메모리 공간을 Insert Buffer라 한다.  

### Undo Record

Undo 영역은 UPDATE, DELETE같은 문장으로 데이터 변경 전에 이전 데이터를 보관하는 곳이다. Undo 데이터는 트랜잭션 롤백을 위해 사용되기도 하고, 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하기 위해 사용된다. 후자의 기능이 바로 MVCC의 기능을 구현하기 위해 사용된다. 

#### MVCC(Multi Version Concurrency Control)

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다. 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있는데, 이때 Undo 로그를 사용해 기능을 구현한다.   

멀티 버전이라는 것은 한개의 레코드에 대해서 여러 버전이 동시에 관리된다는 의미이다. 한 레코드는 Data Page Buffer, Undo Record, Disk file에 3가지 버전으로 기록이 된다. 

UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이, Data Page Buffer으 새로운 값으로 수정되고, 디스크의 데이터도 일반적으로 동일한 상태의 데이터가 된다.  그러면 아직 COMMIT이나 ROLLBACK이 일어나지 않은 상태에서 다른 사용자가 작업 중이던 레코드를 조회하면 어떤 버전의 데이터를 조회할까??

이는 설정된 격리 수준(Isolation level)에 따라 다르다. READ_UNCOMMITED의 경우, 데이터가 COMMIT되었든 아니든 변경되지 않은 데이터를 읽어 온다. 
READ_COMMIT나 그 이상의 수준일때는 아직 변경이 커밋 되지 않았기 때문에 Data Page Buffer이나 Disk file 대신에 Undo Record에 데이터를 반환한다. 즉 하나의 레코드가 2개의 버전이 존재하고, 상황에 따라 다른 데이터가 반환되는 구조이다. 





## Log Buffer & Redo Log

트랜잭션 보장을 위해서는 앞서 보았던 Buffer Pool만으로는 부족하다. 트랜잭션 보장을 위해선 변경된 내용을 순차적으로 데이터 파일로 기록해야 한다. 이 데이터 파일이 우리가 일반적으로 부르는 로그파일이고 리두로그(Redo Log)라고 부른다. 일반적으로 DBMS에서 로그라 하면 일반적으로 이 리두 로그(Redo Log)를 말한다. 

변경작업이 많은 서버에서는 로그 기록작업도 부하가 커서, 버퍼링을 사용하게 되는데, 이때 사용하는 버퍼가 Log Buffer이다.

## MVCC(Multi Version Concurreny Control)

## Non-locking consistent read


# NDB Cluster Storage Engine

# MySQL 로그 파일
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg5NDczODg1OSwtMTg0Mjk5NDg5LC0xNj
g0NTE1NjEzLC0zNDQ1NDU2MDYsLTEyNjczNzk5MzUsNzE2OTAz
NCwtNjU2OTQ3NjI5LC0xMzUyODM0ODIyLC0xNjc0OTgyMDU0XX
0=
-->