# Overview

MySQL 실행 계획 성능에 큰 영향을 미치는 작업 단위에 대해 더 자세히 알아 보자. 
풀 테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리되는 내용임을 명심하자. 또한 MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 큰 영향을 미치는데, 안타깝게도 모두 쿼리의 성능을 저하 시킨다. 

스토리지 엔진에서 읽은 레코드를 MySQL엔진이 아무런 가공 없이 반환하면 최상의 성능을 보장하겠지만, 우리가 원하는 결과는 대부분 그렇지 않다. MySQL엔진에서 처리하는 시간이 오래걸리는 작업의 원리를 안다면 쿼리 튜닝에 큰 도움이 될것이다. 

# 풀 테이블 스캔(full table scan)

인덱스를 사용하지 않고 테이블 전체를 읽어 작업을 처리한다. 풀 테이블 스캔은 아래와 같은 조건에서 주로 풀테이블 스캔을 선택한다.

* 테이블의 레코드가 원채 적어서 풀 테이블 스캔이 더 빠른 경우
* WHERE 절이나 ON 절에서 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
* 인덱스 래이진 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(통계 정보기준)
* max_seeks_for_key 변수를 특정 값(N)으로 설정하면 인덱스의 기수성(Cardinality)나 선택도(selectivity)를 무시하고, 최대 N건만 읽으면 된다고 판단한다. 이 값이 작으면 인덱스를 더 사용하도록 유도할 수 있다.

일반적으로 테이블 전체 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기가 필요하다. 그래서 대부분의 DBMS는 풀 테이블 스캔시 한꺼번에 가져올 여러개의 블럭이나 페이지를 읽어오는 기능이 있고, 그 수를 조절할 수 있다. 하지만 MySQL에서는 예외적으로 풀 테이블 스캔을 할때 한꺼번에 몇 개씩 블럭이나 페이지를 가져올지 설정하는 변수가 없다. 그래서 많은 개발자가 MySQL이 풀 테이블 스캔시 디스크로부터 블럭이나 페이지를 하나씩 읽어 오는것으로 착각할때가 많다. 

사실 MyISAM 스토리진 엔진에서는 페이지를 하나씩 읽어오고 InnoDB에서는 아니다. InnoDB 스토리지 엔진은 특정 테이블에서 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어해드(Read ahead) 작업이 자동시작된다. 즉 풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 백 그라운드 스레드가 읽기를 넘겨받는 시점부터는 한번에 4개 또는 8개씩의 페이지를 읽으면서 그 수를 증가시킨다. 그리고 한번에 최대 64개의 페이지를 읽어 버퍼풀에 저장해둔다. 포그라운드 스레드는 미리 버퍼풀에 올라간 데이터를 가져다 사용하기만 되므로 쿼리가 상당히 빠르게 처리된다. 

리드 어해드(Read ahead)
: 어떤 영역의 데이터가 앞으로 필요해지리라 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB 풀에 가져다 두는 것을 말한다.

MySQL 5.1의 InnoDB 플러그인 버전 부터는 언제 리드 어해드를 사용할지 시스템 변수로 변경할 수 있다. 이 변수 이름은 innodb_read_ahead_threshold인데, 일반적으로는 디폴트 설정으로도 충분하지만 테이터웨어하우스용으로 MySQL을 사용한다면 이 옵션 값을 낮추어 더 자주 리드 어해드가 시작되도록 유도하는 것도 좋다.

# ORDER BY 처리(Using filesort)

레코드를 한 두건 가져오는 쿼리를 제외하고는 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 데이터웨어 하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 아마 레코드 정렬 요건은 대부분의 조회 쿼리에 포함되어 있을것이다. 정렬을 처리하는 방법으로는 인덱스를 이용한 방법과 쿼리가 실행될때 "Filesort"라는 별도의 처리를 이용하는 방법이 있다.

* 인덱스 이용 방법
	* 장점: INSERT, UPDATE, DELETE 쿼리가 실행될때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되어 매우 빠르다.
	* 단점: INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 필요하다. 인덱스 개수가 늘어날 수록 버퍼풀 메모리가 더 필요하다. 
* Filesort 이용 방법
	* 장점: 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이 된다. 정렬해야할 레코드가 적으면 메모리에서 충분히 Filesort 처리가 빠르다.
	* 단점: 정렬 작업이 쿼리 실행시 실행되므로 레코드 대상 건수가 많아질 수록 응답이 느리다.

물론 레코드를 정렬하기 위해 항상 Filesort라는 정렬 작업을 거쳐야 하는 것은 아니다. 아쉽게도 아래와 같은 이유로 모든 정렬에 인덱스를 이용하기에 어려움이 있다.

* 정렬 기준이 너무 많아 모든 기준에 맞는 인덱스를 생성하는 것이 불가능한 경우
* GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 다시 정렬해야 하는 경우
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
* 랜덤하게 결과 레코드를 가져와야 하는 경우(때로는 인덱스를 이용하도록 개선할 수 있다)

MySQL이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 Extra 컬럼에 "Using filesort" 멘트가 표시되는 것으로 판단할 수 있다. 

## 소트 버퍼(Sort buffer)

MySQL 정렬을 위해서는 별도의 메모리 공간을 할당 받는데 이 공간을 소트 버퍼(sort buffer)라 한다. 소트 버퍼는 정렬이 필요한 경우만 할당되면, 버퍼의 크기는 정렬해야한 레코드의 크기에 따라 가변적으로 증가한다. 하지만 최대 사용 가능한 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다. 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

자 이제 정렬해야 할 레코드의 건수가 sort_buffer_size 보다 더 크다면 어떻게 될까? 이러면 MySQL은 정렬해야할 레코드를 여러 조각 나누어 처리하는데 이 과정에서 디스크를 사용하게 된다.

메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기론해 둔다. 그 다음 레코드를 가져와서 정렬하고 반복적으로 디스크에 임시 저장한다.  이처럼 각 버퍼 크기 만큼씩 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다. 이 병합 작업을 멀티 머지(Multi-merge)라고 표현하며, 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수(SHOW STATUS VARIABLES; 명령 참조)에 누적된다.

모든 작업들은 모두 디스크 I/O를 유발하며, 레코드 건수가 많을 수록 이 반복 잡어의 횟수가 많아진다. 물론 소트 버퍼를 크세 설정하면 디스크를 사용하지 않아서 더 빨라질 것으로 생각할 수 있으나 실제 벤치마크 결과론 거의 차이가 없었다. MySQL에서는 소트 버퍼 크기가 256KB에서 512KB일때 최적의 성능을 보였으며 그 이후로는 아무리 소트 버퍼 크기를 늘려도 성능상 차이가 없었다. 소트 버퍼의 이런 특성은 리눅스의 메모리 할당 방식이 원인일 것으로 예측하지만 정확한 원인은 아직 확인된바가 없다.

경험상 소트 버퍼의 크기는 56KB에서 1MB 미안일때가 적절하다고 생각한다. MySQL은 글로벌 메모리 영역과 세션(로컬) 메모리 영역으로 나뉘는데. **소트 버퍼는 세션 메모리 영역에 해당한다.** 즉 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 없다. 커넥션이 많을 수록, 정렬 작업이 많을 수록 소트 버퍼로 사용되는 메모리 공간이 커진다. 소트 버퍼의 크기를 터무니 없이 크게 잡을 수 있지만 그렇게 되면 운영체제는 메모리 부족현상을 겪을 수 있다. 이럴 경우 운영체제의 정책은 메모리를 가장 많이 사용하고 있는 프로세스를 강제 종료하는데 일반적으로 MySQL 서버가 가장 많은 메모리를 사용하기 때문에 강제 종료 1순위가 된다.

>주의
>소트 버퍼를 크게 설정해서 빠른 성능을 없을 수는 없지만 디스크의 I/O 사용량은 줄일 수 있다. 따라서 MySQL 서버의 데이터가 많거나 디스크 I/O의 성능이 떨어진다면 소트 버퍼의 크기를 더 크게 설정해서 도움이 될 수 도 있다. 하지만 소트 버퍼를 너무 크게 설정하면 서버 메모리 공간이 부족해지기 때문에 소트 버퍼의 크기는 적절히 설정하도록 하자.

## 정렬 알고리즘

레코드 전체를 소트 버퍼에 담을지 아니면 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 두 가지 정렬 알고리즘을 사용할 수 있다.

### 싱글 패스(Single pass) 알고리즘

소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 되는 컬럼 전부를 담아서 정렬을 수행하는 방법이다. MySQL 5.0 이후 도입된 비교적 최식 버전의 정렬법이다.

```
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name
```

처음 employees 테이블을 읽을때, 정렬ㅇ


투 패스(Two pass) 알고리즘



# Distinct 처리

# 임시 테이블(Using temporary)

# 테이블 조인(table join)
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg3MTIxMjAzMCwtMTQyOTgzMTU1MCwtNT
cyMzM0NDgsLTI2MzU1OTQ3MSwyMDQ2NzIyMDY4LDYzMzY3Mjcw
MywtMjE0MTI4MTYyNSwtMTU5MDU1OTM3NywtMTAzNjE2ODY4Ni
wtNDYxNTE0MTA4LC0xMzIyNDQwNjQ5LC01NjQzMDg4MjEsLTIz
MTcyMjA3NCwyODY2MDc5NTEsLTE4MDg5NDExNjksMTg0MTk1Nz
YxMSwxMTA5NDU5MjQwLC02MTQzNzU5ODgsLTI4MjQxMDM1XX0=

-->