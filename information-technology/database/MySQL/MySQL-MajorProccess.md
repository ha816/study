# Overview

MySQL 실행 계획 성능에 큰 영향을 미치는 작업 단위에 대해 더 자세히 알아 보자. 
풀 테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리되는 내용임을 명심하자. 또한 MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 큰 영향을 미치는데, 안타깝게도 모두 쿼리의 성능을 저하 시킨다. 

스토리지 엔진에서 읽은 레코드를 MySQL엔진이 아무런 가공 없이 반환하면 최상의 성능을 보장하겠지만, 우리가 원하는 결과는 대부분 그렇지 않다. MySQL엔진에서 처리하는 시간이 오래걸리는 작업의 원리를 안다면 쿼리 튜닝에 큰 도움이 될것이다. 

# 풀 테이블 스캔(full table scan)

인덱스를 사용하지 않고 테이블 전체를 읽어 작업을 처리한다. 풀 테이블 스캔은 아래와 같은 조건에서 주로 풀테이블 스캔을 선택한다.

* 테이블의 레코드가 원채 적어서 풀 테이블 스캔이 더 빠른 경우
* WHERE 절이나 ON 절에서 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
* 인덱스 래이진 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(통계 정보기준)
* max_seeks_for_key 변수를 특정 값(N)으로 설정하면 인덱스의 기수성(Cardinality)나 선택도(selectivity)를 무시하고, 최대 N건만 읽으면 된다고 판단한다. 이 값이 작으면 인덱스를 더 사용하도록 유도할 수 있다.

일반적으로 테이블 전체 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기가 필요하다. 그래서 대부분의 DBMS는 풀 테이블 스캔시 한꺼번에 가져올 여러개의 블럭이나 페이지를 읽어오는 기능이 있고, 그 수를 조절할 수 있다. 하지만 MySQL에서는 예외적으로 풀 테이블 스캔을 할때 한꺼번에 몇 개씩 블럭이나 페이지를 가져올지 설정하는 변수가 없다. 그래서 많은 개발자가 MySQL이 풀 테이블 스캔시 디스크로부터 블럭이나 페이지를 하나씩 읽어 오는것으로 착각할때가 많다. 

사실 MyISAM 스토리진 엔진에서는 페이지를 하나씩 읽어오고 InnoDB에서는 아니다. InnoDB 스토리지 엔진은 특정 테이블에서 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어해드(Read ahead) 작업이 자동시작된다. 즉 풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 백 그라운드 스레드가 읽기를 넘겨받는 시점부터는 한번에 4개 또는 8개씩의 페이지를 읽으면서 그 수를 증가시킨다. 그리고 한번에 최대 64개의 페이지를 읽어 버퍼풀에 저장해둔다. 포그라운드 스레드는 미리 버퍼풀에 올라간 데이터를 가져다 사용하기만 되므로 쿼리가 상당히 빠르게 처리된다. 

리드 어해드(Read ahead)
: 어떤 영역의 데이터가 앞으로 필요해지리라 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB 풀에 가져다 두는 것을 말한다.

MySQL 5.1의 InnoDB 플러그인 버전 부터는 언제 리드 어해드를 사용할지 시스템 변수로 변경할 수 있다. 이 변수 이름은 innodb_read_ahead_threshold인데, 일반적으로는 디폴트 설정으로도 충분하지만 테이터웨어하우스용으로 MySQL을 사용한다면 이 옵션 값을 낮추어 더 자주 리드 어해드가 시작되도록 유도하는 것도 좋다.

# ORDER BY 처리(Using filesort)

레코드를 한 두건 가져오는 쿼리를 제외하고는 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 데이터웨어 하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 아마 레코드 정렬 요건은 대부분의 조회 쿼리에 포함되어 있을것이다. 정렬을 처리하는 방법으로는 인덱스를 이용한 방법과 쿼리가 실행될때 "Filesort"라는 별도의 처리를 이용하는 방법이 있다.

* 인덱스 이용 방법
	* 장점: INSERT, UPDATE, DELETE 쿼리가 실행될때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되어 매우 빠르다.
	* 단점: INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 필요하다. 인덱스 개수가 늘어날 수록 버퍼풀 메모리가 더 필요하다. 
* Filesort 이용 방법
	* 장점: 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이 된다. 정렬해야할 레코드가 적으면 메모리에서 충분히 Filesort 처리가 빠르다.
	* 단점: 정렬 작업이 쿼리 실행시 실행되므로 레코드 대상 건수가 많아질 수록 응답이 느리다.

물론 레코드를 정렬하기 위해 항상 Filesort라는 정렬 작업을 거쳐야 하는 것은 아니다. 아쉽게도 아래와 같은 이유로 모든 정렬에 인덱스를 이용하기에 어려움이 있다.

* 정렬 기준이 너무 많아 모든 기준에 맞는 인덱스를 생성하는 것이 불가능한 경우
* GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 다시 정렬해야 하는 경우
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
* 랜덤하게 결과 레코드를 가져와야 하는 경우(때로는 인덱스를 이용하도록 개선할 수 있다)

MySQL이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 Extra 컬럼에 "Using filesort" 멘트가 표시되는 것으로 판단할 수 있다. 

## 소트 버퍼(Sort buffer)

MySQL 정렬을 위해서는 별도의 메모리 공간을 할당 받는데 이 공간을 소트 버퍼(sort buffer)라 한다. 소트 버퍼는 정렬이 필요한 경우만 할당되면, 버퍼의 크기는 정렬해야한 레코드의 크기에 따라 가변적으로 증가한다. 하지만 최대 사용 가능한 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다. 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

자 이제 정렬해야 할 레코드의 건수가 sort_buffer_size 보다 더 크다면 어떻게 될까? 이러면 MySQL은 정렬해야할 레코드를 여러 조각 나누어 처리하는데 이 과정에서 디스크를 사용하게 된다.

메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기론해 둔다. 그 다음 레코드를 가져와서 정렬하고 반복적으로 디스크에 임시 저장한다.  이처럼 각 버퍼 크기 만큼씩 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다. 이 병합 작업을 멀티 머지(Multi-merge)라고 표현하며, 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수(SHOW STATUS VARIABLES; 명령 참조)에 누적된다.

모든 작업들은 모두 디스크 I/O를 유발하며, 레코드 건수가 많을 수록 이 반복 잡어의 횟수가 많아진다. 물론 소트 버퍼를 크세 설정하면 디스크를 사용하지 않아서 더 빨라질 것으로 생각할 수 있으나 실제 벤치마크 결과론 거의 차이가 없었다. MySQL에서는 소트 버퍼 크기가 256KB에서 512KB일때 최적의 성능을 보였으며 그 이후로는 아무리 소트 버퍼 크기를 늘려도 성능상 차이가 없었다. 소트 버퍼의 이런 특성은 리눅스의 메모리 할당 방식이 원인일 것으로 예측하지만 정확한 원인은 아직 확인된바가 없다.

경험상 소트 버퍼의 크기는 56KB에서 1MB 미안일때가 적절하다고 생각한다. MySQL은 글로벌 메모리 영역과 세션(로컬) 메모리 영역으로 나뉘는데. **소트 버퍼는 세션 메모리 영역에 해당한다.** 즉 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 없다. 커넥션이 많을 수록, 정렬 작업이 많을 수록 소트 버퍼로 사용되는 메모리 공간이 커진다. 소트 버퍼의 크기를 터무니 없이 크게 잡을 수 있지만 그렇게 되면 운영체제는 메모리 부족현상을 겪을 수 있다. 이럴 경우 운영체제의 정책은 메모리를 가장 많이 사용하고 있는 프로세스를 강제 종료하는데 일반적으로 MySQL 서버가 가장 많은 메모리를 사용하기 때문에 강제 종료 1순위가 된다.

>주의
>소트 버퍼를 크게 설정해서 빠른 성능을 없을 수는 없지만 디스크의 I/O 사용량은 줄일 수 있다. 따라서 MySQL 서버의 데이터가 많거나 디스크 I/O의 성능이 떨어진다면 소트 버퍼의 크기를 더 크게 설정해서 도움이 될 수 도 있다. 하지만 소트 버퍼를 너무 크게 설정하면 서버 메모리 공간이 부족해지기 때문에 소트 버퍼의 크기는 적절히 설정하도록 하자.

## 정렬 알고리즘

레코드 전체를 소트 버퍼에 담을지 아니면 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 두 가지 정렬 알고리즘을 사용할 수 있다.

### 싱글 패스(Single pass) 알고리즘

소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 되는 컬럼 전부를 담아서 정렬을 수행하는 방법이다. MySQL 5.0 이후 도입된 비교적 최식 버전의 정렬법이다.

```
SELECT first_name, last_name
FROM employees
ORDER BY first_name
```

처음 employees 테이블을 읽을때, 정렬에 직접 필요하지 않은 last_name까지 전부 읽어 소트 버퍼에 담고 정렬을 수행한다. 그리고 정렬이 완료되면 그대로 정렬 버퍼의 내용을 클라이언트에게 넘겨준다. 

### 투 패스(Two pass) 알고리즘

정렬 대상 컬럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어 필요한 컬럼 정보를 가져오는 알고리즘으로, 오랫동안 MySQL에서 사용하던 방법이다. MySQL 5.0 이상에서도 특정 조건에는 이 방법을 사용한다. 

```
SELECT first_name, last_name
FROM employees
ORDER BY first_name
```

처음 employees 테이블을 읽을 때는 정렬에 필요한 first_name 컬럼과 프라이머리 키인 emp_no만 읽어서 정렬을 수행했음을 알 수 있다. 이 정렬이 완료되면 그 결과 순서대로 employees 테이블을 한번 더 읽어서 last_name을 가져와 결과로 반환한다.

MySQL의 투패스 알고리즘은 같은 레코드를 두번 읽어야 하기 때문에 상당히 불합리 하지만 새로운 정렬방식인 싱글 패스(Single pass)알고리즘은 이런 불합리한 점이 없다. 하지만 싱글 패스 알고리즘은 더 많은 소트 버퍼 공간이 필요하다. 

대략 128KB의 정렬 버퍼를 쓴다면, 싱글에서는 대략 3500건, 투패스에서는 7000건의 레코드를 정렬할 수 있다. 

최근 MySQL은 싱글 패스 알고리즘을 쓰지만 아래 상황일때는 투 패스 알고리즘을 사용한다. 

* 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클때
* BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될때 

싱글 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 많은 경우 효율적이다. 

>SELECT 쿼리에서 꼭 필요한 컬럼만 조회하지 않고, 모든 컬럼(*)을 가져오도록 개발할때가 있다. 하지만 이는 정렬 버퍼를 비효율적으로 만들 가능성이 매우 크다. SELECT 쿼리에서 꼭 필요한 컬럼만 조회하도록 쿼리를 작성하도록 하는 것이 좋다고 권장하는 이유가 바로 이것 때문이다. 특히나 정렬이 필요한 SELECT는 불필요한 컬럼을 SELECT 하지 않도록 하는 것이 효율적이다. 이는 꼭 정렬 버퍼에만 영향을 미치는 것이 아니라 임시 테이블이 필요한 테이블에서도 영향을 미친다.

## 정렬의 처리방식

쿼리에 ORDER BY가 사용되면 반드시 아래 3가지 처리 방식 중 하나로 정렬이 처리된다. 일반적으로 밑쪽에 있는 정렬 방버븡로 갈수록 처리가 느려진다.

|정렬 처리 방법| 실행 계획의 Extra 커멘트  |
|--|--|
|인덱스 사용한 정렬  | 별도의 내용 표기 없음|
|드라이빙 테이블만 정렬 | Using filesort 표시|
|조인 결과를 임시 테이블로 저장후, 임시 테이블에서 정렬 | Using temporary; Usingfilesort가 같이 표시됨|

먼저 옵티마이저는 정렬처리를 위해 인덱스를 사용할 수 있을지 검토할 것이다. 만약 인덱스를 이용 할 수 있다면 별도의 Filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다. 하지만 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리한다.(Filesort) 이때 MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 두 방법 중 하나를 선택한다.

* 드라이빙 테이블만 정렬한 다음 조인 수행
* 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

일반적으로 조인이 수행되면서 레코드 건수는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다. 그래서 첫 번째 방법이 더 효율적으로 처리 된다.

### 인덱스 사용 정렬

인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 또한 WHERE 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. 

참고로 B-Tree 계열의 인덱스가 아닌 인덱스(해시 인덱스나 전문 검색 인덱스 등)에서는 이 인덱스 사용 정렬을 사용할 수 없다. 

인덱스를 이용해 처리하는 경우는 실제 인덱스의 값이 정렬되어 있기 때문에 단지 순서대로 읽기만 하면 된다. 실제로 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않는다. 

```
SELECT * FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no;

-- emp_no 컬럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동 정렬이 된다고 해서
일부러 ORDER BY e.emp)no를 제거하는 것은 좋지 않다.

SELECT * FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020;
```

>ORDER BY 주의할 점
>ORDER BY 절을 넣지 않아도 자동으로 정렬된다고 해서 ORDER BY를 빼는 경우가 있다. 혹시나 ORDER BY 절을 포함하면 MySQL 서버가 별도로 정렬 작업을 더 할까봐 걱정스러워서이다. 하지만 MySQL 서버는 졍렬을 인덱스로 처리할 수 있다면 절대 부가적으로 불필요한 정렬 작업을 하지 않는다. 그래서 인덱스 정렬이 처리될때 ORDER BY를 넣어도 작업량이 늘지 않는다. 또한, 어떤 이유 때문에 쿼리의 실행 계획이 조금 변경된다면 ORDER BY가 명시되지 않은 쿼리는 결과가 기대했던 순서대로 가져오지 못해 버그가 될 수도 있다. 하지만 ORDER BY를 명시해두면 성능상의 손해가 없음은 물론이고 이런 예외 상황도 버그로 연결되지 않을 것이다. 

### 드라이빙 테이블만 정렬

일반적으로 조인이 수행되면 결과 레코드의 건수가 몇배로 불어난다. 그래서 조인 전에 첫 번재 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이다. 이 방법은 조인에서 첫 번재 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절이 작성되어야 한다. 

```
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 AND 100010
order by e.last_name;
```

우선 WHERE 절의 조건이 다음 두 조건을 가지기 때문에 employees 테이블을 드라이빙 테이블러 선택할 것이다.

1. WHERE 절의 검색 조건(e.emp_no between ...)은 employees 테이블의 프라이머리 키를 이용해 작업량을 줄일 수 있다.
2. 드리븐 테이블(s.salaries)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다. 

검색은 인덱스 레인지 스캔으로 처리할 수 있지만 **ORDER BY 절에 명시된 컬럼은 employees 테이블의 프라이머리 키와 전혀 연관이 없으므로 인덱스를 이용한 정렬은 불가능하다.** 그런데 ORDER BY의 정렬 기준 컬럼이 드라이빙 테이블(employees)에 포함된 컬럼이다. 옵티마이저는 이럴 경우 드라이빙 테이블만 검색해서 정렬을 먼저 수행(File sort)하고, 그 결과로 salaries 테이블과 조인을 할 것이다. 

### 임시 테이블에서 정렬

쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT해서 정렬하는 경우라면 임시 테이블이 필요하지 않는다. 하지만 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다. 

앞에서 본 드라이빙 테이블 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다. 하지만 그 밖에 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다. 이 방법은 세 가지 방법 중에 정렬해야할 레코드 건수가 가장 많아지기 때문에 가장 느린 정렬법이다.  

```
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 AND 100010
order by s.salary;
```

하지만 이번 쿼리에서는 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블(salaries)에 있는 컬럼이다. 즉 정렬이 수행되기 전에 반드시 salaries 테이블을 읽어야 하므로 반드시 조인된 데이터를 가지고 정렬할 수 밖에 없다. 


|id| select_type|table|type|key|key_len|ref|rows|Extra
|--|--|--|--|--|--|--|--|--|
|1| SIMPLE|e|range|PRIMARY|4| | 9| Using where; Using temporary; Using filesort
|1| SIMPLE| s|ref|PRIMARY|4|e.emp_no|4|

## 정렬 방식의 성능 비교

주로 웹 서비스용 쿼리에서는 ORDER BY와 함께 LIMIT가 거의 필수적으로 사용되는 경향이 있다. 일반적으로 LIMIT는 테이블의 처리 결과 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다. 그런데 **ORDER BY나 GROUP BY와 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서 처리될 수 없다.** 
우선조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그룹핑 작업을 실행해야마나 비로서 LIMIT 건수를 제한할 수 있다. WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다. 

쿼리에 인덱스를 사용하지 못하는 정려이나 그룹핑 작업이 왜 느리게 작동할 수 밖에 없는지 보자. 이를 위해 쿼리가 처리되는 방법 "스트리밍 처리"와 "버퍼링 처리" 두 가지 방식을 구분해보자.

###


# Distinct 처리

# 임시 테이블(Using temporary)

# 테이블 조인(table join)
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTk4MDk0NDk1LC04NjY3NzY1NiwtNzM1Nj
M0ODQ1LC0zMzYyODQ4ODEsLTg4ODQ4MTI5LDE1MjAwOTY1NzAs
OTg2NzAyODIyLDE3MzUyODAwMzUsLTIxMzAyNTE3NzUsMjYzMD
c1OTUwLC01MTg3MDYwNDQsLTIwMDk1MTgwNjEsMTU5NTA2NjEw
NSwtNzcxOTMxNTAxLC0xMDc3MzA5MTQ1LDg2NDA0NDQ5OCwxOD
k3MzQ2NzUsLTQ1Njc3OTUyMCw3MTI4OTM2NjYsNzMzNTk0MjEy
XX0=
-->