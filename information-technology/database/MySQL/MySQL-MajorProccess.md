# Overview

MySQL 실행 계획 성능에 큰 영향을 미치는 작업 단위에 대해 더 자세히 알아 보자. 
풀 테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리되는 내용임을 명심하자. 또한 MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 큰 영향을 미치는데, 안타깝게도 모두 쿼리의 성능을 저하 시킨다. 

스토리지 엔진에서 읽은 레코드를 MySQL엔진이 아무런 가공 없이 반환하면 최상의 성능을 보장하겠지만, 우리가 원하는 결과는 대부분 그렇지 않다. MySQL엔진에서 처리하는 시간이 오래걸리는 작업의 원리를 안다면 쿼리 튜닝에 큰 도움이 될것이다. 

# 풀 테이블 스캔(full table scan)

인덱스를 사용하지 않고 테이블 전체를 읽어 작업을 처리한다. 풀 테이블 스캔은 아래와 같은 조건에서 주로 풀테이블 스캔을 선택한다.

* 테이블의 레코드가 원채 적어서 풀 테이블 스캔이 더 빠른 경우
* WHERE 절이나 ON 절에서 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
* 인덱스 래이진 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(통계 정보기준)
* max_seeks_for_key 변수를 특정 값(N)으로 설정하면 인덱스의 기수성(Cardinality)나 선택도(selectivity)를 무시하고, 최대 N건만 읽으면 된다고 판단한다. 이 값이 작으면 인덱스를 더 사용하도록 유도할 수 있다.

일반적으로 테이블 전체 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기가 필요하다. 그래서 대부분의 DBMS는 풀 테이블 스캔시 한꺼번에 가져올 여러개의 블럭이나 페이지를 읽어오는 기능이 있고, 그 수를 조절할 수 있다. 하지만 MySQL에서는 예외적으로 풀 테이블 스캔을 할때 한꺼번에 몇 개씩 블럭이나 페이지를 가져올지 설정하는 변수가 없다. 그래서 많은 개발자가 MySQL이 풀 테이블 스캔시 디스크로부터 블럭이나 페이지를 하나씩 읽어 오는것으로 착각할때가 많다. 

사실 MyISAM 스토리진 엔진에서는 페이지를 하나씩 읽어오고 InnoDB에서는 아니다. InnoDB 스토리지 엔진은 특정 테이블에서 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어해드(Read ahead) 작업이 자동시작된다. 즉 풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 백 그라운드 스레드가 읽기를 넘겨받는 시점부터는 한번에 4개 또는 8개씩의 페이지를 읽으면서 그 수를 증가시킨다. 그리고 한번에 최대 64개의 페이지를 읽어 버퍼풀에 저장해둔다. 포그라운드 스레드는 미리 버퍼풀에 올라간 데이터를 가져다 사용하기만 되므로 쿼리가 상당히 빠르게 처리된다. 

리드 어해드(Read ahead)
: 어떤 영역의 데이터가 앞으로 필요해지리라 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB 풀에 가져다 두는 것을 말한다.

MySQL 5.1의 InnoDB 플러그인 버전 부터는 언제 리드 어해드를 사용할지 시스템 변수로 변경할 수 있다. 이 변수 이름은 innodb_read_ahead_threshold인데, 일반적으로는 디폴트 설정으로도 충분하지만 테이터웨어하우스용으로 MySQL을 사용한다면 이 옵션 값을 낮추어 더 자주 리드 어해드가 시작되도록 유도하는 것도 좋다.

# ORDER BY 처리(Using filesort)

레코드를 한 두건 가져오는 쿼리를 제외하고는 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 데이터웨어 하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 아마 레코드 정렬 요건은 대부분의 조회 쿼리에 포함되어 있을것이다. 정렬을 처리하는 방법으로는 인덱스를 이용한 방법과 쿼리가 실행될때 "Filesort"라는 별도의 처리를 이용하는 방법이 있다.

* 인덱스 이용 방법
	* 장점: INSERT, UPDATE, DELETE 쿼리가 실행될때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되어 매우 빠르다.
	* 단점: INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 필요하다. 인덱스 개수가 늘어날 수록 버퍼풀 메모리가 더 필요하다. 
* Filesort 이용 방법
	* 장점: 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이 된다. 정렬해야할 레코드가 적으면 메모리에서 충분히 Filesort 처리가 빠르다.
	* 단점: 정렬 작업이 쿼리 실행시 실행되므로 레코드 대상 건수가 많아질 수록 응답이 느리다.

물론 레코드를 정렬하기 위해 항상 Filesort라는 정렬 작업을 거쳐야 하는 것은 아니다. 아쉽게도 아래와 같은 이유로 모든 정렬에 인덱스를 이용하기에 어려움이 있다.

*

*

# Distinct 처리

# 임시 테이블(Using temporary)

# 테이블 조인(table join)
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwODk3NjU4ODAsLTEwMzYxNjg2ODYsLT
Q2MTUxNDEwOCwtMTMyMjQ0MDY0OSwtNTY0MzA4ODIxLC0yMzE3
MjIwNzQsMjg2NjA3OTUxLC0xODA4OTQxMTY5LDE4NDE5NTc2MT
EsMTEwOTQ1OTI0MCwtNjE0Mzc1OTg4LC0yODI0MTAzNV19
-->