# Overview

MySQL 실행 계획 성능에 큰 영향을 미치는 작업 단위에 대해 더 자세히 알아 보자. 
풀 테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리되는 내용임을 명심하자. 또한 MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 큰 영향을 미치는데, 안타깝게도 모두 쿼리의 성능을 저하 시킨다. 

스토리지 엔진에서 읽은 레코드를 MySQL엔진이 아무런 가공 없이 반환하면 최상의 성능을 보장하겠지만, 우리가 원하는 결과는 대부분 그렇지 않다. MySQL엔진에서 처리하는 시간이 오래걸리는 작업의 원리를 안다면 쿼리 튜닝에 큰 도움이 될것이다. 

# 풀 테이블 스캔(full table scan)

인덱스를 사용하지 않고 테이블 전체를 읽어 작업을 처리한다. 풀 테이블 스캔은 아래와 같은 조건에서 주로 풀테이블 스캔을 선택한다.

* 테이블의 레코드가 원채 적어서 풀 테이블 스캔이 더 빠른 경우
* WHERE 절이나 ON 절에서 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
* 인덱스 래이진 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(통계 정보기준)
* max_seeks_for_key 변수를 특정 값(N)으로 설정하면 인덱스의 기수성(Cardinality)나 선택도(selectivity)를 무시하고, 최대 N건만 읽으면 된다고 판단한다. 이 값이 작으면 인덱스를 더 사용하도록 유도할 수 있다.

일반적으로 테이블 전체 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기가 필요하다. 그래서 대부분의 DBMS는 풀 테이블 스캔시 한꺼번에 가져올 여러개의 블럭이나 페이지를 읽어오는 기능이 있고, 그 수를 조절할 수 있다. 하지만 MySQL에서는 예외적으로 풀 테이블 스캔을 할때 한꺼번에 몇 개씩 블럭이나 페이지를 가져올지 설정하는 변수가 없다. 그래서 많은 개발자가 MySQL이 풀 테이블 스캔시 디스크로부터 블럭이나 페이지를 하나씩 읽어 오는것으로 착각할때가 많다. 

사실 MyISAM 스토리진 엔진에서는 페이지를 하나씩 읽어오고 InnoDB에서는 아니다. InnoDB 스토리지 엔진은 특정 테이블에서 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어해드(Read ahead) 작업이 자동시작된다. 즉 풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 백 그라운드 스레드가 읽기를 넘겨받는 시점부터는 한번에 4개 또는 8개씩의 페이지를 읽으면서 그 수를 증가시킨다. 그리고 한번에 최대 64개의 페이지를 읽어 버퍼풀에 저장해둔다. 포그라운드 스레드는 미리 버퍼풀에 올라간 데이터를 가져다 사용하기만 되므로 쿼리가 상당히 빠르게 처리된다. 

리드 어해드(Read ahead)
: 어떤 영역의 데이터가 앞으로 필요해지리라 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB 풀에 가져다 두는 것을 말한다.

MySQL 5.1의 InnoDB 플러그인 버전 부터는 언제 리드 어해드를 사용할지 시스템 변수로 변경할 수 있다. 이 변수 이름은 innodb_read_ahead_threshold인데, 일반적으로는 디폴트 설정으로도 충분하지만 테이터웨어하우스용으로 MySQL을 사용한다면 이 옵션 값을 낮추어 더 자주 리드 어해드가 시작되도록 유도하는 것도 좋다.

# ORDER BY 처리(Using filesort)

레코드를 한 두건 가져오는 쿼리를 제외하고는 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 데이터웨어 하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 아마 레코드 정렬 요건은 대부분의 조회 쿼리에 포함되어 있을것이다. 정렬을 처리하는 방법으로는 인덱스를 이용한 방법과 쿼리가 실행될때 "Filesort"라는 별도의 처리를 이용하는 방법이 있다.

* 인덱스 이용 방법
	* 장점: INSERT, UPDATE, DELETE 쿼리가 실행될때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되어 매우 빠르다.
	* 단점: INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 필요하다. 인덱스 개수가 늘어날 수록 버퍼풀 메모리가 더 필요하다. 
* Filesort 이용 방법
	* 장점: 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이 된다. 정렬해야할 레코드가 적으면 메모리에서 충분히 Filesort 처리가 빠르다.
	* 단점: 정렬 작업이 쿼리 실행시 실행되므로 레코드 대상 건수가 많아질 수록 응답이 느리다.

물론 레코드를 정렬하기 위해 항상 Filesort라는 정렬 작업을 거쳐야 하는 것은 아니다. 아쉽게도 아래와 같은 이유로 모든 정렬에 인덱스를 이용하기에 어려움이 있다.

* 정렬 기준이 너무 많아 모든 기준에 맞는 인덱스를 생성하는 것이 불가능한 경우
* GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 다시 정렬해야 하는 경우
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
* 랜덤하게 결과 레코드를 가져와야 하는 경우(때로는 인덱스를 이용하도록 개선할 수 있다)

MySQL이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 Extra 컬럼에 "Using filesort" 멘트가 표시되는 것으로 판단할 수 있다. 

## 소트 버퍼(Sort buffer)

MySQL 정렬을 위해서는 별도의 메모리 공간을 할당 받는데 이 공간을 소트 버퍼(sort buffer)라 한다. 소트 버퍼는 정렬이 필요한 경우만 할당되면, 버퍼의 크기는 정렬해야한 레코드의 크기에 따라 가변적으로 증가한다. 하지만 최대 사용 가능한 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다. 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

자 이제 정렬해야 할 레코드의 건수가 sort_buffer_size 보다 더 크다면 어떻게 될까? 이러면 MySQL은 정렬해야할 레코드를 여러 조각 나누어 처리하는데 이 과정에서 디스크를 사용하게 된다.

메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기론해 둔다. 그 다음 레코드를 가져와서 정렬하고 반복적으로 디스크에 임시 저장한다.  이처럼 각 버퍼 크기 만큼씩 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다. 이 병합 작업을 멀티 머지(Multi-merge)라고 표현하며, 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수(SHOW STATUS VARIABLES; 명령 참조)에 누적된다.

모든 작업들은 모두 디스크 I/O를 유발하며, 레코드 건수가 많을 수록 이 반복 잡어의 횟수가 많아진다. 물론 소트 버퍼를 크세 설정하면 디스크를 사용하지 않아서 더 빨라질 것으로 생각할 수 있으나 실제 벤치마크 결과론 거의 차이가 없었다. MySQL에서는 소트 버퍼 크기가 256KB에서 512KB일때 최적의 성능을 보였으며 그 이후로는 아무리 소트 버퍼 크기를 늘려도 성능상 차이가 없었다. 소트 버퍼의 이런 특성은 리눅스의 메모리 할당 방식이 원인일 것으로 예측하지만 정확한 원인은 아직 확인된바가 없다.

경험상 소트 버퍼의 크기는 56KB에서 1MB 미안일때가 적절하다고 생각한다. MySQL은 글로벌 메모리 영역과 세션(로컬) 메모리 영역으로 나뉘는데. **소트 버퍼는 세션 메모리 영역에 해당한다.** 즉 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 없다. 커넥션이 많을 수록, 정렬 작업이 많을 수록 소트 버퍼로 사용되는 메모리 공간이 커진다. 소트 버퍼의 크기를 터무니 없이 크게 잡을 수 있지만 그렇게 되면 운영체제는 메모리 부족현상을 겪을 수 있다. 이럴 경우 운영체제의 정책은 메모리를 가장 많이 사용하고 있는 프로세스를 강제 종료하는데 일반적으로 MySQL 서버가 가장 많은 메모리를 사용하기 때문에 강제 종료 1순위가 된다.

>주의
>소트 버퍼를 크게 설정해서 빠른 성능을 없을 수는 없지만 디스크의 I/O 사용량은 줄일 수 있다. 따라서 MySQL 서버의 데이터가 많거나 디스크 I/O의 성능이 떨어진다면 소트 버퍼의 크기를 더 크게 설정해서 도움이 될 수 도 있다. 하지만 소트 버퍼를 너무 크게 설정하면 서버 메모리 공간이 부족해지기 때문에 소트 버퍼의 크기는 적절히 설정하도록 하자.

## 정렬 알고리즘

레코드 전체를 소트 버퍼에 담을지 아니면 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 두 가지 정렬 알고리즘을 사용할 수 있다.

### 싱글 패스(Single pass) 알고리즘

소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 되는 컬럼 전부를 담아서 정렬을 수행하는 방법이다. MySQL 5.0 이후 도입된 비교적 최식 버전의 정렬법이다.

```
SELECT first_name, last_name
FROM employees
ORDER BY first_name
```

처음 employees 테이블을 읽을때, 정렬에 직접 필요하지 않은 last_name까지 전부 읽어 소트 버퍼에 담고 정렬을 수행한다. 그리고 정렬이 완료되면 그대로 정렬 버퍼의 내용을 클라이언트에게 넘겨준다. 

### 투 패스(Two pass) 알고리즘

정렬 대상 컬럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어 필요한 컬럼 정보를 가져오는 알고리즘으로, 오랫동안 MySQL에서 사용하던 방법이다. MySQL 5.0 이상에서도 특정 조건에는 이 방법을 사용한다. 

```
SELECT first_name, last_name
FROM employees
ORDER BY first_name
```

처음 employees 테이블을 읽을 때는 정렬에 필요한 first_name 컬럼과 프라이머리 키인 emp_no만 읽어서 정렬을 수행했음을 알 수 있다. 이 정렬이 완료되면 그 결과 순서대로 employees 테이블을 한번 더 읽어서 last_name을 가져와 결과로 반환한다.

MySQL의 투패스 알고리즘은 같은 레코드를 두번 읽어야 하기 때문에 상당히 불합리 하지만 새로운 정렬방식인 싱글 패스(Single pass)알고리즘은 이런 불합리한 점이 없다. 하지만 싱글 패스 알고리즘은 더 많은 소트 버퍼 공간이 필요하다. 

대략 128KB의 정렬 버퍼를 쓴다면, 싱글에서는 대략 3500건, 투패스에서는 7000건의 레코드를 정렬할 수 있다. 

최근 MySQL은 싱글 패스 알고리즘을 쓰지만 아래 상황일때는 투 패스 알고리즘을 사용한다. 

* 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클때
* BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될때 

싱글 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 많은 경우 효율적이다. 

>SELECT 쿼리에서 꼭 필요한 컬럼만 조회하지 않고, 모든 컬럼(*)을 가져오도록 개발할때가 있다. 하지만 이는 정렬 버퍼를 비효율적으로 만들 가능성이 매우 크다. SELECT 쿼리에서 꼭 필요한 컬럼만 조회하도록 쿼리를 작성하도록 하는 것이 좋다고 권장하는 이유가 바로 이것 때문이다. 특히나 정렬이 필요한 SELECT는 불필요한 컬럼을 SELECT 하지 않도록 하는 것이 효율적이다. 이는 꼭 정렬 버퍼에만 영향을 미치는 것이 아니라 임시 테이블이 필요한 테이블에서도 영향을 미친다.

## 정렬의 처리방식

쿼리에 ORDER BY가 사용되면 반드시 아래 3가지 처리 방식 중 하나로 정렬이 처리된다. 일반적으로 밑쪽에 있는 정렬 방버븡로 갈수록 처리가 느려진다.

|정렬 처리 방법| 실행 계획의 Extra 커멘트  |
|--|--|
|인덱스 사용한 정렬  | 별도의 내용 표기 없음|
|드라이빙 테이블만 정렬 | Using filesort 표시|
|조인 결과를 임시 테이블 저장후,임시 테이블에서 정렬 | Using temporary; Usingfilesort가 같이 표시됨|

먼저 옵티마이저는 정렬처리를 위해 인덱스를 사용할 수 있을지 검토할 것이다. 만약 인덱스를 이용 할 수 있다면 별도의 Filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다. 하지만 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리한다.(Filesort) 이때 MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 두 방법 중 하나를 선택한다.

* 드라이빙 테이블만 정렬한 다음 조인 수행
* 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

일반적으로 조인이 수행되면서 레코드 건수는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다. 그래서 첫 번째 방법이 더 효율적으로 처리 된다.

### 인덱스 사용 정렬

인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 또한 WHERE 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. 

참고로 B-Tree 계열의 인덱스가 아닌 인덱스(해시 인덱스나 전문 검색 인덱스 등)에서는 이 인덱스 사용 정렬을 사용할 수 없다. 

인덱스를 이용해 처리하는 경우는 실제 인덱스의 값이 정렬되어 있기 때문에 단지 순서대로 읽기만 하면 된다. 실제로 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않는다. 

```
SELECT * FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no;

-- emp_no 컬럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동 정렬이 된다고 해서
일부러 ORDER BY e.emp)no를 제거하는 것은 좋지 않다.

SELECT * FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020;
```

>ORDER BY 주의할 점
>ORDER BY 절을 넣지 않아도 자동으로 정렬된다고 해서 ORDER BY를 빼는 경우가 있다. 혹시나 ORDER BY 절을 포함하면 MySQL 서버가 별도로 정렬 작업을 더 할까봐 걱정스러워서이다. 하지만 MySQL 서버는 졍렬을 인덱스로 처리할 수 있다면 절대 부가적으로 불필요한 정렬 작업을 하지 않는다. 그래서 인덱스 정렬이 처리될때 ORDER BY를 넣어도 작업량이 늘지 않는다. 또한, 어떤 이유 때문에 쿼리의 실행 계획이 조금 변경된다면 ORDER BY가 명시되지 않은 쿼리는 결과가 기대했던 순서대로 가져오지 못해 버그가 될 수도 있다. 하지만 ORDER BY를 명시해두면 성능상의 손해가 없음은 물론이고 이런 예외 상황도 버그로 연결되지 않을 것이다. 

### 드라이빙 테이블만 정렬

일반적으로 조인이 수행되면 결과 레코드의 건수가 몇배로 불어난다. 그래서 조인 전에 첫 번재 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이다. 이 방법은 조인에서 첫 번재 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절이 작성되어야 한다. 

```
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 AND 100010
order by e.last_name;
```

우선 WHERE 절의 조건이 다음 두 조건을 가지기 때문에 employees 테이블을 드라이빙 테이블러 선택할 것이다.

1. WHERE 절의 검색 조건(e.emp_no between ...)은 employees 테이블의 프라이머리 키를 이용해 작업량을 줄일 수 있다.
2. 드리븐 테이블(s.salaries)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다. 

검색은 인덱스 레인지 스캔으로 처리할 수 있지만 **ORDER BY 절에 명시된 컬럼은 employees 테이블의 프라이머리 키와 전혀 연관이 없으므로 인덱스를 이용한 정렬은 불가능하다.** 그런데 ORDER BY의 정렬 기준 컬럼이 드라이빙 테이블(employees)에 포함된 컬럼이다. 옵티마이저는 이럴 경우 드라이빙 테이블만 검색해서 정렬을 먼저 수행(File sort)하고, 그 결과로 salaries 테이블과 조인을 할 것이다. 

### 임시 테이블에서 정렬

쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT해서 정렬하는 경우라면 임시 테이블이 필요하지 않는다. 하지만 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다. 

앞에서 본 드라이빙 테이블 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다. 하지만 그 밖에 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다. 이 방법은 세 가지 방법 중에 정렬해야할 레코드 건수가 가장 많아지기 때문에 가장 느린 정렬법이다.  

```
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 AND 100010
order by s.salary;
```

하지만 이번 쿼리에서는 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블(salaries)에 있는 컬럼이다. 즉 정렬이 수행되기 전에 반드시 salaries 테이블을 읽어야 하므로 반드시 조인된 데이터를 가지고 정렬할 수 밖에 없다. 


|id| select_type|table|type|key|key_len|ref|rows|Extra
|--|--|--|--|--|--|--|--|--|
|1| SIMPLE|e|range|PRIMARY|4| | 9| Using where; Using temporary; Using filesort
|1| SIMPLE| s|ref|PRIMARY|4|e.emp_no|4|

## 정렬 방식의 성능 비교

주로 웹 서비스용 쿼리에서는 ORDER BY와 함께 LIMIT가 거의 필수적으로 사용되는 경향이 있다. 일반적으로 LIMIT는 테이블의 처리 결과 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다. 그런데 **ORDER BY나 GROUP BY와 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서 처리될 수 없다.** 
우선조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그룹핑 작업을 실행해야마나 비로서 LIMIT 건수를 제한할 수 있다. WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다. 

쿼리에 인덱스를 사용하지 못하는 정려이나 그룹핑 작업이 왜 느리게 작동할 수 밖에 없는지 보자. 이를 위해 쿼리가 처리되는 방법 "스트리밍 처리"와 "버퍼링 처리" 두 가지 방식을 구분해보자.

### 스트리밍(Streaming) 방식

서버 쪽에서 처리해야할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식이다. 이 방식으로 처리할 경우 클라이언트는 쿼리를 요청하고 곧 바로 원했던 첫번째 레코드를 받을 것이다. 물론 마지막 레코드를 언제 받을지는 모르지만 이는 중요하지 않다. 

쿼리가 스트리밍 방식으로 전달되면 클라이언트는 일치하는 레코드를 즉시 전달받기 때문에 동시에 데이터 가공작업을 할 수 있다. 웹 서비스와 같은 OLTP 환경에서는 쿼리의 요청에서부터 첫 번째 레코드를 전달 받기 까지 응답 시간이 중요하다. 스트리밍 방식으로 처리되는 쿼리는 그 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관 없이 빠른 응답시간을 보장한다.

또한 스트리밍 방식으로 처리되는 쿼리에서 LIMIT와 같이 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있다. 매우 큰 테이블을 아무 조건 없이 SELECT 해보면 아주 빨리 첫번째 레코드는 가져올 수 있다. 

>참고 
>스트리밍 처리는 어떤 클라이언트 도구나 API를 사용하느냐에 따라 그 방식에 차이가 있다. 대표적으로 JDBC 라이브러리를 이용해 SELECT 쿼리를 실행하면 레코드를 읽자마자 클라이언트로 그 결과를 전달할 것이다. 하지만 JDBC는 레코드 자체를 버퍼에 모두 담아두다가 마제막 레코드가 전달될 때까지 기다렸다가 모든 결과를 전달 받으면 그때서야 비로서 클라이언트의 애플리케이션에 반환한다. 즉 MySQL 서버는 스트리밍 방식으로 처리하지만 클라이언트의 JDBC 라이브러리가 버퍼링을 한다. 하지만 JDBC가 아닌 SQL 클라이언트 도구는 이러한 버퍼링을 하지 않기 때문에 아무리 큰 테이블이라도 첫 레코드는 매우 빨리 가져온다. 
>JDBC 라이브러리가 자체적으로 레코드를 버퍼링하는 이유는 이 방식이 전체 처리량(Throughput)에서 뛰어나기 때문이다. 이 방식은 JDBC 라이브러리와 MySQL 서버가 대화형으로 주고 받는것이 아니라 MySQL 서버는 데이터의 크기에 관계없이 무조건 보내고, JDBC MySQL 서버로부터 전송되는 데이터를 받아서 저정만 하므로 불필요한 네트워크 요청이 최소화되기 때문에 전체 처리량이 뛰어난 것이다. 
>하지만 JDBC의 버퍼링 처리 방식은 기본 작동 방식이며, 아주 대량의 데이터를 가져와야 할때는 MySQL 서버와 JDBC간의 전송 방식을 스트리밍으로 변경할 수 있다. 

###  버퍼링(Buffering) 방식

ORDER BY나 GROUP BY와 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다. 왜냐하면 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후에 정렬하거나 그룹핑을 통해 차례대로 보내야 하기 때문이다. MySQL 서버가 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다. 

버퍼링 방식으로 처리되는 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로 부터 가져올때 까지 기다려야 한다. 그래서 버퍼링 방식은 LIMIT 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 큰 도움이 되지 않는다. 네트워크로 전송되는 건수는 줄일 수 있지만 MySQL 서버에서 해야하는 작업량에는 크게 변화가 없기 때문이다. 

인덱스를 사용한 정렬 방식만 스트리밍 형태로 처리가 가능하며, 나머지는 모두 버퍼링된 후에 정렬된다. 즉 인덱스를 사용한 정렬 방식은 LIMIT 제한 건수만큼만 읽으면서 바로 클라이언트에 결과를 전송해줄 수 있다. 하지만 인덱스를 사용하지 못하는 경우의 처리는 필요한 레코드를 읽어서 정렬한 후에 LIMIT 건수만큼 잘라서 클라이언트로 전송해줄수 있다.

조인과 함께 ORDER BY 절과 LIMIT 절이 함께 사용할 경우, 정렬의 각 처리 방식별로 어떤 차이가 있는지 좀 더 자세히 살펴보자.

```
SELECT *
FROM tb_test1, tb_test2
WHERE t1.col=t2.col1
ORDER BY t1.col2
LIMIT 10
```

tb_test1 테이블의 레코드가 100건이고, tb_test2 테이블의 레코드가 1000건이라 하자. 그리고 tb_test1 1건당 tb_test2 레코드가 10건씩 있다고 가정하자. 두 테이블 조인 결과는 전체 1000건이라고 가정하고 정렬의 처리 방식별로 읽어야 하는 레코드 건수와 정렬을 수행해야 하는 레코드 건수를 비교해보자.

* tb_test1이 드라이빙 테이블이 되는 경우

|정렬방식|읽어야 하는 건수 | 조인 횟수 | 정렬해야 하는 대상 건수|
|--|--|--|--|
|인덱스 사용|tb_test1 : 1건, tb_test2 : 10건|1번|0건|
|드라이빙 테이블만 정렬|tb_test1 : 100건, tb_test2 : 10건|10번|100건|
|임시 테이블 사용 후 정렬|tb_test1 : 100건, tb_test2 : 1000건|100번(tb_test1 테이블의 레코드 건수만큼 조인 발생)|1000건(조인된 결과 레코드 건수를 전부 정렬해야 함|

* tb_test2가 드라이빙되는 경우

 |정렬방식|읽어야 하는 건수 | 조인 횟수 | 정렬해야 하는 대상 건수|
|--|--|--|--|
|인덱스 사용|tb_test2 : 10건, tb_test1 : 10건|10번|0건|
|드라이빙 테이블만 정렬|tb_test2 : 1000건, tb_test1 : 10건|10번|1000건(tb_test2 테이블의 레코드 건수만큼 정렬필요)|
|임시 테이블 사용 후 정렬|tb_test2 : 1000건, tb_test1 : 100건|1000번(tb_test2 테이블의 레코드 건수만큼 조인 발생)|1000건(조인된 결과 레코드 건수를 전부 정렬해야 함|

어느 테이블이 먼저 드라이빙 되어 조인되는지도 중요하지만 어떤 정렬방식으로 처리 되는지는 더 큰 성능차이를 만든다. 가능하다면 인덱스를 사용한 정렬로 유도하고 그렇지 못한다면 최소한 드라이빙 테이블 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법이다.

> 인덱스를 사용하지 못하고 별도로 Filesort 작업을 거쳐야 하는 쿼리에서 LIMIT 조건이 아무런 도움이 되지 못하는 것은 아니다. 정렬해야할 대상 레코드가 1000건인 쿼리에 LIMIT10이라는 조건이 있다면 MySQL 서버는 1000건의 레코드를 모두 정렬하는 것이 아니라 필요한 순서대로 정렬해서 상위 10건만 정렬이 채워지면 정렬을 멈추고 결과를 반환한다. 하지만 MySQL 서버는 정렬을 위해 퀴소트 알고리즘을 사용한다. 이는 LIMIT 10을 만족하는 상위 10건을 정렬하기 위해 더 많은 작업이 필요할 수도 있다. 결론적으로 인덱스를 사용하지 못하는 쿼리를 페이징 처리에 사용하는 경우 LIMIT로 5~10건만을 조회하더라한다고 해도 쿼리가 기대 만큼 빨라지지는 않는다. 

## 정렬 관련 상태 변수 

MySQL 서버는 처리하는 주요 작업에 대해서 해당 작업의 실행 횟수를 상태 변수로 저장하고 있다. 정렬과 관련해서도 몇건의 레코드를 처리 했는지, 소트 버퍼간의 병합 작업(멀티 머지)은 몇번 발생했는지 등을 아래 명령으로 확인이 가능하다. 

```
SHOW SESSION STATUS LIKE 'Sort%';
+-------------------------------+
|Variable name		|Value		|
+-------------------------------+
|Sort_merge_passes	|56			|
|Sort_range			|0			|
|Sort_rows			|279408		|
|Sort_scan			|1			|
```
각 상태은 아래와 같은 의미를 가진다.

* Sort_merge_passes는 멀티 머지 횟수를 말한다.
* Sort_range는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다.
* Sort_scan은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다. Sort_scan과 Sort_range는 둘다 정렬 작업 횟수를 누적하고 있는 상태 값이다. 
* Sort_rows는 지금까지 정렬한 전체 레코드 건수를 의미한다. 

# Group BY 처리

GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍 처리를 할 수 없게 하는 요소 중 하나다. GROUP BY 절이 있는 쿼리에서는 HAVING 절을 사용할 수 있는데,  HAVING 절은 GROUP BY 결과에 대해서 필터링 역할을 수행한다. 

일반적으로 GROUP BY 처리 결과는 임시 테이블이나 버퍼에 존재하는 값을 필터링 하는 역할을 수행한다.  GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없다. 

GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다. 인덱스를 이용할때는 인덱스를 차례대로 이용하느 인덱스 스캔 방법과 인덱스를 건너 뛰면서 읽는 루즈 인덱스 스캔이 있다. 그리고 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다.

## 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

ORDER BY 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그룹핑할 때 GROUP BY 컬럼으로 이미 인덱스가 있다면 그 인덱스를 차례때로 읽으면서 그룹핑 작업을 수행하고 결과를 조인으로 처리한다. GROUP BY가 인덱스를 사용한다고 하더라도 그룹 함수 등의 그룹 값을 처리해야할 임시 테이블이 필요할 때도 있다. 

GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것으로 추가적인 정렬 작업은 필요치 않다. 이런 그룹핑 방식을 사용하는 쿼리의 실행 계획에서는 Extra 컬럼에서 Using index for group-by나 임시 테이블이나 정렬 관련 커멘트(Using temporary, Using filesort)가 표시 되지 않는다. 

## 루즈 인덱스 스캔을 이용하는 GROUP BY

루즈 인덱스 스캔 방식은 인덱스 레코드를 건너 뛰면서 필요한 부분만 가져오는 것을 말한다. 예를 들어 한번 이야기를 해보겠다. 

```
EXPLAIN
SELECT emp_no
FROM salaries 
WHERE from_date = '1985-03-01' -- 다중 인덱스의 두번째
GROUP BY emp_no -- 다중 인덱스의 첫번째
```

salaries 테이블의 인덱스는 (emp_no + from_date)로 생성되어 있다. 쿼리 문장에서 Where 조건은 인덱스 레인지 스캔 방법으로 접근할 수 없는 상태이다. 하지만 실제 실행 계획을 보면 인덱스 레인지 스캔을 이용하며, Extra 컬럼의 Using index for group-by가 노출 된다.

MySQL 서버가 어떻게 레인지 스캔을 했는지 순서대로 정리해보자. 

1. (emp_no + from_date) 인덱스를 차례대로 스캔하면서, emp_no의 첫 번째 유일한 값(그룹 키) '10001'을 찾아낸다.
2. (emp_no + from_date) 인덱스에서 emp_no가 '10001'인 것 중에서 from_date 값이 '1985-03-01' 인 레코드만 가져온다. 
3. (emp_no + from_date) 인덱스에서 emp_no의 그 다음 유니크한(그룹 키) 값을 가져온다. 
4. 3번 단계에서 결과가 더 없으면 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아가서 반복 수행한다.

**MySQL의 루즈 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.** 또한 프리픽스 인덱스(Prefix index, 칼럼값의 앞쪽 일부만으로 생성된 인덱스)는 루즈 인덱스 스캔을 사용할 수 없다. 

인덱스 레인지 스캔은 유니크한 값의 수가 많을 수록 성능이 향상 되지만 반면 루즈 인덱스 스캔은 인덱스의 유니크한 값이 적을수록 성능이 향상 된다. **일반적인 상황과 다르게 루즈 인덱스 스캔은 분포도가 좋지 않을 수록 더 빠른 결과를 만든다.** 그리고 루즈 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다. 

루즈 인덱스 스캔이 사용될 수 있을지 없을지 판단하는 것은 WHERE 절의 조건이나 ORDER BY 절이 인덱스를 사용할 수 있을지 판단하는 것보다 더 어렵다. 다음 예로 루즈 인덱스 스캔을 사용할 수 있을지 판단하는 연습을 해보자.

우선, (col1+col2+col3) 컬럼으로 생성된 tb_test 테이블을 만들어 보자. 그리고 아래 쿼리들은 모두 루즈 인덱스 스캔을 사용할 수 있는 쿼리다. 

```
SELECT col1, col2 FROM tb_test GROUP BY col1, col2;
SELECT DISTINCT col1, col2 FROM tb_test;
SELECT col1, MIN(col2) FROM tb_test GROUP BY col1;
SELECT col1, col2 FROM tb_test WHERE co1 < const GROUP BY col1, col2;
SELECT MAX(col3), MIN(col3), col1, col2 FROM tb_test WHERE co2 > const GROUP BY col1, col2;
SELECT col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;
SELECT col1, col2 FROM tb_test WHERE col3 = const GROUP BY col1, col2;
```

다음 쿼리는 루즈 인덱스 스캔을 사용할 수 없는 경우다. 

```
-- MIN, MAX 이외의 집합 함수가 사용되었기 때문에 사용불가
SELECT col1, col2 FROM tb_test GROUP BY col1, col2;

-- GROUP BY에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치하지 않기 때문에 불가
SELECT col1, col2 FROM tb_test GROUP BY col2, col3

-- SELECT 절의 컬럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
SELECT col1, col3 FROM tb_test GROUP BY col1, col2
```
>참고사항
>일반적으로 B-Tree 인덱스는 인덱스를 구성하는 컬럼이 왼쪽부터 일치하는 (leftmost) 일때만 사용할 수 있다. 하지만 루즈 인덱스 스캔은 인덱스의 첫 컬럼이 WHERE 조건이나 GROUP BY 조건에 사용되지 않아도 B-Tree 인덱스를 사용할 수 있는 방식이다. 오라클과 같은 DBMS에서는 옵티마이저가 인덱스의 첫번째 컬럼에 대한 조건을 마음대로 만들어 추가하는 형태로 기능이 구현되어 있다. 하지만 MySQL의 루즈 인덱스 스캔은 아직 초기 수준으로 최적화가 되어 있지 않다.

## 임시 테이블을 사용하는 GROUP BY

GROUP BY의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계 없이 인덱스를 전혀 사용하지 못할때 사용하는 방식이다. 
인덱스를 사용할 수 없기 때문에 필요한 조인 결과를 임시 테이블에 저장하고 필요시 정렬을 하고 사용자에게 결과를 반환한다.

이때 중요한 것은 원본 쿼리에서 **GROUP BY 절에 사용된 컬럼을 기준으로 유니크 키를 생성한다는 점이다.**  즉 GROUP BY가 임시 테이블로 처리가 되는 경우 사용되는 임시 테이블은 항상 유니크 키를 가진다. 

# Distinct 처리

특정 컬럼의 유니크한 값만 조회하려면 SELECT에 DISTINCT를 사용한다. DISTINCT는 MIN, MAX 또는 COUNT와 같은 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우로 두 가지로 나누어 생각해 볼 수 있다. 이렇게 나눈 이유는 DISTINCT 키워드가 영향을 미치는 범위가 다르기 때문이다. 
그리고 집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할때는 항상 임시 테이블이 필요하다. 

## SELECT DISTINCT 

단순히 SELECT 되는 레코드 중에 유니크한 레코드만 가져오자고 하면 SELECT DISTINCT 형태의 문장을 사용한다. 이렬 경우 **GROUP BY와 거의 같은 방식으로 처리되며 차이는 SELECT DISTINCT의 경우에는 정렬이 보장되지 않는다는 것 뿐이다.** 

```
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no
```

DISTINCT를 사용할때 자주 실수하는 것이 있다. DISTINCT는 SELECT하는 레코드(튜플)을 유니크하게 SELECT 하는 것이지 칼럼을 유니크하게 조회하는 것이 아니다. 즉 다음 쿼리는 first_name만 유니크한 것을 가져오는게 아니라 first_name, last_name 전체가 유니크한 레코드를 가져오는 것이다.

```
SELECT DISTINCT first_name, last_name FROM employees;
```

가끔 DISTINCT를 아래와 같이 사용할때도 있다.
```
SELECT DISTINCT (first_name), last_name FROM employees;
```
위의 쿼리를 보면, first_name만 유니크하게 조회하고 last_name은 그냥 DISTINCT가 없을 때와 동일하게 조회하는 쿼리처럼 보인다. 그리고 실제로 상당히 그럴듯하게 에러 없이 실행되기 때문에 쉽게 실수할 수 있다. 하지만 MySQL서버는 **DISTINCT 뒤의 괄호를 그냥 의미 없이 사용된 괄호로 해석하고 제거해버린다.** DISTINCT는 함수가 아니므로 그 뒤의 괄호는 의미가 없는 것이다. 

```
SELECT DISTINCT first_name, last_name FROM employees;
```
**SELECT 절에서 사용된 DISTINCT는 조회되는 컬럼 모두에 영향을 미친다. 절대로 SELECT하는 여러 컬럼중 일부만 유니크하게 조회하는 방법은 없다.** 

## 집합 함수와 함께 사용된 DISTINCT

COUNT 또는 MIN, MAX와 같은 함수 내에서 DISTINCT 키워드가 사용될 수 있는데, 이 경우에는 일반적인 SELECT DISTINCT와 다른 형태로 해석된다. **집합 함수내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 컬럼 값이 유니크한 것들을 가져온다.**

```
EXPLAIN
SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100
```

이 쿼리는 COUNT(DISTINCT s.salary)를 처리하기 위해 임시 테이블을 사용한다. 하지만 임시 테이블을 사용하는 "Using temporary"가 표시되지는 않는다.

만약 위 쿼리에서 COUNT(DISTINCT ...)를 하나 더 추가해보자. COUNT(...) 함수가 두 번 사용되었기 때문에 s.salary 컬럼의 값을 저장하는 임시 테이블과 e.last_name 컬럼의 값을 저장하는 또 다른 임시 테이블이 필요하므로 전체적으로 2개의 임시 테이블을 사용한다.
```
SELECT COUNT(DISTINCT s.salary), COUNT(DISTINCT e.last_name)
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no AND e.emp_no BETWEEN 100001 AND 100100
```

위의 쿼리는 DISTINCT 처리를 위해 인덱스를 이용할 수 없어서 임시 테이블이 필요 했다. 하지만 다음 쿼리와 같이 인덱스된 컬럼에 대해 DISTINCT 처리를 수행할때 는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있다.
```
SELECT COUNT(DISTINCT emp_no) FROM employees e
SELECT COUNT(DISTINCT emp_no) FROM dept_emp GROUP BY dept_no
```

# 임시 테이블(Using temporary)

MySQL 엔진이 스토리지 엔진으로부터 받오온 레코드를 정렬하거나 그룹핑할때는 내부적인 임시 테이블을 사용한다. 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성되었다가 테이블의 크기가 커지면 디스크로 옮겨진다. 물론 특정 예외 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 한다. 

원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될때는 MyISAM 스토리지 엔진을 사용한다.

MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다. 사용자가 생성한 임시 테이블(CREATE TEMPORARY TABLE)과는 달리 내부 임시 테이블은 쿼리 처리가 완료되면 자동으로 삭제된다.

## 임시 테이블이 필요한 쿼리

아래 쿼리는 MySQL엔진에서 별도의 데이터 가공 작업이 필요로 하다.물론 이 밖에도 인덱스를 사요하지 못할때는 내부 임시 테이블을 생성해야 할때가 많다.

* ORDER BY나 GROUP BY에 명시된 컬럼이 다른 쿼리
* ORDER BY나 GROUP BY에 명시된 컬럼이 조인 순서상 첫 번째 테이블이 아닌 쿼리
* DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리 되지 못하는 쿼리
* UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 컬럼이 UNION RESULT)
* UNION ALL이 사용된 쿼리(select_type 컬럼이 UNION RESULT)
* 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리


어떤 쿼리의 실행계획에서 임시 테이블을 사용하는지는 Extra 컬럼에 Using tempoary 키워드를 보면 된다. 하지만 해당 키워드가 없을때도 임시 테이블을 사용하는 경우가 있는데, 위 예에서 마지막 3개 패턴이 그런 예다. 왜냐하면 Using temporary대신에 다른 키워드가 나타난다. 

## 임시 테이블이 디스크에 생성되는 경우(MyISAM 스토리지 엔진을 사용)
내부 임시 테이블은 기본적으로 메모리상에 만들어지지만 아래와 같은 조건일 경우 임시 테이블을 생성할 수 없어 디스크 상에 MyISAM 테이블로 만들어진다.

* 임시 테이블에 저장해야 할 내용 중 BLOB(Binary Large Object)나 TEXT와 같이 대용량 컬럼이 있는 경우
* 임시 테이블이 저장해야 하는 레코드 전체 크기나 UNION이나 UNION ALL에서 SELECT 되는 컬럼 중에서 길이가 512byte 이상인 크기의 컬럼이 있는 경우
* GROUP BY나 DISTINCT 컬럼에서 512byte이상의 컬럼이 있는 경우
* 임시 테이블에 저장할 데이터 전체 크기가 tmp_table_size 또는 max_heap_table_size 시스템 설정보다 큰 경우

첫 번째 부터 세번째 까지는 처음부터 디스크에 MyISAM 스토리지 엔진을 사용해 임시 테이블을 만든다. 하지만 네번째의 경우는 처음에 MEMORY 스토리지 엔진을 사용해 내부 임시 테이블을 생성하지만 테이블의 크기가 시스템 설정 값을 넘어서는 순간 디스크의 MyISAM 테이블로 변환된다.


## 임시 테이블 관련 상태 변수

"Using temporary"가 나타났다고 해서 메모리에서 처리되었는지 디스크에서 처리됬는지는 알수 없다. 또한 몇개의 임시 테이블이 사용됬는지도 알 수 없다. 이럴때 몇개의 임시 테이블이 디스크에 생성됬는지 메모리에 생성됬는지 파악하려면 MySQL 서버의 상태 변수를 확인해 보면 된다.

```
SHOW SESSION STATUS LIKE 'Created_tmp%'

SELECT ...
```

쿼리를 실행하기 전에 SHOW SESSION STATUS LIKE 'Created_tmp%'를 사용하면 현재 임시 테이블 사용 현황을 알려준다. SELECT 쿼리를 실행한 후, 다시 상태 조회를 해보면 누적된 값이 노출된다.

Created_tmp_tables
: 쿼리 처리를 위해 만들어진 내부 임시 테이블의 누적 갯수. 이 값은 메모리에 만들어졌는지 디스크에 만들어졌는지 구분하지 않고 모두 누적한다.

Created_tmp_dist_tables
: 디스크에 만들어진 내부 임시 테이블 개수를 누적하는 값


## 임시 테이블 주의사항

레코드 건수가 많지 않으면 임시 테이블은 메모리에 생성되고 MySQL 서버 부하에 크게 영향을 주지 않는다. **성능상 이슈가 되는 부분은 내부 임시 테이블이 MyISAM 테이블로 디스크에 생성되는 경우다.**

```
SELECT * FROM employees GROUP BY last_name ORDER BY first_name
```
위 쿼리는 GROUP BY나 ORDER BY의 컬럼이 다르고, last_name에 인덱스가 없어서 임시 테이블을 만들고 정렬작업도 해야하는 최악의 형태이다.

|id| select_type|table|type|key|key_len|ref|rows|Extra
|--|--|--|--|--|--|--|--|--|
|1| SIMPLE|employees|ALL|PRIMARY|| |300584 | Using temporary; Using filesort

대략 처리해야 하는 레코드 건수가 30만 건이다. 이 실행 계획의 내부적인 작업과정을 알아보자.

1. Employees 테이블의 모든 컬럼을 포함한 임시 테이블을 만든다.(MEMORY)
2. 테이블로부터 첫번째 레코드를 가져와서 임시 테이블에 같은 last_name이 있는지 확인한다.
3. 같은 last_name이 없으면 임시 테이블에 삽입
4. 같은 last_name이 있으면 임시 테이블에 update 또는 무시
5. 임시 테이블 크기가 특정 크기(시스템 설정) 커지면 임시 테이블을 MyISAM 테이블 디스크로 이동
6. Employees 테이블에 더 읽을 레코드가 없을때 까지 2~6번 반복
7. 임시 테이블에서 first_name으로 정렬 작업을 수행후 클라이언트에 결과 반환

여기서 성능상 중요한 점은 MEMORY 스토리지 엔진을 쓴다면 괜찮을지도 모르겠지만 디스크(MyISAM)을 거쳐 디스크에 저장된다면 적지 않은 부하가 발생하리란 것이다. 가능하다면 인덱스를 이용해 처리하고, 처음부터 임시 테이블이 필요하지 않게 만드는 것이 가장 좋다. 이것이 어렵다면 내부 임시 테이블이 메모리에서만 처리되도록 대상 레코드를 적게 만드는 것이 좋다. 하지만 가공할 데이터를 줄일 수 없다고 해서 tmp_table_size나 max_heap_table_size를 무조건 크게하는 것은 위험하다. 

임시 테이블이 MEMORY(HEAP) 테이블로 물리 메모리에 생성되는 경우도 완벽하지 않다. **MEMORY 테이블의 모든 컬럼은 고정 크기 컬럼이라는 점이다.** 따라서 실제 InnoDB 스토리지 엔진에서는 작은 크기의 컬럼이더라도 MEMORY 테이블에선 불필요하게 많은 공간을 차지하게 된다. 이러한 임시 테이블의 저장 방식때문에 SELECT하는 컬럼을 최소화하는게 좋다. (특히 BLOB이나 TEXT컬럼은 배제하는게 좋다)

# 테이블 조인(table join)

MySQL은 다른 DBMS보다 조인을 처리하는 방식이 단순하다. 조인방식은 네스티드-루프로 알려진 중첩된 루프와 같은 형태만 지원한다. 그리고 조인되는 각 테이블 간의 레코드를 어떻게 연결할지에 따라 여러 가지 종류의 조인으로 나뉜다.

조인은 크게 INNER JOIN과 OUTER JOIN으로 구분할 수 있고, OUTER JOIN은 다시 LEFT OUTER JOIN과 RIGHT OUTER JOIN 그리고 FULL OUTER JOIN으로 구분할 수 있다. 그리고 조인 조건을 어떻게 명시하느냐에 따라 NATURAL JOIN과 CROSS JOIN(FULL JOIN, CARTESIAN JOIN)으로도 구분할 수 있다.

**조인 처리에서 어느 테이블을 먼저 읽을지 결정하는 것은 매우 중요하며, 그에 따라 처리할 작업량이 크게 달라진다.** 

**INNER JOIN은 어느 테이블을 먼저 읽어도 결과가 달라지지 않으므로 MySQL 옵티마이저가 조인의 순서를 조절해서 다양한 방법으로 최적화가 가능하다.** 

**OUTER JOIN은 반드시 OUTER가 되는 테이블을 먼저 읽어야 하기 때문에 조인 순서를 옵티마이저가 선택할 수 없다.**

## INNER JOIN

일반적으로 조인이라 함은 INNER JOIN을 뜻한다. MySQL에서 조인은 **네스티드-루프 방식**만 지원한다. **네스티드-루프 방식이란 일반적으로 프로그램을 작성할 때 두개의 FOR나 WHILE과 같은 반복 루프 문장을 실행하는 형태로 조인이 처리되는 것을 의미한다.**

```
For ( record1 IN TABLE1) { //외부 루프 (OUTER)
	For ( record2 IN TABLE2 ) { //내부 루프(INNER)
		IF( record1.join_col == record2.join_col){
			join_record_found(record1.*, record2.*)
		} else {
			join_record_notfound();
		}
	}
}
```

위의 의사코드에서 알 수 있듯이 조인은 2개의 반복 루프로 두 개의 테이블을 조건에 맞게 연결해주는 작업이다. (이 의사 코드의 FOR문 반복이 풀 테이블 스캔을 의미하는 것은 아니다.)

바깥 쪽을 OUTER 테이블, 안쪽을 INNER 테이블이라 한다. 또한 OUTER 테이블은 INNER 테이블 보다 먼저 읽어야 하며, 조인에서 주도적인 역할을 한다고 해서 드라이빙 테이블이라고도 한다. INNER 테이블은 조인에서 끌려가는 역할을 한다고 하여 드리븐 테이블이라고도 한다. 

중첩된 반복 루프에서 최종적으로 선택될 레코드가 안쪽 반복 루프(INNER 테이블)로 결정되는 경우를 INNER JOIN이라 한다. 즉 두 개의 반복 루프를 실행하며 같은 조건을 만족하는 레코드만 조인의 결과로 가져온다.

## OUTER JOIN

```
For ( record1 IN TABLE1) { //외부 루프 (OUTER)
	For ( record2 IN TABLE2 ) { //내부 루프(INNER)
		IF( record1.join_col == record2.join_col){
			join_record_found(record1.*, record2.*)
		} else {
			join_record_found(record1.*, NULL); -- 같지 않으면 record1
		}
	}
}
```

이중 FOR문 안에 일치하는 레코드가 있으면 INNER JOIN과 같은 결과를 만들어 내지만, 없는 경우에는 그저 TABLE1에 있는 결과를 버리지 않고 그대로 결과에 포함한다.

INNER 테이블 조인 결과에 전혀 영향을 미치지 않고, OUTER 테이블 내용에 따라 조인의 결과가 결정되는 것이 OUTER JOIN의 특징이다. 물론 OUTER 테이블과 INNER 테이블의 관계가 1:M의 관계라면 최종 결과 레코드 건수가 늘어날 수 있지만, OUTER 테이블의 레코드가 INNER 테이블에 일치하는 레코드가 없다고 해서 버려지지는 않는다.

OUTER JOIN은 조인의 결과를 결정하는 OUTER 테이블이 조인의 왼쪽에 있는지 오른쪽에 있는지에 따라 LEFT OUTER JOIN과 RIGHT OUTER JOIN 그리고 FULL OUTER JOIN으로 나뉜다.

보통 LEFT OUTER JOIN과 RIGHT OUTER JOIN은 결국 FROM 절에 나오는 테이블의 순서에 따라 같은 처리를 만들어낼 수 있다. 이 혼동을 막기 위해 **일반적으로는 LEFT OUTER JOIN으로 통일해서 사용하는 것이 일반적이다.**

JOIN 키워드를 기준으로 왼쪽의 테이블도 OUTER JOIN을 하고 싶고, 오른쪽 테이블도 OUTER JOIN을 하고 싶은 경우 사용하는 쿼리가 FULL OUTER JOIN이다. MySQL에서는 FULL OUTER JOIN을 지원하지 않는다. 

### 주의 사항

실행 계획에서는 어떤 조인을 했는지 알려주지 않으므로 OUTER JOIN을 의도한 쿼리가 INNER JOIN으로 실행되지 않았는지 주의해야 한다. 

**레코드가 없을 수도 있는 쪽의 테이블(드라이븐)에 국한된 조건은 반드시 ON절에 명시하자.** 그렇지 않으면 옵티마이저는 OUTER JOIN을 내부적으로 INNER JOIN으로 변형 시켜 처리할 수도 있다. 
보다 원론적으로 이야기하자면, ON 과 WHERE 절에는 그 의미의 차이가 있다. ON은 두 테이블간의 관계를 묘사하고 WHERE은 결과로부터 제거해야할 로우를 묘사한다. 

```
SELECT
FROM employees e
LEFT OUTER JOIN salaries s ON s.emp_no = e.emp_no
WHERE s.salary > 5000; 
```

위 쿼리는 LEFT OUTER JOIN을 쓴 의미가 없는 코드이다. 왜냐하면 WHERE 절에  s.salary > 5000를 명시하였기 때문에 모든 결과에서 s.salary가 null인 레코드는 모두 사라져버리기 때문이다. 그래서 MySQL 서버에서 이 쿼리는 아래와 같은 쿼리로 변경 후에 실행한다. 

```
SELECT
FROM employees e
INNER JOIN salaries s ON s.emp_no = e.emp_no
where s.salary > 5000;
```

이런 형태의 쿼리는 아래 두 가지 방식중 하나로 해야 의도나 결과를 명확히 알 수 있다. 

```
-- OUTER JOIN 처리; s.salary가 null인 레코드 포함
SELECT 
FROM employees e
LEFT OUTER JOIN salaries s ON s.emp_no = e.emp_no AND s.salary > 5000;
-- OUTER JOIN pseudo 코드를 보자; s.salray가 null이라 조건에 맞지 않더라도 e 레코드를 결과로 채워넣는다. 

-- INNER JOIN; s.salary가 null인 레코드 제외
SELECT 
FROM employees e
INNER JOIN salaries s ON s.emp_no = e.emp_no
WHERE s.salary > 5000;
```

마지막으로 OUTER JOIN이 아닌 쿼리에서는 검색 조건이나 조인 조건을 WHERE 절이나 ON 절중에서 어느곳에 명시해도 성능상 문제나 결과가 차이 나지 않는다.

## CARTESIAN JOIN(FULL JOIN, CROSS JOIN)

카르테시안 조인은 FULL조인 또는 CROSS JOIN이라고도 한다. 일반적으로 조인을 수행하기 위해선 하나의 테이블과 다른 테이블간에 연결조건이 필요하다. 하지만 카르테시안 조인은 이 조긴 조건 자체가 없어 2개의 테이블의 모든 레코드 조합을 결과로 가져오는 조인 방식이다. 카르테시안 조인은 레코드 건수가 적으면 특별히 문제가 되지 않는다. 하지만 레코드 건수가 많아지면 조인 결과가 기하급수적으로 늘어나므로 MySQL 서버 자체를 응답 불능 상태로 만들어버릴 수도 있다. 

조인의 양쪽 테이블이 모두 레코드 1건인 쿼리를 제외하면, 애플리케이션에서 사용되는 카테시안 조인은 의도하지 않은 경우가 대부분이다. N개의 테이블의 조인이 수행되는 쿼리에서는 반드시 조인 조건은 N-1개(또는 그 이상)이 필요하며 모든 테이블은 반드시 1번 이상 조인 조건에 사용되야 카르테시안 조인을 피할 수 있다. 조인되는 테이블이 많아지고 조인 조건이 복자해질 수록 의도하지 않은 카르테시안 조인이 발생할 가능성이 크기 때문에 주의해야 한다.

SQL 표준에서 CROSS JOIN은 카르테시안 조인과 같은 조인 방식을 의미하지만 MySQL에서 CROSS JOIN은 INNEr JOIN고 같은 조인 방식을 말한다. MySQL에서 CROSS JOIN을 사용하는 경우 INNER JOIN과 같이 ON절이나 WHERE절에 조건을 부여하는 것이 가능하며, 이렇게 작성된 CROSS JOIN은 INNER JOIN과 같은 방식으로 동작한다. 그래서 MySQL에서 CROSS JOIN 카르테시안 조인이 될 수도 있고 아닐 수도 있다.  

사실 MySQL에서는 카르테시안 조인과 INNER JOIN이 문법으로 구분되는 것이 아니다. JOIN시 연결되는 조건이 적절히 있다면 INNER JOIN으로 연결 조건이 없다면 CARTESIAN JOIN이 되는 것이다. 그래서 사실 CROSS JOIN이나 INNER JOIN을 특별히 구분해서 사용할 필요는 없다.

## NATURAL JOIN

MySQL에서 INNER JOIN를 명시하는 방법은 여러가지가 있다. 아래 쿼리들은 모두 표기법만 다를 뿐 모두 같은 쿼리다. 
```
SELECT * 
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no;

SELECT * 
FROM employees e
INNER JOIN salaries s ON s.emp_no = e.emp_no;

SELECT * 
FROM employees e
INNER JOIN salaries s USING (emp_no)
```

참고로 Using 키워드는 두 테이블의 조인 컬럼이 같은 이름을 가질때만 사용할 수 있다.
```
SELECT * 
FROM employees e
NATURAL JOIN salaries s
```

**NATURAL JOIN은 두 테이블에 존재하는 컬럼 중에서 서로 이름이 같은 모든 컬럼으로 조인을 하게 된다.** 
즉 위 쿼리에서 employees 테이블에 존재하는 컬럼과 salaries 테이블 컬럼에 존재하는 컬럼 중에서 서로 이름이 같은 모든 컬럼으로 조인을 하게 된다. 

NATURAL JOIN은 조인 조건을 줄줄이 나열하지 않아도 된다는 편리함이 있지만, 사실 각 테이블의 컬럼이 이름에 의해 자동으로 변경될 수 있다는 문제가 있다. 즉, NATURAL JOIN으로 조인하는 테이블은 같은 컬럼명을 사용할 때 자동으로 조인 조건으로 사용되버릴 수 있다는 점을 항상 고려해야 한다. 또한 애플리케이션이 변경되면서 테이블의 구조를 변경할때도 NATURAL JOIN으로 조인되는 테이블이 있는지, 그리고 일일이 그 테이블의 컬럼을 비교하면서 같은 컬럼명이 존재하는지 확인해봐야 한다. 이는 상당히 성가신 작업이 될것이고 유지보수 비용만 높일 것이다. 따라서 NATURAL JOIN은 이런 방식의 조인이 있다는 것말 알아두자. 

## Single-sweep multi JOIN

MySQL의 네스티드-루프 조인을 자주 "Single-sweep multi join"이라 표현하기도 한다. 이는 표현이 난해하다는 이유로 네스티드 루프로 표현이 바뀌었다.  Single-sweep multi JOIN의 의미는 조인에 참여하는 테이블의 개수만큼 FOR나 WHILE과 같은 반복 루프가 중첩되는 것을 말한다. 

```
SELECT d.dempt_name, e.first_name
FROM departments d, employees e, dept_emp de
WHERE de.dept_no = d.dept_no AND e.emp_no = de.emp_no;
```

위 쿼리의 실행계획을 보면 d, de 그리고 e로 순서대로 테이블이 읽힌다. 이를 FOR문으로 표시하면 다음과 같다. 

```
FOR( record1 IN departments){
	FOR(record 2 IN dept_emp && record2.dept_no = record1.dept_no){
		FOR(recrod3 IN employees && record3.emp_no = record2.emp_no){
			RETURN {record1.dept_name, record3.first_name}
		}
	}
}
```

위 의사코드를 보면 3번 중첩이 되긴 했지만 전체적으로는 반폭 루프가 1개다. 즉 반복 루프를 돌면서 레코드 단위로 모든 조인 대상 테이블을 차례대로 읽는 방식을 "Single-sweep multi join"이라 한다. MySQL에서는 드라이빙 테이블 읽은 순서대로 레코드가 정렬되어 반환된다. 조인에서 드리븐 테이블은 단순히 드라이빙 테이블의 레코드를 읽는 순서대로 검색(Lookup)만 할 뿐이다. 

## 조인 버퍼를 이용한 조인(Using join buffer)

조인은 드라이빙 테이블에서 일치하는 레코드의 건수 만큼 드리븐 테이블을 검색하면서 처리된다. 즉 드라이빙 테이블을 쭉 읽게 되지만 드리븐 테이블은 여러번 읽게 된다는 것이다. 예를 들어 드라이빙 테이블에 일치하는 레코드가 1000건 이었는데, 드리븐 테이블 조인 조건이 인덱스를 이용할 수 없었다면 드리븐 테이블에 연결되는 레코드를 찾기 위해 1000번의 풀 테이블 스캔을 해야 한다. 그래서 드리븐 테이블을 검색할때 인덱스를 사용할 수 없는 쿼리는 상당히 느려지며, MySQL 옵티마이저는 최대한 드리븐 테이블 검색에 인덱스를 사용할 수 있도록 실행 계획을 수립한다.

그런데 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티아미저는 **드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다. 이때 사용되는 메모리 캐시를 조인 버퍼(Join buffer)라고 한다.** 조인 버퍼는 join_buffer_size라는 시스템 설정 변수로 크기를 제한할 수 있으며, 조인이 완료되면 조인 버퍼는 바로 해제 된다. 

```
SELECT * 
FROM dept_emp de, employees e
WHERE de.from_date > '2000-01-01' AND e.emp_no < 109004
```

먼저 위 쿼리를 조인 버퍼가 없다고 생각해보자. 그러면 dept_emp 테이블에서 de.from_date 조건을 만족하는 각 레코드 별로 employees 테이블과 조인을 하게 된다. 대략 de.from_date를 만족하는 레코드가 10,000건이고 e.emp_no < 109004를 만족하는 레코드가 9000건이라 해보자. 

dept_emp 테이블의 각 레코드에 의해 employees 테이블을 읽을 때 드리븐 테이블에서 가져오는 결과는 매번 같지만 최종적으로 10,000 * 9000건의 반복 작업을 수행하게 된다.  

같은 처리를 조인 버퍼를 통해 사용하면 훨씬 효율적이된다. 조인 버퍼를 사용할때는 Extra 컬럼에 조인 버퍼(join buffer)를 이용한다는 것을 알 수 있으며 조인 버퍼는 어떻게 활용 되는지 알아보자.

1. dept_emp 테이블의 from_date의 인덱스를 이용해 만족하는 레코든 (10,000)건을 검색한다. 
2. 조인에 필요한 나머지 컬럼들을 모두 dept_emp 테이블로 읽어서 조인버퍼에 저장한다.
3. employees 테이블의 프라이머리 키를 이용해  emp_no


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTUwODc5NTg5MSwtMTk4OTY5OTk1OCwyMD
c0NjgxNjYxLDk3MTA0ODg3MSwtNzk1MjI3OTM1LC02MDQ1NDI3
MDQsMTY0NTkzNTMyLC0xMzQzODE3MDg4LC0xODY4Mzc3NDA5LD
MxMzAxNzY0MiwtMTI4NTM4NDI2OCw4MDU5NjA0ODEsMTc5NTMw
MjI2NSwtNzQ1NjExMzQ5LC0xOTcyNTMxMzk5LC0xNDUyNTQxMT
UsLTEyMTQzNjM0NjUsMjAzNzU3NDcyMiwtMTgyMzUzMDcwMiwt
MjY0MTg0MTYxXX0=
-->