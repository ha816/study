# Overview

MySQL 실행 계획 성능에 큰 영향을 미치는 작업 단위에 대해 더 자세히 알아 보자. 
풀 테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리되는 내용임을 명심하자. 또한 MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 큰 영향을 미치는데, 안타깝게도 모두 쿼리의 성능을 저하 시킨다. 

스토리지 엔진에서 읽은 레코드를 MySQL엔진이 아무런 가공 없이 반환하면 최상의 성능을 보장하겠지만, 우리가 원하는 결과는 대부분 그렇지 않다. MySQL엔진에서 처리하는 시간이 오래걸리는 작업의 원리를 안다면 쿼리 튜닝에 큰 도움이 될것이다. 

# 풀 테이블 스캔(full table scan)

인덱스를 사용하지 않고 테이블 전체를 읽어 작업을 처리한다. 풀 테이블 스캔은 아래와 같은 조건에서 주로 풀테이블 스캔을 선택한다.

* 테이블의 레코드가 원채 적어서 풀 테이블 스캔이 더 빠른 경우
* WHERE 절이나 ON 절에서 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
* 인덱스 래이진 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(통계 정보기준)
* max_seeks_for_key 변수를 특정 값(N)으로 설정하면 인덱스의 기수성(Cardinality)나 선택도(selectivity)를 무시하고, 최대 N건만 읽으면 된다고 판단한다. 이 값이 작으면 인덱스를 더 사용하도록 유도할 수 있다.

일반적으로 테이블 전체 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기가 필요하다. 그래서 대부분의 DBMS는 풀 테이블 스캔시 한꺼번에 가져올 여러개의 블럭이나 페이지를 읽어오는 기능이 있고, 그 수를 조절할 수 있다. 하지만 MySQL에서는 예외적으로 풀 테이블 스캔을 할때 한꺼번에 몇 개씩 블럭이나 페이지를 가져올지 설정하는 변수가 없다. 그래서 많은 개발자가 MySQL이 풀 테이블 스캔시 디스크로부터 블럭이나 페이지를 하나씩 읽어 오는것으로 착각할때가 많다. 

사실 MyISAM 스토리진 엔진에서는 페이지를 하나씩 읽어오고 InnoDB에서는 아니다. InnoDB 스토리지 엔진은 특정 테이블에서 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어해드(Read ahead) 작업이 자동시작된다. 즉 풀 테이블 스캔이 실행되면 처음 몇 개의 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 백 그라운드 스레드가 읽기를 넘겨받는 시점부터는 한번에 4개 또는 8개씩의 페이지를 읽으면서 그 수를 증가시킨다. 그리고 한번에 최대 64개의 페이지를 읽어 버퍼풀에 저장해둔다. 포그라운드 스레드는 미리 버퍼풀에 올라간 데이터를 가져다 사용하기만 되므로 쿼리가 상당히 빠르게 처리된다. 

리드 어해드(Read ahead)
: 어떤 영역의 데이터가 앞으로 필요해지리라 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB 풀에 가져다 두는 것을 말한다.

MySQL 5.1의 InnoDB 플러그인 버전 부터는 언제 리드 어해드를 사용할지 시스템 변수로 변경할 수 있다. 이 변수 이름은 innodb_read_ahead_threshold인데, 일반적으로는 디폴트 설정으로도 충분하지만 테이터웨어하우스용으로 MySQL을 사용한다면 이 옵션 값을 낮추어 더 자주 리드 어해드가 시작되도록 유도하는 것도 좋다.

# ORDER BY 처리(Using filesort)

레코드를 한 두건 가져오는 쿼리를 제외하고는 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 데이터웨어 하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 아마 레코드 정렬 요건은 대부분의 조회 쿼리에 포함되어 있을것이다. 정렬을 처리하는 방법으로는 인덱스를 이용한 방법과 쿼리가 실행될때 "Filesort"라는 별도의 처리를 이용하는 방법이 있다.

* 인덱스 이용 방법
	* 장점: INSERT, UPDATE, DELETE 쿼리가 실행될때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되어 매우 빠르다.
	* 단점: INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 필요하다. 인덱스 개수가 늘어날 수록 버퍼풀 메모리가 더 필요하다. 
* Filesort 이용 방법
	* 장점: 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이 된다. 정렬해야할 레코드가 적으면 메모리에서 충분히 Filesort 처리가 빠르다.
	* 단점: 정렬 작업이 쿼리 실행시 실행되므로 레코드 대상 건수가 많아질 수록 응답이 느리다.

물론 레코드를 정렬하기 위해 항상 Filesort라는 정렬 작업을 거쳐야 하는 것은 아니다. 아쉽게도 아래와 같은 이유로 모든 정렬에 인덱스를 이용하기에 어려움이 있다.

* 정렬 기준이 너무 많아 모든 기준에 맞는 인덱스를 생성하는 것이 불가능한 경우
* GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 다시 정렬해야 하는 경우
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
* 랜덤하게 결과 레코드를 가져와야 하는 경우(때로는 인덱스를 이용하도록 개선할 수 있다)

MySQL이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 Extra 컬럼에 "Using filesort" 멘트가 표시되는 것으로 판단할 수 있다. 

## 소트 버퍼(Sort buffer)

MySQL 정렬을 위해서는 별도의 메모리 공간을 할당 받는데 이 공간을 소트 버퍼(sort buffer)라 한다. 소트 버퍼는 정렬이 필요한 경우만 할당되면, 버퍼의 크기는 정렬해야한 레코드의 크기에 따라 가변적으로 증가한다. 하지만 최대 사용 가능한 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다. 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

자 이제 정렬해야 할 레코드의 건수가 sort_buffer_size 보다 더 크다면 어떻게 될까? 이러면 MySQL은 정렬해야할 레코드를 여러 조각 나누어 처리하는데 이 과정에서 디스크를 사용하게 된다.

메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기론해 둔다. 그 다음 레코드를 가져와서 정렬하고 반복적으로 디스크에 임시 저장한다.  이처럼 각 버퍼 크기 만큼씩 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다. 이 병합 작업을 멀티 머지(Multi-merge)라고 표현하며, 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수(SHOW STATUS VARIABLES; 명령 참조)에 누적된다.

모든 작업들은 모두 디스크 I/O를 유발하며, 레코드 건수가 많을 수록 이 반복 잡어의 횟수가 많아진다. 물론 소트 버퍼를 크세 설정하면 디스크를 사용하지 않아서 더 빨라질 것으로 생각할 수 있으나 실제 벤치마크 결과론 거의 차이가 없었다. MySQL에서는 소트 버퍼 크기가 256KB에서 512KB일때 최적의 성능을 보였으며 그 이후로는 아무리 소트 버퍼 크기를 늘려도 성능상 차이가 없었다. 소트 버퍼의 이런 특성은 리눅스의 메모리 할당 방식이 원인일 것으로 예측하지만 정확한 원인은 아직 확인된바가 없다.

경험상 소트 버퍼의 크기는 56KB에서 1MB 미안일때가 적절하다고 생각한다. MySQL은 글로벌 메모리 영역과 세션(로컬) 메모리 영역으로 나뉘는데. **소트 버퍼는 세션 메모리 영역에 해당한다.** 즉 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 없다. 커넥션이 많을 수록, 정렬 작업이 많을 수록 소트 버퍼로 사용되는 메모리 공간이 커진다. 소트 버퍼의 크기를 터무니 없이 크게 잡을 수 있지만 그렇게 되면 운영체제는 메모리 부족현상을 겪을 수 있다. 이럴 경우 운영체제의 정책은 메모리를 가장 많이 사용하고 있는 프로세스를 강제 종료하는데 일반적으로 MySQL 서버가 가장 많은 메모리를 사용하기 때문에 강제 종료 1순위가 된다.

>주의
>소트 버퍼를 크게 설정해서 빠른 성능을 없을 수는 없지만 디스크의 I/O 사용량은 줄일 수 있다. 따라서 MySQL 서버의 데이터가 많거나 디스크 I/O의 성능이 떨어진다면 소트 버퍼의 크기를 더 크게 설정해서 도움이 될 수 도 있다. 하지만 소트 버퍼를 너무 크게 설정하면 서버 메모리 공간이 부족해지기 때문에 소트 버퍼의 크기는 적절히 설정하도록 하자.

## 정렬 알고리즘

레코드 전체를 소트 버퍼에 담을지 아니면 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 두 가지 정렬 알고리즘을 사용할 수 있다.

### 싱글 패스(Single pass) 알고리즘

소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 되는 컬럼 전부를 담아서 정렬을 수행하는 방법이다. MySQL 5.0 이후 도입된 비교적 최식 버전의 정렬법이다.

```
SELECT first_name, last_name
FROM employees
ORDER BY first_name
```

처음 employees 테이블을 읽을때, 정렬에 직접 필요하지 않은 last_name까지 전부 읽어 소트 버퍼에 담고 정렬을 수행한다. 그리고 정렬이 완료되면 그대로 정렬 버퍼의 내용을 클라이언트에게 넘겨준다. 

### 투 패스(Two pass) 알고리즘

정렬 대상 컬럼과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어 필요한 컬럼 정보를 가져오는 알고리즘으로, 오랫동안 MySQL에서 사용하던 방법이다. MySQL 5.0 이상에서도 특정 조건에는 이 방법을 사용한다. 

```
SELECT first_name, last_name
FROM employees
ORDER BY first_name
```

처음 employees 테이블을 읽을 때는 정렬에 필요한 first_name 컬럼과 프라이머리 키인 emp_no만 읽어서 정렬을 수행했음을 알 수 있다. 이 정렬이 완료되면 그 결과 순서대로 employees 테이블을 한번 더 읽어서 last_name을 가져와 결과로 반환한다.

MySQL의 투패스 알고리즘은 같은 레코드를 두번 읽어야 하기 때문에 상당히 불합리 하지만 새로운 정렬방식인 싱글 패스(Single pass)알고리즘은 이런 불합리한 점이 없다. 하지만 싱글 패스 알고리즘은 더 많은 소트 버퍼 공간이 필요하다. 

대략 128KB의 정렬 버퍼를 쓴다면, 싱글에서는 대략 3500건, 투패스에서는 7000건의 레코드를 정렬할 수 있다. 

최근 MySQL은 싱글 패스 알고리즘을 쓰지만 아래 상황일때는 투 패스 알고리즘을 사용한다. 

* 레코드의 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클때
* BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될때 

싱글 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 많은 경우 효율적이다. 

>SELECT 쿼리에서 꼭 필요한 컬럼만 조회하지 않고, 모든 컬럼(*)을 가져오도록 개발할때가 있다. 하지만 이는 정렬 버퍼를 비효율적으로 만들 가능성이 매우 크다. SELECT 쿼리에서 꼭 필요한 컬럼만 조회하도록 쿼리를 작성하도록 하는 것이 좋다고 권장하는 이유가 바로 이것 때문이다. 특히나 정렬이 필요한 SELECT는 불필요한 컬럼을 SELECT 하지 않도록 하는 것이 효율적이다. 이는 꼭 정렬 버퍼에만 영향을 미치는 것이 아니라 임시 테이블이 필요한 테이블에서도 영향을 미친다.

## 정렬의 처리방식

쿼리에 ORDER BY가 사용되면 반드시 아래 3가지 처리 방식 중 하나로 정렬이 처리된다. 일반적으로 밑쪽에 있는 정렬 방버븡로 갈수록 처리가 느려진다.

|정렬 처리 방법| 실행 계획의 Extra 커멘트  |
|--|--|
|인덱스 사용한 정렬  | 별도의 내용 표기 없음|
|드라이빙 테이블만 정렬 | Using filesort 표시|
|조인 결과를 임시 테이블 저장후,임시 테이블에서 정렬 | Using temporary; Usingfilesort가 같이 표시됨|

먼저 옵티마이저는 정렬처리를 위해 인덱스를 사용할 수 있을지 검토할 것이다. 만약 인덱스를 이용 할 수 있다면 별도의 Filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다. 하지만 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리한다.(Filesort) 이때 MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 두 방법 중 하나를 선택한다.

* 드라이빙 테이블만 정렬한 다음 조인 수행
* 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

일반적으로 조인이 수행되면서 레코드 건수는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다. 그래서 첫 번째 방법이 더 효율적으로 처리 된다.

### 인덱스 사용 정렬

인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 또한 WHERE 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. 

참고로 B-Tree 계열의 인덱스가 아닌 인덱스(해시 인덱스나 전문 검색 인덱스 등)에서는 이 인덱스 사용 정렬을 사용할 수 없다. 

인덱스를 이용해 처리하는 경우는 실제 인덱스의 값이 정렬되어 있기 때문에 단지 순서대로 읽기만 하면 된다. 실제로 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않는다. 

```
SELECT * FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no;

-- emp_no 컬럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동 정렬이 된다고 해서
일부러 ORDER BY e.emp)no를 제거하는 것은 좋지 않다.

SELECT * FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020;
```

>ORDER BY 주의할 점
>ORDER BY 절을 넣지 않아도 자동으로 정렬된다고 해서 ORDER BY를 빼는 경우가 있다. 혹시나 ORDER BY 절을 포함하면 MySQL 서버가 별도로 정렬 작업을 더 할까봐 걱정스러워서이다. 하지만 MySQL 서버는 졍렬을 인덱스로 처리할 수 있다면 절대 부가적으로 불필요한 정렬 작업을 하지 않는다. 그래서 인덱스 정렬이 처리될때 ORDER BY를 넣어도 작업량이 늘지 않는다. 또한, 어떤 이유 때문에 쿼리의 실행 계획이 조금 변경된다면 ORDER BY가 명시되지 않은 쿼리는 결과가 기대했던 순서대로 가져오지 못해 버그가 될 수도 있다. 하지만 ORDER BY를 명시해두면 성능상의 손해가 없음은 물론이고 이런 예외 상황도 버그로 연결되지 않을 것이다. 

### 드라이빙 테이블만 정렬

일반적으로 조인이 수행되면 결과 레코드의 건수가 몇배로 불어난다. 그래서 조인 전에 첫 번재 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이다. 이 방법은 조인에서 첫 번재 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절이 작성되어야 한다. 

```
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 AND 100010
order by e.last_name;
```

우선 WHERE 절의 조건이 다음 두 조건을 가지기 때문에 employees 테이블을 드라이빙 테이블러 선택할 것이다.

1. WHERE 절의 검색 조건(e.emp_no between ...)은 employees 테이블의 프라이머리 키를 이용해 작업량을 줄일 수 있다.
2. 드리븐 테이블(s.salaries)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다. 

검색은 인덱스 레인지 스캔으로 처리할 수 있지만 **ORDER BY 절에 명시된 컬럼은 employees 테이블의 프라이머리 키와 전혀 연관이 없으므로 인덱스를 이용한 정렬은 불가능하다.** 그런데 ORDER BY의 정렬 기준 컬럼이 드라이빙 테이블(employees)에 포함된 컬럼이다. 옵티마이저는 이럴 경우 드라이빙 테이블만 검색해서 정렬을 먼저 수행(File sort)하고, 그 결과로 salaries 테이블과 조인을 할 것이다. 

### 임시 테이블에서 정렬

쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT해서 정렬하는 경우라면 임시 테이블이 필요하지 않는다. 하지만 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다. 

앞에서 본 드라이빙 테이블 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다. 하지만 그 밖에 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다. 이 방법은 세 가지 방법 중에 정렬해야할 레코드 건수가 가장 많아지기 때문에 가장 느린 정렬법이다.  

```
select * from employees e, salaries s
where s.emp_no = e.emp_no
and e.emp_no between 100002 AND 100010
order by s.salary;
```

하지만 이번 쿼리에서는 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블(salaries)에 있는 컬럼이다. 즉 정렬이 수행되기 전에 반드시 salaries 테이블을 읽어야 하므로 반드시 조인된 데이터를 가지고 정렬할 수 밖에 없다. 


|id| select_type|table|type|key|key_len|ref|rows|Extra
|--|--|--|--|--|--|--|--|--|
|1| SIMPLE|e|range|PRIMARY|4| | 9| Using where; Using temporary; Using filesort
|1| SIMPLE| s|ref|PRIMARY|4|e.emp_no|4|

## 정렬 방식의 성능 비교

주로 웹 서비스용 쿼리에서는 ORDER BY와 함께 LIMIT가 거의 필수적으로 사용되는 경향이 있다. 일반적으로 LIMIT는 테이블의 처리 결과 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다. 그런데 **ORDER BY나 GROUP BY와 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서 처리될 수 없다.** 
우선조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그룹핑 작업을 실행해야마나 비로서 LIMIT 건수를 제한할 수 있다. WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다. 

쿼리에 인덱스를 사용하지 못하는 정려이나 그룹핑 작업이 왜 느리게 작동할 수 밖에 없는지 보자. 이를 위해 쿼리가 처리되는 방법 "스트리밍 처리"와 "버퍼링 처리" 두 가지 방식을 구분해보자.

### 스트리밍(Streaming) 방식

서버 쪽에서 처리해야할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식이다. 이 방식으로 처리할 경우 클라이언트는 쿼리를 요청하고 곧 바로 원했던 첫번째 레코드를 받을 것이다. 물론 마지막 레코드를 언제 받을지는 모르지만 이는 중요하지 않다. 

쿼리가 스트리밍 방식으로 전달되면 클라이언트는 일치하는 레코드를 즉시 전달받기 때문에 동시에 데이터 가공작업을 할 수 있다. 웹 서비스와 같은 OLTP 환경에서는 쿼리의 요청에서부터 첫 번째 레코드를 전달 받기 까지 응답 시간이 중요하다. 스트리밍 방식으로 처리되는 쿼리는 그 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관 없이 빠른 응답시간을 보장한다.

또한 스트리밍 방식으로 처리되는 쿼리에서 LIMIT와 같이 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있다. 매우 큰 테이블을 아무 조건 없이 SELECT 해보면 아주 빨리 첫번째 레코드는 가져올 수 있다. 

>참고 
>스트리밍 처리는 어떤 클라이언트 도구나 API를 사용하느냐에 따라 그 방식에 차이가 있다. 대표적으로 JDBC 라이브러리를 이용해 SELECT 쿼리를 실행하면 레코드를 읽자마자 클라이언트로 그 결과를 전달할 것이다. 하지만 JDBC는 레코드 자체를 버퍼에 모두 담아두다가 마제막 레코드가 전달될 때까지 기다렸다가 모든 결과를 전달 받으면 그때서야 비로서 클라이언트의 애플리케이션에 반환한다. 즉 MySQL 서버는 스트리밍 방식으로 처리하지만 클라이언트의 JDBC 라이브러리가 버퍼링을 한다. 하지만 JDBC가 아닌 SQL 클라이언트 도구는 이러한 버퍼링을 하지 않기 때문에 아무리 큰 테이블이라도 첫 레코드는 매우 빨리 가져온다. 
>JDBC 라이브러리가 자체적으로 레코드를 버퍼링하는 이유는 이 방식이 전체 처리량(Throughput)에서 뛰어나기 때문이다. 이 방식은 JDBC 라이브러리와 MySQL 서버가 대화형으로 주고 받는것이 아니라 MySQL 서버는 데이터의 크기에 관계없이 무조건 보내고, JDBC MySQL 서버로부터 전송되는 데이터를 받아서 저정만 하므로 불필요한 네트워크 요청이 최소화되기 때문에 전체 처리량이 뛰어난 것이다. 
>하지만 JDBC의 버퍼링 처리 방식은 기본 작동 방식이며, 아주 대량의 데이터를 가져와야 할때는 MySQL 서버와 JDBC간의 전송 방식을 스트리밍으로 변경할 수 있다. 

###  버퍼링(Buffering) 방식

ORDER BY나 GROUP BY와 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다. 왜냐하면 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후에 정렬하거나 그룹핑을 통해 차례대로 보내야 하기 때문이다. MySQL 서버가 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다. 

버퍼링 방식으로 처리되는 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로 부터 가져올때 까지 기다려야 한다. 그래서 버퍼링 방식은 LIMIT 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 큰 도움이 되지 않는다. 네트워크로 전송되는 건수는 줄일 수 있지만 MySQL 서버에서 해야하는 작업량에는 크게 변화가 없기 때문이다. 

인덱스를 사용한 정렬 방식만 스트리밍 형태로 처리가 가능하며, 나머지는 모두 버퍼링된 후에 정렬된다. 즉 인덱스를 사용한 정렬 방식은 LIMIT 제한 건수만큼만 읽으면서 바로 클라이언트에 결과를 전송해줄 수 있다. 하지만 인덱스를 사용하지 못하는 경우의 처리는 필요한 레코드를 읽어서 정렬한 후에 LIMIT 건수만큼 잘라서 클라이언트로 전송해줄수 있다.

조인과 함께 ORDER BY 절과 LIMIT 절이 함께 사용할 경우, 정렬의 각 처리 방식별로 어떤 차이가 있는지 좀 더 자세히 살펴보자.

```
SELECT *
FROM tb_test1, tb_test2
WHERE t1.col=t2.col1
ORDER BY t1.col2
LIMIT 10
```

tb_test1 테이블의 레코드가 100건이고, tb_test2 테이블의 레코드가 1000건이라 하자. 그리고 tb_test1 1건당 tb_test2 레코드가 10건씩 있다고 가정하자. 두 테이블 조인 결과는 전체 1000건이라고 가정하고 정렬의 처리 방식별로 읽어야 하는 레코드 건수와 정렬을 수행해야 하는 레코드 건수를 비교해보자.

* tb_test1이 드라이빙 테이블이 되는 경우

|정렬방식|읽어야 하는 건수 | 조인 횟수 | 정렬해야 하는 대상 건수|
|--|--|--|--|
|인덱스 사용|tb_test1 : 1건, tb_test2 : 10건|1번|0건|
|드라이빙 테이블만 정렬|tb_test1 : 100건, tb_test2 : 10건|10번|100건|
|임시 테이블 사용 후 정렬|tb_test1 : 100건, tb_test2 : 1000건|100번(tb_test1 테이블의 레코드 건수만큼 조인 발생)|1000건(조인된 결과 레코드 건수를 전부 정렬해야 함|

* tb_test2가 드라이빙되는 경우

 |정렬방식|읽어야 하는 건수 | 조인 횟수 | 정렬해야 하는 대상 건수|
|--|--|--|--|
|인덱스 사용|tb_test2 : 10건, tb_test1 : 10건|10번|0건|
|드라이빙 테이블만 정렬|tb_test2 : 1000건, tb_test1 : 10건|10번|1000건(tb_test2 테이블의 레코드 건수만큼 정렬필요)|
|임시 테이블 사용 후 정렬|tb_test2 : 1000건, tb_test1 : 100건|1000번(tb_test2 테이블의 레코드 건수만큼 조인 발생)|1000건(조인된 결과 레코드 건수를 전부 정렬해야 함|

어느 테이블이 먼저 드라이빙 되어 조인되는지도 중요하지만 어떤 정렬방식으로 처리 되는지는 더 큰 성능차이를 만든다. 가능하다면 인덱스를 사용한 정렬로 유도하고 그렇지 못한다면 최소한 드라이빙 테이블 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법이다.

> 인덱스를 사용하지 못하고 별도로 Filesort 작업을 거쳐야 하는 쿼리에서 LIMIT 조건이 아무런 도움이 되지 못하는 것은 아니다. 정렬해야할 대상 레코드가 1000건인 쿼리에 LIMIT10이라는 조건이 있다면 MySQL 서버는 1000건의 레코드를 모두 정렬하는 것이 아니라 필요한 순서대로 정렬해서 상위 10건만 정렬이 채워지면 정렬을 멈추고 결과를 반환한다. 하지만 MySQL 서버는 정렬을 위해 퀴소트 알고리즘을 사용한다. 이는 LIMIT 10을 만족하는 상위 10건을 정렬하기 위해 더 많은 작업이 필요할 수도 있다. 결론적으로 인덱스를 사용하지 못하는 쿼리를 페이징 처리에 사용하는 경우 LIMIT 5~10건만 조회하더라도 쿼리가 기대 만큼 빨라지지는 않는다.

## 정렬 관련 상태 변수 

MySQL 서버는 처리하는 주요 작업에 대해서 해당 작업의 실행 횟수를 상태 변수로 저장하고 있다. 정렬과 관련해서도 몇건의 레코드를 처리 했는지, 소트 버퍼간의 병합 작업(멀티 머지)은 몇번 발생했는지 등을 아래 명령으로 확인이 가능하다. 

```
SHOW SESSION STATUS LIKE 'Sort%';
+-------------------------------+
|Variable name		|Value		|
+-------------------------------+
|Sort_merge_passes	|56			|
|Sort_range			|0			|
|Sort_rows			|279408		|
|Sort_scan			|1			|
```
각 상태은 아래와 같은 의미를 가진다.

* Sort_merge_passes는 멀티 머지 횟수를 말한다.
* Sort_range는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다.
* Sort_scan은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수다. Sort_scan과 Sort_range는 둘다 정렬 작업 횟수를 누적하고 있는 상태 값이다. 
* Sort_rows는 지금까지 정렬한 전체 레코드 건수를 의미한다. 

# Group BY 처리

GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍 처리를 할 수 없게 하는 요소 중 하나다. GROUP BY 절이 있는 쿼리에서는 HAVING 절을 사용할 수 있는데,  HAVING 절은 GROUP BY 결과에 대해서 필터링 역할을 수행한다. 

일반적으로 GROUP BY 처리 결과는 임시 테이블이나 버퍼에 존재하는 값을 필터링 하는 역할을 수행한다.  GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없다. 

GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다. 인덱스를 이용할때는 인덱스를 차례대로 이용하느 인덱스 스캔 방법과 인덱스를 건너 뛰면서 읽는 루즈 인덱스 스캔이 있다. 그리고 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다.

## 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

ORDER BY 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그룹핑할 때 GROUP BY 컬럼으로 이미 인덱스가 있다면 그 인덱스를 차례때로 읽으면서 그룹핑 작업을 수행하고 결과를 조인으로 처리한다. GROUP BY가 인덱스를 사용한다고 하더라도 그룹 함수 등의 그룹 값을 처리해야할 임시 테이블이 필요할 때도 있다. 

GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것으로 추가적인 정렬 작업은 필요치 않다. 이런 그룹핑 방식을 사용하는 쿼리의 실행 계획에서는 Extra 컬럼에서 Using index for group-by나 임시 테이블이나 정렬 관련 커멘트(Using temporary, Using filesort)가 표시 되지 않는다. 

## 루즈 인덱스 스캔을 이용하는 GROUP BY

루즈 인덱스 스캔 방식은 인덱스 레코드를 건너 뛰면서 필요한 부분만 가져오는 것을 말한다. 예를 들어 한번 이야기를 해보겠다. 

```
EXPLAIN
SELECT emp_no
FROM salaries 
WHERE from_date = '1985-03-01' -- 다중 인덱스의 두번째
GROUP BY emp_no -- 다중 인덱스의 첫번째
```

salaries 테이블의 인덱스는 (emp_no + from_date)로 생성되어 있다. 쿼리 문장에서 Where 조건은 인덱스 레인지 스캔 방법으로 접근할 수 없는 상태이다. 하지만 실제 실행 계획을 보면 인덱스 레인지 스캔을 이용하며, Extra 컬럼의 Using index for group-by가 노출 된다.

MySQL 서버가 어떻게 레인지 스캔을 했는지 순서대로 정리해보자. 

1. (emp_no + from_date) 인덱스를 차례대로 스캔하면서, emp_no의 첫 번째 유일한 값(그룹 키) '10001'을 찾아낸다.
2. (emp_no + from_date) 인덱스에서 emp_no가 '10001'인 것 중에서 from_date 값이 '1985-03-01' 인 레코드만 가져온다. 
3. (emp_no + from_date) 인덱스에서 emp_no의 그 다음 유니크한(그룹 키) 값을 가져온다. 
4. 3번 단계에서 결과가 더 없으면 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아가서 반복 수행한다.

**MySQL의 루즈 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.** 또한 프리픽스 인덱스(Prefix index, 칼럼값의 앞쪽 일부만으로 생성된 인덱스)는 루즈 인덱스 스캔을 사용할 수 없다. 

인덱스 레인지 스캔은 유니크한 값의 수가 많을 수록 성능이 향상 되지만 반면 루즈 인덱스 스캔은 인덱스의 유니크한 값이 적을수록 성능이 향상 된다. **일반적인 상황과 다르게 루즈 인덱스 스캔은 분포도가 좋지 않을 수록 더 빠른 결과를 만든다.** 그리고 루즈 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다. 

루즈 인덱스 스캔이 사용될 수 있을지 없을지 판단하는 것은 WHERE 절의 조건이나 ORDER BY 절이 인덱스를 사용할 수 있을지 판단하는 것보다 더 어렵다. 다음 예로 루즈 인덱스 스캔을 사용할 수 있을지 판단하는 연습을 해보자.

우선, (col1+col2+col3) 컬럼으로 생성된 tb_test 테이블을 만들어 보자. 그리고 아래 쿼리들은 모두 루즈 인덱스 스캔을 사용할 수 있는 쿼리다. 

```
SELECT col1, col2 FROM tb_test GROUP BY col1, col2;
SELECT DISTINCT col1, col2 FROM tb_test;
SELECT col1, Min(col2) FROM tb_test GROUP BY col1;

```

# Distinct 처리

# 임시 테이블(Using temporary)

# 테이블 조인(table join)
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI0OTIyMTg0MywtNTk0MjQ5NzMxLC0xOD
E3Nzc2NTI0LDEyMjEwNDI1MDcsMjA3NjQ2MDIzNywtMjkzNDM2
MzUyLC0yMDczOTE2NzQ2LDE2MTIwNTY4OTYsMjA3NjA4OTU4MS
wxMTQyMTUwODY1LC0xNDIzNzI1NjE5LC03ODU0MDM5NzUsMTYy
NTk0NjExOCwyMDczMTg4NjU5LDE5ODg1MTI5NjEsMTc5NzA4OD
A3LDE5OTYxNTUxMTcsLTM1MDg2NjcwNyw5Mjg2MzI5OTEsMTYw
MDQ3OTM3M119
-->