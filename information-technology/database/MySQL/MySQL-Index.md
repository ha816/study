# MySQL Index

인덱스는 데이터 베이스 쿼리의 성능을 말하자면 뺄 수 없는 영역이다. 

## 랜덤 I/O와 순차 I/O

랜덤 I/O라는 표현은 디스크 드라이브 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 말한다. 

디스크의 성능은 **디스크 헤더의 위치이동 없이 얼마나 많은 데이터를 한번에 기록하느냐**에 의해 결정된다. 랜덤 I/O는 순차 I/O에 비해  여러번  쓰기 또는 읽기  요청을 한다. (즉, 작업 부하가 커진다.)  

쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸어 실행할 방법은 많지 않다. 대신에 쿼리 튜닝은 랜덤 I/O 자체를 줄이는 것이 목적이다. 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하고 풀테이블 스캔은 주로 순차 I/O를 사용한다. 

위 두가지 이유로, 주로  **Data Warehouse**나  **DB Table 통계작업**  등에는 테이블이 큰 경우 인덱스 레인지 스캔보다 풀 테이블 스캔을 유도하는 경우도 있다. 

## Key

Primary Key
: 프라이머리키는 그 레코드를 대표하는 칼럼 값으로 만들어진 인덱스를 말한다. 이렇게 되면 테이블에서 해당하는 레코드를 식별할 수 있는 기준값이 되기 때문에 이를 식별자라고도 부른다. 프라이머리키는 NULL 값을 허용하지 않고 중복을 허용하지 않는다.

Secondary Key
: 프라이머리 키를 제외한 나머지 모든 인덱스는 보저 인덱스이다. 


# Index

DBMS에서 **인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 데이터의 읽기 속도를 높이는 기능**이다. 

## B-Tree Index(Balanced-Tree Index)

가장 일반적으로 사용되는 인덱스 알고리즘으로 또한 가장 범용적이다.  B-Tree는 칼럼의 원래 값을 변형하지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다. 

B-tree는 최상위에 하나의 루트 노드가 존재하고, 가장 하위에는 리프노드가 있다. 그 중간에는 브랜치 노드가 있다. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데,  **인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값**을 가진다. 

인덱스의 브랜치 노드들의 키 값은 모두 정렬되어 있다. 하지만 실제 데이터 파일의 로우는 정렬되어 있지 않고 임의의 순서로 저장된다. 레코드의 삭제나 변경없이 순수하게 INSERT만 수행된다면 그럴수도 있지만 기본적으로 레코드가 삭제 되면 그 다음의 INSERT는 삭제된 공간을 재활용하도록 DBMS가 설계되어 있기 때문에 순서가 지켜지지는 않는다.

INNODb 테이블에서는 레코드가 클러스터링 되어 디스크에 저장되는데 기본적으로 프라이머리 키 순서대로 정렬된다.  InnoDB에서는 사용자가 기본 옵션이 클러스터링 테이블로 생성되기 때문에, 최대한 비슷한 값들을 모아 저장한다. 

### Index INSERT, DELETE, UPDATE, SELECT

새로운 키 값이 B-Tree에 저장될때는 저장될 키 값을 이용해서 B-Tree의 적절한 인덱스 위치를 검색해야 한다. 그리고 저장될 위치가 정해지면  레코드의 키 값과 주소 정보를 B-Tree의 리프 노드에 저장한다. 이때 만약 리프 노드가 꽉차면 리프 노드를 분리해야 하는데, 상위 브랜치 노드까지 처리 범위가 넓어진다. 이때문에 B-tree는 상대적으로 Insert 비용이 많이 드는것으로 알려져 있다. 

인덱스 추가로 인해 INSERT나 UPDATE 문장이 어떤 영향을 받을지 궁흠한 사람이 많다. 성능의 영향은 테이블의 컬럼 수, 컬럼의 크기, 인덱스 컬럼의 특성등을 확인해야 한다. 대략적으로 계산하는 방법은 테이블에 레코드를 추가하는 비용이 1이라 하면 인덱스에 키를 추가하는 작업은 1 ~ 1.5정도로 예측을 한다. 
중요한 점은 이 비용 대부분이 I/O 작업에서 온다는 것이다. 

InnoDB는 상황에 따라 인덱스 키 추가 작업을 지연시켜서 나중에 처리할지 아니면 바로 처리할지를 결정한다. 인덱스 키 추가 작업은 항상 우선순위가 높게 처리가 되지 않아도 사실 큰 문제가 없다. 그래서 buffer에 데이터를 저장하다가 서버 자원의 여유가 있을때  지연 처리를 한다. MySQL 5.1이하 버전에서는 INSERT만 버퍼링을 지원했지만 5.5 이상 부터는 DELETE도 추가되었다. 이 버퍼의 정싱 명칭은 체인지 버퍼링(Change Buffering)이 되었다. 

인덱스 삭제의 경우는 간단하다. 키값이 저장되 리프노드를 찾아서 그냥 삭제하면 된다. 이 작업도 디스크 쓰기가 필요하는데 5.5버전 이상에서는 체인지 버퍼링을 이용하여 지연 처리가 될 수도 있다. 

인덱스 변경의 경우, 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다.  현재 그래서 키 값을 삭제한후, 다시 새로운 키 값을 추가하는 형태로 진행된다. 즉 앞서 설명한 인덱스 삭제, 추가 과정이 절차대로 진행된다. 

인덱스 키 검색은 루트 노드로 부터 시작해 브랜치 노드를 거쳐 리프 노드까지 이동하며 비교 작업을 수행하는데, 이 과정을 트리 탐색(Tree traversal)이라 한다. 인덱스 트리 탐색은 SELECT에서만 사용하는 것이 아니라 UPDATE, DELETE를 처리하기 위해 항상 해당 레코드를 검색해야 할 경우에도 인덱스가 있으면 빠른 검색이 가능하다. 

B-Tree인덱스를 이용한 검색은 100% 완전 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우에는 사용할 수 있다. 부등호("<>") 비교나 값의 뒷부분이 일치하는 경우에는 B-Tree 인덱스를 이용한 검색이 불가능하다. 또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다. 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니다. 따라서 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의하자. 

InnoDB 스토리지 엔진에서 인덱스는 특별한 의미가 있다. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락(갭 락)이 검색을 수행한 인덱스를 잠근후 테이블의 레코드를 잠그는 식으로 구현되어 있다. UPDATE나 DELETE 문장이 실행될때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 테이블의 모든 레코드를 잠글 수도 있다. InnoDB 스토리지 엔진에서는 그 만큼 인덱스 설계가 중요하고 많은 부분에 영향을 미친다는 것이다. 

### Performance

B-Tree 인덱스는 인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수등에 의해 검색이나 변경 작업의 성능이 영향을 받는다. 

#### 인덱스 키값의 크기

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위를 페이지(Page) 또는 블록(Block)이라 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 또한 페이지는 InnoDB 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 한다. 인덱스도 결국은 페이지 단위로 관리되며, 페이지 단위란 하나의 노드로 이해하자. 

일반적으로 B-Tree는 자식 노드의 갯수가 가변적이다. 그러면 MySQL의 B-Tree는 자식 노드를 몇 개까지 가질지 궁금할 것이다. 이것은 바로 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다. InnoDB의 모든 페이지 크기는 16KB로 고정되어 있다. 

만약 인덱스의 키가 16바이트라고 하고 자식 노드 주소가 12바이트라고 가정하자. 
|16byte|12byte  |
|--|--|
|1233__ABCD  | 자식노드주소|

그러면 하나의 인덱스 페이지(16KB) 또는 노드에 몇 개의 키와 자식노드 주소를 저장할 수 있을까? $16 * 1024 / (16+12) = 585$개를 저장 할 수 있다.  최종적으로 각 노드는 585개의 자식 노드를 가질 수 있는 B-Tree이다. 

인덱스 의 키값이 2배가 늘어난 32byte로 늘어났다고 가정하면 $16 * 1024 / (32+12) = 372$개를 저장할 수 있다. 만약 여러분의 SELECT 쿼리가 레코드 500개를 읽어야 한다면 전자는 인덱스 페이지 한번에 해결이 되지만, 후자는 최소 2번 이상의 디스크를 읽어야 한다. 결국 **인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 느려진다는 것을 의미한다.** 

결국 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 말한다. InnoDB 버퍼풀은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 메모리에 캐시해둘 수 있는 레코드 수는 줄어드는 것을 의미하며 자연히 메모리 효율이 떨어진다. 

#### B-Tree 깊이

**B-Tree 인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법이 없다.** 

만약 인덱스의 키값의 평균 크기가 늘어나면 어떤 현상이 추가로 더 발생하는지 알아보자. 만약 B-Tree의 깊이가 3인 경우 최대 몇개 의 키 값을 가질 수 있을까? 
앞서 하나의 노드는 585개의 키 값과 자식 노드 주소 가질 수 있다고 했다. $16 * 1024 / (16+12) = 585$ 
즉 키값과 자식노드 주소 값의 합이 28 바이트라면 최대 2억정도 된다.($585^3$)

**B-Tree의 깊이는 검색할때 몇번이나 랜덤하게 디스크를 읽어야 하는지와 직결된다.** 결론적으로 인덱스 키값이 커지면 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 갯수가 작아지고, 같은 레코드 건수라 하더라도 B-Tree가 깊어져 디스크 읽기가 더 많이 필요하게 된다. 

여기서 언급한 내용은 인덱스 키 값을 가능한 작제 만들면 좋다는 것을 강조하는 내용이고 아무리 대용량의 데이터 베이스라도 B-Tree깊이가 4~5이상까지 깊어지는 경우는 별로 없다. 

#### 선택도(기수성)

인덱스에서 선택도(Selectivity) 또는 기수성(Cardinality)는 거의 같은 의미로 사용된다. **Cardinality는 모든 인덱스 키값 가운데 유니크한 값의 수를 의미한다.**
만약 전체 인덱스 키값은 100개인데 그중에서 유니크한 값의 수는 10개라면 Cardinality는 10이다. 정의에 따라 인덱스 키 값중에 중복되는 값이 많아지면 Cardinality는 낮아지고 반대로 중복값이 없으면 Cardinality가 높아진다. Cardinality가 높아지면 검색 대상 수가 줄기 때문에 더 빠르게 처리가 된다. 

예를 들어 하나의 테이블에 country와 city라는 컬럼을 가지고 있다고 하자. 해당 테이블에 전체 레코드 갯수는 1만건이고, country 칼럼으로만 인덱스가 생성된 상태에서 country 컬럼의 유니크한 값의 갯수가 10개, 1,000개 인경우를 생각해보자. 

MySQL에서는 인덱스의 통계정보(유니크한 값의 갯수)가 관리대기 때문에 city 칼럼의 cardinality는 무시해도 된다. 만약 유니크 값의 갯수가 10인경우 평균적으로 1,000건의 조회가 필요한 것을 통계적으로 유추할 수 있고 유니크 값의 갯수가 1,000개인 경우 10건의 조회만으로 검색이 가능한 것을 유추해 볼 수 있다. 

#### 읽어야 하는 레코드의 건수

사실 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 비용이 더 많이 든다. 만약 테이블 레코드가 100만건인데, 그중에 50만건을 읽어야 한다는 쿼리가 있다고 하자. 이 작업은 사실 전체 테이블을 읽고 50만건을 버리는게 휴율적인지 필요한 50만건을 읽어오는 것이 효율적인지 판단해야 한다.

일반적으로 DBMS의 옵티마니저는에서는 **인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 읽는것보다 4~5배 정도 더 비용이 많이 드는것으로 예측한다.** 따라서 인덱스를 통해 읽어야 할 레코드 건수(옵티마이저가 판단한)가 전체 테이블 레코드의 20 ~25%를 넘어서면 인덱스를 이용하지 않고 직접 모든 데이터를 읽고 필터링을 통해 처리하는게 효율적이다. 

### B-Tree 인덱스를 통한 데이터 읽기

어떤 경우에 인덱스를 사용할지, 또는 사용하지 못할지 판단하려면 MySQL이 어떻게 인덱스를 이용해서 실제 레코드를 읽어내는지 알아야 한다. MySQL이 인덱스를 이용하는 대표적인 방법 Range Scan, Full Scan, Loose Scan을 보도록 하자.

#### Range Scan

레인지 스캔은 인덱스의 접근 방법 중 가장 대표적인 접근 방법이고 FullScan과 Loose Scan 보다 빠른 방법이다. 사실 인덱스를 통해 한 건만 읽는 경우와 두 건 이상을 읽는 경우를 서로 다른 이름으로 구분하지만, 모두 인덱스 레이진 스캔이라고 표현

## Hash Index






> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYxOTA2NTU2LC00NDEzMDY3MDgsMTc1Mj
Q2MDg3NywtMTU2MDM3NjkwMSwyNDgxMDk1NDgsLTIwNDQ3Mzk3
MTgsNTMxNTY3MTk3LDcyNjkxOTEwOSwtMTM3ODUwODMwLC0xMT
E0NjA0ODg0LC0xODc3NTE5NzQ3LC0xNjEyMDU5OTg3LDc5Mzc1
NDA4OCwxMzk1MTM3OTExLC0xMzY5NzA0MTIzLC0xMDYwMTQ0NT
g4LDEzMjMzNTIwNzAsNDg4NDcyMDc1LC05NzA2MTcxMywtNTc5
ODkzMjldfQ==
-->