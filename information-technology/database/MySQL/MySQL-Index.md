# MySQL Index

인덱스는 데이터 베이스 쿼리의 성능을 말하자면 뺄 수 없는 영역이다. 

## 랜덤 I/O와 순차 I/O

랜덤 I/O라는 표현은 디스크 드라이브 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 말한다. 

디스크의 성능은 **디스크 헤더의 위치이동 없이 얼마나 많은 데이터를 한번에 기록하느냐**에 의해 결정된다. 랜덤 I/O는 순차 I/O에 비해  여러번  쓰기 또는 읽기  요청을 한다. (즉, 작업 부하가 커진다.)  

쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸어 실행할 방법은 많지 않다. 대신에 쿼리 튜닝은 랜덤 I/O 자체를 줄이는 것이 목적이다. 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하고 풀테이블 스캔은 주로 순차 I/O를 사용한다. 

위 두가지 이유로, 주로  **Data Warehouse**나  **DB Table 통계작업**  등에는 테이블이 큰 경우 인덱스 레인지 스캔보다 풀 테이블 스캔을 유도하는 경우도 있다. 

## Key

Primary Key
: 프라이머리키는 그 레코드를 대표하는 칼럼 값으로 만들어진 인덱스를 말한다. 이렇게 되면 테이블에서 해당하는 레코드를 식별할 수 있는 기준값이 되기 때문에 이를 식별자라고도 부른다. 프라이머리키는 NULL 값을 허용하지 않고 중복을 허용하지 않는다.

Secondary Key
: 프라이머리 키를 제외한 나머지 모든 인덱스는 보저 인덱스이다. 


# Index

DBMS에서 **인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 데이터의 읽기 속도를 높이는 기능**이다. 

## B-Tree Index(Balanced-Tree Index)

가장 일반적으로 사용되는 인덱스 알고리즘으로 또한 가장 범용적이다.  B-Tree는 칼럼의 원래 값을 변형하지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다. 

B-tree는 최상위에 하나의 루트 노드가 존재하고, 가장 하위에는 리프노드가 있다. 그 중간에는 브랜치 노드가 있다. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데,  **인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값**을 가진다. 

인덱스의 브랜치 노드들의 키 값은 모두 정렬되어 있다. 하지만 실제 데이터 파일의 로우는 정렬되어 있지 않고 임의의 순서로 저장된다. 레코드의 삭제나 변경없이 순수하게 INSERT만 수행된다면 그럴수도 있지만 기본적으로 레코드가 삭제 되면 그 다음의 INSERT는 삭제된 공간을 재활용하도록 DBMS가 설계되어 있기 때문에 순서가 지켜지지는 않는다.

INNODb 테이블에서는 레코드가 클러스터링 되어 디스크에 저장되는데 기본적으로 프라이머리 키 순서대로 정렬된다.  InnoDB에서는 사용자가 기본 옵션이 클러스터링 테이블로 생성되기 때문에, 최대한 비슷한 값들을 모아 저장한다. 

### Index INSERT, DELETE, UPDATE, SELECT

새로운 키 값이 B-Tree에 저장될때는 저장될 키 값을 이용해서 B-Tree의 적절한 인덱스 위치를 검색해야 한다. 그리고 저장될 위치가 정해지면  레코드의 키 값과 주소 정보를 B-Tree의 리프 노드에 저장한다. 이때 만약 리프 노드가 꽉차면 리프 노드를 분리해야 하는데, 상위 브랜치 노드까지 처리 범위가 넓어진다. 이때문에 B-tree는 상대적으로 Insert 비용이 많이 드는것으로 알려져 있다. 

인덱스 추가로 인해 INSERT나 UPDATE 문장이 어떤 영향을 받을지 궁흠한 사람이 많다. 성능의 영향은 테이블의 컬럼 수, 컬럼의 크기, 인덱스 컬럼의 특성등을 확인해야 한다. 대략적으로 계산하는 방법은 테이블에 레코드를 추가하는 비용이 1이라 하면 인덱스에 키를 추가하는 작업은 1 ~ 1.5정도로 예측을 한다. 
중요한 점은 이 비용 대부분이 I/O 작업에서 온다는 것이다. 

InnoDB는 상황에 따라 인덱스 키 추가 작업을 지연시켜서 나중에 처리할지 아니면 바로 처리할지를 결정한다. 인덱스 키 추가 작업은 항상 우선순위가 높게 처리가 되지 않아도 사실 큰 문제가 없다. 그래서 buffer에 데이터를 저장하다가 서버 자원의 여유가 있을때  지연 처리를 한다. MySQL 5.1이하 버전에서는 INSERT만 버퍼링을 지원했지만 5.5 이상 부터는 DELETE도 추가되었다. 이 버퍼의 정싱 명칭은 체인지 버퍼링(Change Buffering)이 되었다. 

인덱스 삭제의 경우는 간단하다. 키값이 저장되 리프노드를 찾아서 그냥 삭제하면 된다. 이 작업도 디스크 쓰기가 필요하는데 5.5버전 이상에서는 체인지 버퍼링을 이용하여 지연 처리가 될 수도 있다. 

인덱스 변경의 경우, 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다.  현재 그래서 키 값을 삭제한후, 다시 새로운 키 값을 추가하는 형태로 진행된다. 즉 앞서 설명한 인덱스 삭제, 추가 과정이 절차대로 진행된다. 

인덱스 키 검색은 루트 노드로 부터 시작해 브랜치 노드를 거쳐 리프 노드까지 이동하며 비교 작업을 수행하는데, 이 과정을 트리 탐색(Tree traversal)이라 한다. 인덱스 트리 탐색은 SELECT에서만 사용하는 것이 아니라 UPDATE, DELETE를 처리하기 위해 항상 해당 레코드를 검색해야 할 경우에도 인덱스가 있으면 빠른 검색이 가능하다. 

B-Tree인덱스를 이용한 검색은 100% 완전 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우에는 사용할 수 있다. 부등호("<>") 비교나 값의 뒷부분이 일치하는 경우에는 B-Tree 인덱스를 이용한 검색이 불가능하다. 또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다. 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니다. 따라서 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의하자. 

InnoDB 스토리지 엔진에서 인덱스는 특별한 의미가 있다. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락(갭 락)이 검색을 수행한 인덱스를 잠근후 테이블의 레코드를 잠그는 식으로 구현되어 있다. UPDATE나 DELETE 문장이 실행될때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 테이블의 모든 레코드를 잠글 수도 있다. InnoDB 스토리지 엔진에서는 그 만큼 인덱스 설계가 중요하고 많은 부분에 영향을 미친다는 것이다. 

### Performance

B-Tree 인덱스는 인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수등에 의해 검색이나 변경 작업의 성능이 영향을 받는다. 

#### 인덱스 키값의 크기

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위를 페이지(Page) 또는 블록(Block)이라 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 또한 페이지는 InnoDB 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 한다. 인덱스도 결국은 페이지 단위로 관리되며, 페이지 단위란 하나의 노드로 이해하자. 

일반적으로 B-Tree는 자식 노드의 갯수가 가변적이다. 그러면 MySQL의 B-Tree는 자식 노드를 몇 개까지 가질지 궁금할 것이다. 이것은 바로 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다. InnoDB의 모든 페이지 크기는 16KB로 고정되어 있다. 

만약 인덱스의 키가 16바이트라고 하고 자식 노드 주소가 12바이트라고 가정하자. 
|16byte|12byte  |
|--|--|
|1233__ABCD  | 자식노드주소|

그러면 하나의 인덱스 페이지(16KB) 또는 노드에 몇 개의 키와 자식노드 주소를 저장할 수 있을까? $16 * 1024 / (16+12) = 585$개를 저장 할 수 있다.  최종적으로 각 노드는 585개의 자식 노드를 가질 수 있는 B-Tree이다. 

인덱스 의 키값이 2배가 늘어난 32byte로 늘어났다고 가정하면 $16 * 1024 / (32+12) = 372$개를 저장할 수 있다. 만약 여러분의 SELECT 쿼리가 레코드 500개를 읽어야 한다면 전자는 인덱스 페이지 한번에 해결이 되지만, 후자는 최소 2번 이상의 디스크를 읽어야 한다. 결국 **인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 느려진다는 것을 의미한다.** 

결국 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 말한다. InnoDB 버퍼풀은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 메모리에 캐시해둘 수 있는 레코드 수는 줄어드는 것을 의미하며 자연히 메모리 효율이 떨어진다. 

#### B-Tree 깊이

B-Tree 인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법이 없다. 





## Hash Index






> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMTQ2MDQ4ODQsLTE4Nzc1MTk3NDcsLT
E2MTIwNTk5ODcsNzkzNzU0MDg4LDEzOTUxMzc5MTEsLTEzNjk3
MDQxMjMsLTEwNjAxNDQ1ODgsMTMyMzM1MjA3MCw0ODg0NzIwNz
UsLTk3MDYxNzEzLC01Nzk4OTMyOSwtMTM5ODk0MDI0NCw4MzQ4
ODEyNjUsODQwODI1NDBdfQ==
-->