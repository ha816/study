# MySQL Index

인덱스는 데이터 베이스 쿼리의 성능을 말하자면 뺄 수 없는 영역이다. 

## 랜덤 I/O와 순차 I/O

랜덤 I/O라는 표현은 디스크 드라이브 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 말한다. 

디스크의 성능은 **디스크 헤더의 위치이동 없이 얼마나 많은 데이터를 한번에 기록하느냐**에 의해 결정된다. 랜덤 I/O는 순차 I/O에 비해  여러번  쓰기 또는 읽기  요청을 한다. (즉, 작업 부하가 커진다.)  

쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸어 실행할 방법은 많지 않다. 대신에 쿼리 튜닝은 랜덤 I/O 자체를 줄이는 것이 목적이다. 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하고 풀테이블 스캔은 주로 순차 I/O를 사용한다. 

위 두가지 이유로, 주로  **Data Warehouse**나  **DB Table 통계작업**  등에는 테이블이 큰 경우 인덱스 레인지 스캔보다 풀 테이블 스캔을 유도하는 경우도 있다. 

## Key

Primary Key
: 프라이머리키는 그 레코드를 대표하는 칼럼 값으로 만들어진 인덱스를 말한다. 이렇게 되면 테이블에서 해당하는 레코드를 식별할 수 있는 기준값이 되기 때문에 이를 식별자라고도 부른다. 프라이머리키는 NULL 값을 허용하지 않고 중복을 허용하지 않는다.

Secondary Key
: 프라이머리 키를 제외한 나머지 모든 인덱스는 보저 인덱스이다. 


# Index

DBMS에서 **인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 데이터의 읽기 속도를 높이는 기능**이다. 

## B-Tree Index(Balanced-Tree Index)

가장 일반적으로 사용되는 인덱스 알고리즘으로 또한 가장 범용적이다.  B-Tree는 칼럼의 원래 값을 변형하지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다. 

B-tree는 최상위에 하나의 루트 노드가 존재하고, 가장 하위에는 리프노드가 있다. 그 중간에는 브랜치 노드가 있다. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데,  **인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값**을 가진다. 

인덱스의 브랜치 노드들의 키 값은 모두 정렬되어 있다. 하지만 실제 데이터 파일의 로우는 정렬되어 있지 않고 임의의 순서로 저장된다. 레코드의 삭제나 변경없이 순수하게 INSERT만 수행된다면 그럴수도 있지만 기본적으로 레코드가 삭제 되면 그 다음의 INSERT는 삭제된 공간을 재활용하도록 DBMS가 설계되어 있기 때문에 순서가 지켜지지는 않는다.

INNODb 테이블에서는 레코드가 클러스터링 되어 디스크에 저장되는데 기본적으로 프라이머리 키 순서대로 정렬된다.  InnoDB에서는 사용자가 기본 옵션이 클러스터링 테이블로 생성되기 때문에, 최대한 비슷한 값들을 모아 저장한다. 

### Index Insert, Delete

새로운 키 값이 B-Tree에 저장될때는 저장될 키 값을 이용해서 B-Tree의 적절한 인덱스 위치를 검색해야 한다. 그리고 저장될 위치가 정해지면  레코드의 키 값과 주소 정보를 B-Tree의 리프 노드에 저장한다. 이때 만약 리프 노드가 꽉차면 리프 노드를 분리해야 하는데, 상위 브랜치 노드까지 처리 범위가 넓어진다. 이때문에 B-tree는 상대적으로 Insert 비용이 많이 드는것으로 알려져 있다. 



## Hash Index






> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzOTg5NDAyNDQsODM0ODgxMjY1LDg0MD
gyNTQwXX0=
-->