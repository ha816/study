# MySQL Index

인덱스는 데이터 베이스 쿼리의 성능을 말하자면 뺄 수 없는 영역이다. 

## 랜덤 I/O와 순차 I/O

랜덤 I/O라는 표현은 디스크 드라이브 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 말한다. 

디스크의 성능은 **디스크 헤더의 위치이동 없이 얼마나 많은 데이터를 한번에 기록하느냐**에 의해 결정된다. 랜덤 I/O는 순차 I/O에 비해  여러번  쓰기 또는 읽기  요청을 한다. (즉, 작업 부하가 커진다.)  

쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸어 실행할 방법은 많지 않다. 대신에 쿼리 튜닝은 랜덤 I/O 자체를 줄이는 것이 목적이다. 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하고 풀테이블 스캔은 주로 순차 I/O를 사용한다. 

위 두가지 이유로, 주로  **Data Warehouse**나  **DB Table 통계작업**  등에는 테이블이 큰 경우 인덱스 레인지 스캔보다 풀 테이블 스캔을 유도하는 경우도 있다. 

## Key

Primary Key
: 프라이머리키는 그 레코드를 대표하는 칼럼 값으로 만들어진 인덱스를 말한다. 이렇게 되면 테이블에서 해당하는 레코드를 식별할 수 있는 기준값이 되기 때문에 이를 식별자라고도 부른다. 프라이머리키는 NULL 값을 허용하지 않고 중복을 허용하지 않는다.

Secondary Key
: 프라이머리 키를 제외한 나머지 모든 인덱스는 보저 인덱스이다. 


# Index

DBMS에서 **인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 데이터의 읽기 속도를 높이는 기능**이다. 

## B-Tree Index(Balanced-Tree Index)

가장 일반적으로 사용되는 인덱스 알고리즘으로 또한 가장 범용적이다.  B-Tree는 칼럼의 원래 값을 변형하지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다. 

B-tree는 최상위에 하나의 루트 노드가 존재하고, 가장 하위에는 리프노드가 있다. 그 중간에는 브랜치 노드가 있다. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데,  **인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값**을 가진다. 

인덱스의 브랜치 노드들의 키 값은 모두 정렬되어 있다. 하지만 실제 데이터 파일의 로우는 정렬되어 있지 않고 임의의 순서로 저장된다. 레코드의 삭제나 변경없이 순수하게 INSERT만 수행된다면 그럴수도 있지만 기본적으로 레코드가 삭제 되면 그 다음의 INSERT는 삭제된 공간을 재활용하도록 DBMS가 설계되어 있기 때문에 순서가 지켜지지는 않는다.

INNODb 테이블에서는 레코드가 클러스터링 되어 디스크에 저장되는데 기본적으로 프라이머리 키 순서대로 정렬된다.  InnoDB에서는 사용자가 기본 옵션이 클러스터링 테이블로 생성되기 때문에, 최대한 비슷한 값들을 모아 저장한다. 

### Index Insert, Delete

새로운 키 값이 B-Tree에 저장될때는 저장될 키 값을 이용해서 B-Tree의 적절한 인덱스 위치를 검색해야 한다. 그리고 저장될 위치가 정해지면  레코드의 키 값과 주소 정보를 B-Tree의 리프 노드에 저장한다. 이때 만약 리프 노드가 꽉차면 리프 노드를 분리해야 하는데, 상위 브랜치 노드까지 처리 범위가 넓어진다. 이때문에 B-tree는 상대적으로 Insert 비용이 많이 드는것으로 알려져 있다. 

인덱스 추가로 인해 INSERT나 UPDATE 문장이 어떤 영향을 받을지 궁흠한 사람이 많다. 성능의 영향은 테이블의 컬럼 수, 컬럼의 크기, 인덱스 컬럼의 특성등을 확인해야 한다. 대략적으로 계산하는 방법은 테이블에 레코드를 추가하는 비용이 1이라 하면 인덱스에 키를 추가하는 작업은 1 ~ 1.5정도로 예측을 한다. 
중요한 점은 이 비용 대부분이 I/O 작업에서 온다는 것이다. 

InnoDB는 상황에 따라 인덱스 키 추가 작업을 지연시켜서 나중에 처리할지 아니면 바로 처리할지를 결정한다. 인덱스 키 추가 작업은 항상 우선순위가 높게 처리가 되지 않아도 사실 큰 문제가 없다. 그래서 buffer에 데이터를 저장하다가 서버 자원의 여유가 있을때 

## Hash Index






> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4ODU3ODc4MzAsLTU3OTg5MzI5LC0xMz
k4OTQwMjQ0LDgzNDg4MTI2NSw4NDA4MjU0MF19
-->