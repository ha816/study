# Overview

데이터 베이스로부터 필요한 데이터를 가져오려면 SQL이라는 정형화된 문장을 사용해야 한다. 데이터 베이스 구조를 변경하기 위한 DDL(Data Definition Language), 테이블 레코드 조작을 위한 DML(Data Manipulation Language)가 있고 이 둘을 합쳐 SQL이라 한다.

DML에는 SELECT, INSERT, UPDATE, DELETE 쿼리로 나뉘며, 이 밖에 REPLACE, MERGE INTO 등과 같이 DBMS 벤더별로 제공되는 비표준 SQL도 있다. ANSI 표준에는 데이터를 조회하는 SELECT를 쿼리라고 하고, 그외의 INSERT, UPDATE 그리고 DELETE와 같은 SQL을 스테이먼트(Statement)라고 구분하기도 한다.

애플리케이션에서 데이터베이스와 통신할때 데이터베이스 서버로 전달되는 것은 SQL뿐이다. SQL은 어떠한(WHAT) 데이터를 요청하기 위한 언어지 어떻게(HOW) 데이터를 읽을지를 표현하는 언어는 아니므로 일반 프로그래밍 언어보다 상당히 제한적이다. 그래서 SQL을 작성하는 방법, 규칙, 내부적 처리(옵티마이저)에 대해 어느 정도 지식이 필요하다.

애플리케이션에서 코드 튜닝으로 성능을 2배 올리는 것은 굉장히 어려운 일이다. 하지만 DBMS에선 몇십배의 성능 향상은 흔한 일이다. SQL처리에서 어떻게(HOW)를 이해하고 쿼리를 작성하는 게 그만큼 중요하다는 것이다. 

이번 장에선 쿼리 패턴별로 어떻게 처리되는지를 이해하고, 많이 알려져 있지 않지만 코드수를 상당히 줄일 수 있는 유용한 쿼리 패턴도 알아보자. 

# 쿼리와 연관된 시스템 설정

SQL 작성 규칙은 대소문자 구분, 문자열 표기방법등 MySQL 서버 시스템 설정에 따라달라 진다. 시스템 설정에는 무엇이 있는지 예약어에는 어떤 것이 있고, 사용할때 주의사항도 알아보자.

## SQL 모드

MySQL 서버의 sql_mode라는 시스템 설정엔 여러 값이 동시에 설정된다. 그 중 대표적으로 SQL 작성과 결과에 영향이 있는 것들은 무엇인지 알아보자. MySQL 서버 설정 파일에서 sql_mode를 설정할때는 구분자(,)를 사용해 아래 키워드를 동시에 설정할 수 있다. 

### STRICT_ALL_TABLES

기본 MYSQL에서는 **저장하려는 값의 길이가 컬럼 길이보다 더 긴 경우라도 에러가 발생하지 않는다.** 컬럼의 길이를 초과하는 부분은 버리고 가능한 만큼만 저장한다. 물론 경고 메세지가 발생하지만, 이를 보는 사람은 별로 없을 것이다. 만약 sql_mode 시스템변수에 STRICT_ALL_TABLES를 하면 컬럼의 정해진 길이보다 큰 값을 저장할때 경고가 아닌 오류가 발생하고 쿼리 실행이 중지된다.

### STRICT_TRANS_TABLES

**컬럼에 호환되지 않는 값을 저장할때, MySQL 서버는 비슷한 값으로 최대한 바꿔서 저장하려고 한다.** 하지만 이런 부분이 사용자를 더 혼란 스럽게 하기도 한다. STRICT_TRANS_TABLES를 설정하면 맞지 않는 데이터 타입 변환이 필요할때 강제 변환을 하지 않고 에러를 발생시킨다.

### TRADITIONAL
STRICT_ALL_TABLES, STRICT_TRANS_TABLES와 비슷하지만 조금 더 엄격한 SQL 작동을 강제한다. MySQL 서버가 좀더 ANSI 표준 모드로 작동하도록 유도한다.

### ANSI_QUOTES

MySQL에서는 문자열 값(리터럴)을 표기하기 위해 홑따음표와 쌍따옴표 둘다 사용이 가능하다. 하지만 오라클과 같은 DBMS에서는 홑따옴표는 문자열 값을 표기하는데 사용하고 쌍따옴표는 컬럼 명이나 테이블 명과 같은 식별자를 구분하는 용도로만 사용한다. 

ANSI_QUOTES를 설정하면 홑따옴표만 문자열 값으로 사용할 수 있고, 쌍따옴표는 컬럼명이나 테이블 명과 같은 식별자를 표기하는데만 사용할 수 있다. 

### ONLY_FULL_GROUP_BY

MySQL의 쿼리에서는 GROUP BY 절에 포함되지 않은 컬럼이더라도 집합 함수의 사용없이 그대로 SELECT 절이나 HAVING 절에 사용할 수 있다. 이 부분도 SQL 표준이나 다른 DBMS와는 다른 동작 방식인데, 이 설정을 하면 SQL 문법에 더 엄격한 규칙을 적용하게 된다.

### PIPE_AS_CONCAT

MySQL에서는 "||"는 OR 연산자와 같은 의미로 사용된다. 이 설정을 하면 오라클과 값이 문자열 연결(CONCAT) 연산자로 사용할 수 있다.

### PAD_CHAR_TO_FULL_LENGTH

MySQL에서는 CHAR 타입이라 하더라도 VARCHAR와 같이 유효 문자열 뒤의 공백문자는 제거되어 반환된다. 이는 주로 애플리케이션 개발자에게 민감한 부분인데, 저자는 MySQL의 불필요한 공백을 제거하는 방식이 편리한거 같다. 하지만 CHAR 타입의 컬럼값을 가져오는 경우, 뒤쪽의 공백이 제거되지 않고 변환되야 한다. 이 설정을 하면 뒤쪽 공백이 제거되지 않고 반환된다.

### NO_BACKSLASH_ESCAPES

MySQL에서도 일반적인 프로그래밍 언어에서 사용하는 역 슬래시 문자를 이스케이프 문자로 사용할 수 있다. 이 설정을 추가하면 **역 슬래시를 문자의 이스케이프 용도로 사용하지 못한다.** 즉 백슬리시 문자도 다른 문자와 동일하게 취급한다. 

### IGNORE_SPACE

MySQL에서 스토어드 프로시저나 함수의 이름뒤에 공백이 있으면 프로시저나 함수가 없다는 에러가 출력될 수도 있다. 이 현상을 MySQL이 괄호사이에 있는 공백까지도 스토어드 프로시저나 함수의 이름으로 간주해서 그렇다. 이 설정을 추가하면 프로시저나 함수의 괄호 사이의 공백은 무시한다. 

### ANSI
위에서 설명한 여러 옵션을 조합해서 MySQL 서버가 최대한 SQL 표준에 맞게 동작하도록 설정한다.

## 영문 대소문자 구분

**MySQL 서버는 설치된 운영체제에 따라 테이블의 대소문자를 구분한다.** 이는 MySQL의 DB나 테이블이 디스크의 디렉터리나 파일로 매핑되기 때문이다. 즉 윈도우에 설치된 MySQL에선 대소문자를 구분하지 않지만 리눅스 계열에선 대소문자를 구분한다. 

MySQL 서버가 운영체제에 관계없이 대소문자 구분 영향을 받지 않게 하려면 lower_case_table_names 시스템 변수를 설정하면 된다. 기본 설정 값은 0으로, 대소문자 구분을 한다. 또한 이 값은 2로 설정할 수 있는데, 이 경우 저장은 대소문자를 구분하지만 MySQL 쿼리에서는 대소문자를 구분하지 않게 해준다. 사실 이런 설정 자체를 떠나서 가능하면 **초기에 DB나 테이블 생성시 대문자만 또는 소문자만 사용하다록 통일해서 쓰는게 좋다**

## MySQL 예약어

MySQL에는 무수히 많은 예약어들이 있다. (ADD, ALL, ALTER 등) 따라서 **데이터 베이스, 테이블,  컬럼 이름을 예약어와 같은 키워드로 생성한다면 SQL에선 항상 역따옴표(`)나 쌍따옴표로 감싸줘야 한다.** 이는 관리 작업시 상당히 성가신 일이 될수 있는데, 또 단순히 문법이 틀리 라는 형식의 에러만 출력하므로 SQL을 작성하는 개발자가 찾기가 어려운 버그가 될수도 있다. 

MySQL에 등록되 예약어의 갯수는 이를 구분해서 모두 기억하기란 쉽지 않다. 가장 좋은 방법은 실제 쿼리를 수행시켜 보는 것이다. 이때는 역따옴표로 일단 둘러싸지 않고 테이블을 생성해 보자. 만약 역따옴표로 둘러싸서 테이블을 생성하는 경우라면 예약어를 사용했다고 하더라도 에러나 경고를 보여주지 않고, 그대로 테이블을 생성해버리기 때문이다. **항상 테이블을 생성할때는 역따옴표로 테이블이나 컬럼의 이름을 둘러싸지 않은 상태로 생성하길 권장한다.** 

그래야만 예약어인지 아닌지를 MySQL 서버에서 알려주기 때문이다. 만약 테이블 생성이 실패한다면 해당 예약어는 역따옴표로 감싸지 않고는 사용할 수 없다는 것을 말한다. 

# 메뉴얼 SQL 문법 표기 읽는 법

MySQL 메뉴얼에 명시된 SQL 문법은 사용할 수 있는 모든 키워드나 기능을 하나의 문장에 다 표기해 둿기 때문에 한눈에 이해되지 않는 단점이 있다. 하지만 해당 버전에 맞는 SQL 문법을 참조하기에는 메뉴얼만큼 정확한 자료가 없다. 그래서 더 정확하고 상세한 문법을 확인하려면 MySQL의 SQL 문법을 참조하는것이 정석이다. 이번에는 SQL 문법을 표기하는 방법을 간단히 알아보자 

![enter image description here](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http://cfile7.uf.tistory.com/image/21784C3C5866670621BE75)

```
INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
	[INTO] tlb_name
	SET col_name = {expr | DEFAULT}, ...
	[ON DUPLICATE KEY UPDATE
		col_name = expr
			[, col_name = expr] ... ]
```			



SQL에서 각 키워드는 위 그림과 같이 키워드나 표현식이 표기된 순서대로만 사용할 수 있다. 

대문자로 표현된 단어
: 모두 키워드를 의미한다. 키워드는 대소문자를 특별히 구분하지 않고 사용할 수 있다. 

이탤릭체로 표현한 단어
: 사용자가 선택해서 작성하는 토큰을 말하는데, 대부분 테이블명이나 컬럼명 또는 표현식을 말한다.  

대괄호([])
: 해당 키워드나 표현식 자체가 선택사항임을 말한다. 즉 대괄호로 묶인 키워드나 표현식 없어도 문법적 오류가 발생하지 않고, 있어도 문법적 오류가 발생하지 않음을 뜻한다.

중괄호({})
: 괄호 내의 아이템 중에서 반드시 하나를 사용해야 하는 경우를 말한다. 

파이프(|)
: 앞 뒤의 키워드나 표현식 중에서 단 하나만 선택해서 사용하다는 의미다. 즉 첫번재 라인의 LOW, DELAYED, HIGH_PRIORITY 셋중에 단 하나만 사용할 수 있음을 말한다. 그런데 이 세개는 대괄호로 묵여 있기 때문에 INSERT 쿼워드 사이에 아무것도 사용하지 않거나 셋중 하나만 사용할수 있다는 의미다.

...(...)
: ... 표기는 앞에 명시된 키워드나 표현식의 조합이 반복될수 있음을 말한다. 마지막 라인에서 $\cdots$은, "col_name=expr"을 여러번 반복해서 사용할 수 있음을 말한다. 


# MySQL 연산자와 내장함수

여타 DBMS에서도 사용되는 기본적인 연산자는 MySQL에도 비슷하게 있지만 MySQL에서만 사용되는 연산자나 표기법이 있다. ANSI 표준은 아닌것도 있기 때문에 혼란스럽게 만들기도 한다. 따라서 SQL의 가독성을 높이기 위해 ANSI 표준형태 연산자를 사용하기를 권한다. 

**일반적으로 내장함수는 거의 같은 기능을 제공하지만 이름이 호환되는 것은 거의 없는 점을 기억하자.**

## 리터럴 표기법

### 문자열

SQL 표준에서는 문자열은 **반드시 항상 홑따옴표(')를 사용해야 한다.** 하지만 MySQL에서는 쌍따옴표를 사용할 수도 있다. 

SQL 표준에서는 문자열 값에 홑따옴표가 포함되 있을때, 홑따옴표를 두번 연속해서 입력하면 된다. 하지만 MySQL 에서는 쌍따옴표와 홑따옴표를 혼합해서 문제를 피해가기도 한다. 

```
-- SQL 표준의 " 쌍따옴표 처리법
SELECT * FROM departments WHERE dept_no = 'd''001';
SELECT * FROM departments WHERE dept_no = 'd"001';

-- MySQL에서만 지원되는 방법
SELECT * FROM departments WHERE dept_no = "d'001";
SELECT * FROM departments WHERE dept_no = "d""001";
```

SQL에서 사용되는 식별자(테이블이나 컬럼명 등)가 키워드와 충돌할때 오라클이나 MS-SQL에서는 쌍따옴표나 대괄호를 감싸서 충돌을 피하곤 한다. MySQL에서는 역따옴표로 감싸서 사용하면 예약어와의 충돌을 피할 수 있다. 

### 숫자

숫자 값을 상수로 SQL에 사용할때는 따옴표(홑 따옴표, 쌍따옴표) 없이 숫자값을 입력하면 된다. 또한 문자열 형태로 따옴표를 써도 비교대상이 숫자값이거나 숫자 타입의 컬럼이라면 MySQL 서버가 문자열 값을 숫자 값으로 자동변환 해준다. 하지만 한가지 주의 사항이 있다.  서로 다른 타입으로 WHERE 조건 비교가 수행되는 다음 경우를 보자

```
-- SQL 표준의 " 쌍따옴표 처리법
SELECT * FROM tab_test WHERE number_column = '1001';
SELECT * FROM tab_test WHERE string_column = 1001;
```

먼저 비교대상이 문자열과 숫자 타입으로 다를때는 자동으로 타입변환이 일어난다. **MySQL에서는 문자열 값을 숫자 값으로 변환하는 것을 우선하고 이후 비교를 수행한다.** 

첫번째 쿼리는 주어진 상수값을 숫자로 변환하는데, 이때 상수값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않는다.

두 번째 쿼리는 주어진 상수값이 숫자 값인데 컬럼은 문자열이다. 이때 앞서 말했듯이 MySQL은 문자열 컬럼을 숫자로 변경한다. 즉 string_column 컬럼의 모든 문자열 값을 숫자로 변환해 비교를 수행한다. 따라서 **string_column에 있덱스가 있다 하더라도 이를 이용하지 못하게 된다.**

원천적으로 이런 문제를 피하려면 숫자값은 숫자 타입 컬럼에만 저장해야 한다. 항상 주의하도록 하자.

### 날짜

다른 DBMS에서 날짜 타입을 비교하거나 INSERT하려면 반드시 문자열을 DATE 타입으로 변환하는 코드가 필요하다. 하지만 MySQL에서는 날짜 포맷을 표기하기만 하면 MySQL 서버가 자동으로 DATE나 DATETIME으로 변환하기 때문에 복잡한 함수를 사용하지 않아도 된다.

### 불리언

BOOL이나 BOOLEAN이라는 타입이 있지만 사실 이것은 TINYINT 타입에 대한 동의어일 뿐이다. 테이블의 컬럼을 BOOL로 생성한 뒤에 조회해보면 컬럼의 타입이 BOOL이 아니라 TINYINT라는 점을 알 수 있다. MySQL에서는 TRUE나 FALSE 형태로 비교하거나 값을 저장할 수 있는데, 사실 값을 조회해 보면 0 또는 1값이 조회된다. 즉 MySQL은 TRUE나 FALSE같은 불리언 값을 정수로 매핑해서 사용한다. 이때 MySQL에서는 FALSE가 정수 값 0이 되지만, TRUE는 1만을 의미한다는 것을 주의해야 한다. 그래서 숫자 값이 저장된 컬럼을 TRUE나 FALSE로 조회하면 0이나 1이외의 숫자 값은 조회되지 않는다. 

모든 숫자 값이 TRUE나 FALSE 두 개의 불리언 값으로 매핑되지 않는다는 것은 혼란스럽고 버그로 연결될 가능성이 크다. 만약 불리언 타입을 꼭 사용하고 싶다면 ENUM 타입으로 관리하는 것이 더 좋다.

## MySQL 연산자

### 동등(Equal) 비교 ( =, <=>)

동등 비교는 다른 DBMS에서와 마찬가지로 "=" 기호를 사용해서 비교를 수행하면 된다. 하지만 MySQL에서는 동등 비교를 위해 "<=>" 









> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwNzQyMTgyOSwxNzY5OTE1OTI5LDE5OT
A0NzgwMCw0Nzg0MTA4NDIsLTEwMjM1NDE0ODMsLTEzNzIzNzE4
MDMsLTEwNTk0NzEyMjksLTE3Nzk0NDA0MzksLTMyMzkxNDM3OS
wzOTY2ODc2NDEsLTE1ODg2NzkzMzgsLTI1ODc2NjA5MCwtMjg2
NTYwMDQwLC0xMjUyNDgyNTMsODY3ODQyMDU5LDE1MzY0MjAyOD
ksLTIxMzQ5NjM4NzUsMTE5MTI2NDUzMiwxOTQ3NTAyODI0LDE1
NzI0MTUwMzZdfQ==
-->