# MySQL Architecture

## ENGINE

MySQL엔진
: 커넥션핸들러와 SQL파서 및 전처리기 그리고 옵티마이저가 중심을 이룬다. 그리고 성능 향상을 위해 MyISAM의 키 캐시나 InnoDB의 버퍼풀과 같은 보조 저장소 기능이 포함되어 있다. MySQL엔진은 DBMS의 두뇌와 같은 처리를 수행한다. 

스토리지 엔진
: 실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 역할은 스토리지 엔진이 담당한다.  MySQL엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있다. 

핸들러 API
: MySQL엔진이 쿼리 수행을 위해 각 스토리지 엔진에게 쓰기 또는 일기를 요청하는데 이러한 요청을 핸들러 요청이라고 한다. 그리고 이때 사용되는 API를 핸들러 API라고 한다. 

```
create table test_table (...) ENGINE =INNODB, MyISAM;
```

## THREAD Structure
MySQL은 프로세스 기반이 아니라 스레드 기반으로 동작한다. 
스레드는 크게 포그라운드 스레드(클라이언트 스레드)와 백그라운드 스레드로 구분할 수 있다.

포그라운드 스레드(Foreground Thread)
: MySQL서버에 접속한 클라이언트의 수 많큼 존재한다. 주로 각 클라이언트에 사용자의 요청쿼리를 처리하는 역할을 한다. 클라이언트의 커넥션이 종료되면 다시 Thread pool로 돌아간다. 

백그라운드 스레드(Background Thread)
: 여러 중요한 작업이 백그라운드 스레드로 수행된다. 버퍼의 데이터를 디스크로 쓰는 쓰기 쓰레드(Write Thread)와 로그 쓰레드(Log Thread)가 대표적이다.

사실 쓰기 작업은 지연(버퍼링, 누적)하여 처리될 수 있지만, 읽기 작업은 절대 지연되면 안된다. 일반적인 DBMS은 쓰기작업을 버퍼링하여 일괄 처리하는 기능이 있다.

## Memory Structure

메모리는 MySQL 파라미터로 설정해 둔 만큼 운영체제로 부터 메모리를 할당 받는다. 메모리 영역은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 두 영역의 차이는 서버 내의 스레드가 공유하는 영역인지 아닌지에 따라 구별된다.

글로벌 메모리 영역(Global Memory Area)
: 모든 스레드가 공유하는 영역이다. 2개 이상의 글로벌 메모리 영역을 받을 수도 있지만, 마찬가지로 모든 스레드가 볼 수 있다.

로컬 메모리 영역(Local Memory Area, Session Memory Area, Client Memory Area)
: 클라이언트 쓰레드가 사용하는 대표적인 메모리 영역이다. 클라이언트 쓰레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역. 또 서버와 커넥션을 맺는 세션이라 하여 세션 메모리 영역이라고도 한다.

## 쿼리 실행 구조
파서 - 전처리기 - 옵티마이저 - 쿼리 실행기 

파서(Parser)
:  들어온 쿼리를 토큰(MySQL이 인식하는 최소 단위의 어휘)으로 분리해 트리 형태의 구조를 만드는 작업을 한다. 이 과정에서 문법 오류가 있으면 오류 메세지를 반환한다.

전처리기
: 파서 과정에서 만들어진 트리를 기반으로 다른 유형의 문제점을 확인한다. 예를 들면, 접근 권한 여부와 컬럼, 테이블등이 존재하는지 여부를 확인한다. 

옵티마이저
: 쿼리를 어떻게 가장 저렴한 비용으로 빠르게 처리할지 결정하는 역할을 담당한다. 어떻게 하면 옵티마이저가 나은 선택을 하도록 유도하는가가 중요하다.

실행기
: 실행기는 옵티마이저에서 만든 계획대로 여러 핸들러에게 필요한 작업을 요청하고 받은 결과를 클라이언트에게 반환한다. 핸들러는 실행기의 요청에 따라 핸들러가 대응하는 스토리지 엔진을 조작하여 필요한 작업을 수행한다. 

## 복제(Replication)
데이터베이스의 데이터가 갈수록 대용량화 되어가는 것을 고려하여 확장성(Scalability)는 DBMS에서 아주 중요한 요소이다. MySQL은 확장성을 위해 다양한 기술을 제공하는데 그중 가장 일반적인 방법이 Replication이다. 

Replication은 2대 이상의 MySQL 서버가 동일한 데이터를 가지도록 동기화하는 기술이다. 하지만 Replication은 동기화가 비동기적으로 발생한다. 따라서 어떤 데이터베이스에는 데이터가 업데이트되어 있지만, 다른 데이터베이스에서는 업데이트되지 않을 수도 있다.  

Master
: 마스터 서버는 주로 데이터변경 작업의 주체이다.  **마스터 서버는 DML, DDL에 해당하는 모든 쿼리 문장을 바이너리 로그에 기록한다.** 슬레이브 서버에서 변경 내역을 요청하면 **바이너리 로그**를 읽어 슬레이브서버에 넘기는데 Binlog dump라는 쓰레드가 이 작업을 수행한다.

Slave
: 바이너리 로그를 받아 마스터 서버의 정보(IP, Port, 접속 계정)를 가지고 있는 경우 슬레이브가 된다. 마스터 서버가 바이너리 로그를 가지고 있다면, 슬레이브 서버는 **릴레이 로그**를 가진다. 마스터 서버와의 동일한 데이터 유지를 위해 슬레이브 서버는 마스터서버에 접속해 변경 내역을 가져와 릴레이 로그에 기록한다.(Slave_IO_Thread). SQL 스레드(Slave_SQL_Thread)가 릴레이 로그의 변경 작업을 재실행(replay)하여 데이터의 일관성을 유지한다. 

### 주의사항
 
**일반적으로 마스터 서버는 반드시 1개이며, 슬래이브는 1개 이상으로 구성한다.** 또한, 마스터와 슬레이브로 나누어지기 때문에 데이터를 변경하는쿼리는 단 하나의 데이터베이스에만 요청할 수 있다. 다시 말해서 슬레이브의 데이터를 변경하면, 마스터에 그 변경은 반영되지 않고, 동기화하는 도중 에러를 발생시키기도 한다.  

**마스터와 슬레이브 동기화를 위해 슬레이브는 읽기 전용으로 설정하자.**
사용자 실수나 애플리케이션 오류로 마스터가 아닌 슬레이브로 접속해서 데이텨 변경을 수행하는 경우가 있다. 이런 실수를 막기 위해 슬레이브는 ReadOnly로 설정하는것이 일반적이다. 

**슬레이브 서버용 장비는 마스터와 동일한 사양이 좋다.**
마스터 서버에서 수많은 데이터 변경 쿼리 문장이 슬레이브 서버에서는 하나의 스레드로 처리되어야 한다. 그래서 변경이 잦은 서버 일수록 마스터 서버의 사양보다 슬레이브의 사양이 더 좋아야 슬레이브에서 지연되지 않고 하나의 스레드로 처리된다. 또한 슬레이브 서버는 마스터가 다운된 경우, 복구 대안으로도 사용될수 있기 때문에 사양을 동일하게 맞추는게 좋다.

**복제가 불필요한 경우 바이너리 로그 수행 중지하자.**
바이너리 로그를 작성하기 위해 MySQL이 많은 성능을 소모하고 있다. 바이너리의 안정적 기록을 위해 갭락(Gap Lock)을 유지하고, 트랜잭션이 커밋될때마다 바이너리 로그에 기록을 해야 한다. 바이너리를 기록하는 작업은 AutoCommit이 활성화된 MySQL 서버에 더 크게 나타난다. 

**바이너리 로그와 트랜잭션 격리 수준**

바이너리 로그파일은 어떤 내용이 기록되느냐에 따라 STATEMENT방식과 ROW 포맷 방식이 있다. STATEMENT는 마스터에서 실행되는 쿼리 문장을 기록하는 방식이고, ROW포맷은 실행된 쿼리에 의해 변경된 레코드 값을 기록하는 방식이다. STATEMENT방식은 데이터 일치를 위해 REPEATABLE READ격리 수준만 사용가능하다. MySQL 5.0이하 버전 + STATEMENT 방식 + REPEATABLE_READ 격리 수준 환경에서는 "INSERT INTO ... SELECT FROM .." 형태의 쿼리를 사용할때는 주의해야 한다. 왜냐하면 INSERT 쿼리 잠금이 발생할 수 있기 때문이다. 

>MySQL 5.1부터는 바이너리 로그 파일에 SQL 문장을 기록하는 방(Statement based replication)과 변경된 레코드를 바이너리 로그에 기록하는 방식(Row base replication)이 존재한다.  Statement base replication은 문장 하나만 전달되므로 네트워크 비용이 적다. 하지만 복제가 정상 동작하려면 REPEATABLE_READ 이상의 트랜잭션 격리 수준을 사용해야 한다. 그로 이해 InnoDb 테이블에서는 레코드간의 간격을 잠그는 갭락이나 넥스트키 락이 필요해 진다.  레코드 기반은 네트워크 비용을 키울 수는 있지만 READ-COMMITED 격리 수준에서도 작동하며 덕분에 잠금 경합이 줄어든다. 

## 쿼리 캐시(Query Cache)

쿼리 캐시는 타 DBMS에서는 볼 수 없는 MySQL만의 독특한 기능이다. **쿼리 캐시는 단어의 의미와는 달리 SQL 문장을 캐시하는 것이 아니라 쿼리의 결과를 메모리에 캐시해두는 기능이다.** 
쿼리 캐시 구조는 Map으로 구현되어 있다. 키는 쿼리 문장 자체이고, 값은 해당 쿼리의 결과이다. 실제 쿼리할 때는 복잡한 처리 절차가 있다. 이를 무시하고 동일한 쿼리 문장이 요청되었다고 해서 바로 캐시된 결과를 보내선 안된다. 캐시 결과를 내려보기 전에 아래와 같은 확인 절차를 거친다. 

### 쿼리 캐시 결과 확인 절차

1. 요청된 쿼리 문장이 캐시에 존재하는가?
2. 해당 사용자가 쿼리를 볼 수 있는 권한이 있는가?
3. 트랜잭션 내에 실행된 쿼리의 경우, 그 결과가 범위내의 트랜잭션에서 만들어진 결과인가?
4. 캐시가 만들어지고 난 후 데이터가 다른 사용자에 의해 변경되지 않았는가?
5. 쿼리에 사용된 내장함수, 저장함수등이 캐시되어도 동일한 결과를 보장하는가?
6. 쿼리 결과가 캐시해두기에는 너무 크지 않은가?
7. 그 밖에 캐시를 사용하지 못하게 하는 요소가 있는가?


# InnoDB Storage Engine 
MySQL에서 사용할 수 있는 스토리지 엔진 중에서 **거의 유일하게 레코드 기반 잠금 기능이 있다.** 따라서 높은 동시성 처가 가능하고 안정적이며 성능이 뛰어나다. 

엔진 특성
* 프라이머리 키에 의한 클러스터링
	* 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 즉 프라이머리 키 값의 순서대로 저장된다. 따라서 쿼리 실행 계획에서 프라이머리 키를 사용하면 빠르게 처리가 될 가능성이 크다. 
* 잠금이 필요 없는 일관된 읽기(Non-locking consistent read)
	* MVCC(Multi Version Concurreny Control)이라는 기술로 락을 걸지 않고 읽기 작업을 수행한다. 
* 외래키 지원
	* 외래키는 여라가지 제약사항 때문에 실무에서 많이 사용하지는 않다. 왜냐하면 데이터 변경시 여러 테이블에서 데이터가 있는지 체크하는 작업이 필요해서 잠금이 여러 테이블로 전파되고, 이로 인해 데드락이 발생하는 경우가 많다.
* 자동 데드락 감지
	* 그래프 기반의 데드락 체크 방식을 사용하여, 데드락이 발생하면 바로 감지되고, 감지된 데드락은 관련 트랜잭션 중에서 가장 적게 변경한 또는 가장 복구작업이 적게 드는 트랜잭션을 찾아 강제 종료해버린다. 따라서 데드락 때문에 쿼리 Timeout또는 슬로루 쿼리로 기록되는 경우는 별로 없다. 
* 오라클 아키텍처 적용
	* InnoDB는 오라클 DBMS와 상당히 비슷한 부분이 많다. MVCC, Undo 데이터가 시스템 테이블 스페이스의 개념등 비슷한 부분이 많다.

![enter image description here](https://t1.daumcdn.net/cfile/tistory/99A451505BDFF70729)

## InnoDB Buffer Pool

파일 디스크의 데이터 파일이나 인덱스 정보를 캐시해 두는 메모리 공간이다. Buffer Pool이란 이름에서 알 수 있듯이 다수의 Buffer 공간을 가진다. Buffer는 주로 쓰기 작업을 지연시켜 일괄적으로 처리하여 성능향상을 꾀한다. 일반적인 애플리케이션에서은 테이블의 레코드를 변경하는데 이를 버퍼 풀에 모아서 처리하면 디스크 변경 작업의 횟수를 줄일 수 있다. 

### Insert Buffer

레코드가 INSERT되거나 UPDATE 될때는 데이터 파일을 변경하는 것 뿐만아니라 해당 테이블에 인덱스를 업데이트하는 작업도 필요하다. 이 작업을 위해서 디스크를 읽고 쓰는 작업이 필요한데 이게 리스크하다. 그래서 변경할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하고, 없다면 디스크로부터 읽어와 업데이트를 해야할때는 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상 시킨다. 이때 사용하는 임시 메모리 공간을 Insert Buffer라 한다.  

### Undo Record

Undo 영역은 UPDATE, DELETE 같은 문장으로 데이터 변경 전에 이전 데이터를 보관하는 곳이다. Undo 데이터는 트랜잭션 롤백을 위해 사용된다. 또 트랜잭션 격리 수준에 맞는 MVCC를 위해 사용된다.

#### MVCC(Multi Version Concurrency Control)
MVCC는 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.  멀티 버전이라는 것은 한개의 레코드에 대해서 여러 버전이 동시에 관리된다는 의미이다. 한 레코드는 Buffer Pool(undo영역을 제외한...), Undo Record, Disk file에 3가지 버전으로 기록이 된다. 주요 목적은 잠금을 사용하지 않는 일관된 읽기(Non-locking consistent read)를 제공하는데 있는데, 이때 Undo 기록을 사용한다.

UPDATE 문장이 실행되면 커밋 실행 여부와 관계 없이, Buffer Pool이 새로운 값으로 수정되고, 디스크의 레코드도 일반적으로 동일한 상태의 데이터가 된다. 그리고 이전의 레코드를 Undo영역에 저장한다.
아직 COMMIT이나 ROLLBACK이 일어나지 않은 상태에서 다른 트랜잭션에서 작업 중이던 레코드를 조회하면 어떤 버전의 데이터를 조회할까?

SELECT의 반환 결과는 설정된 격리 수준(Isolation level)에 따라 다르다. READ_UNCOMMITED의 경우, 데이터를 단순히 Buffer Pool이나 Disk에서 읽어 온다. READ_COMMIT 또는 그 이상의 수준일때는 Buffer Pool이나 Disk 대신에 Undo Record에서 데이터를 가져온다. 즉 하나의 레코드가 2개의 버전이 존재하고, 상황에 따라 다른 데이터가 반환되는 구조이다. 

만약 ROLLBACK을 하면, 언두 영역의 백업된 데이터를 Buffer Pool과 Disk로 복구하고, 언두 영역의 내용을 삭제한다. 그렇다고 언두 데이터가 바로 삭제 되는것은 아니고 언두 영역을 필요로 하는 트랜잭션이 더 없을때 비로소 삭제 된다. 

MVCC의 주요 목적은 잠금 없는 일관된 읽기(Non-locking consistent read)를 사용하기이라 이야기 했다. 일관된 읽기를 사용하기 위해서는 두 조건이 따르는데 일단 격리 수준이 SERIALIZABLE이 아니고, 다른 트랜잭션에서 INSERT 작업을 하지 말아야 한다. SERIALIZABLE보다 낮은 수준에서 INSERT 작업 중이면 PhantomRead 상황이 발생할 수 있기 때문에 여기서는 잠금 없는 일관된 읽기가 불가능하다. 

## Log Buffer & Redo Log

트랜잭션 보장을 위해서는 앞서 보았던 Buffer Pool만으로는 부족하다. 트랜잭션 보장을 위해선 변경된 내용을 순차적으로 데이터 파일로 기록해야 한다. 이 데이터 파일이 우리가 일반적으로 부르는 로그파일이고 리두로그(Redo Log)라고 부른다. 일반적으로 DBMS에서 로그라 하면 일반적으로 이 리두 로그(Redo Log)를 말한다. 

변경작업이 많은 서버에서는 로그 기록작업도 부하가 커서, 버퍼링을 사용하게 되는데, 이때 사용하는 버퍼가 Log Buffer이다.

# NDB Cluster Storage Engine

## Cluster

클러스터는 NDB(Network DataBase) 클러스터 스토리지 엔진을 사용한다. 이 엔진은 네트워크를 통해 데이터 분산을 지원하는 스토리지 엔진이다. 

## NDB 클러스터의 특징

- 무공유 클러스터링
	- NDB 클러스터는 클러스터 그룹내의 모든 노드가 아무것도 공유하지 않는 무공유 아키텍처로 구현되어 있다. NDB 클러스터는 데이터를 저장하는 스토리지가 분산되어 관리되기 때문에 한 데이터 저장소가 작동을 멈추더라도 서비스에 영향이 없다. 
- 메모리 기반의 스토리지 엔진
- 자동화된 Fail-over
- 분산된 데이터 저장소간의 동기 방식 복제

## [Cluster VS Replication](https://blog.seulgi.kim/2015/05/what-is-mysql-replication.html)

클러스터와 리플리케이션은 자주 비교 대상이 된다. MySQL replication은 데이터베이스를 그대로 복사하여 데이터베이스를 한 벌 더 만드는 기능이다. 언뜻 보면 MySQL cluster와 비슷하지만, 분산환경을 만들어서 [single point of failure](http://en.wikipedia.org/wiki/Single_point_of_failure)를 없애려는 cluster와는 달리 MySQL replication은 단순히 데이터를 복제한다.  
  
모든 데이터가 실시간 동기화되는 cluster와는 달리, replication은 동기화가 비동기적으로 발생한다. 따라서 어떤 데이터베이스에는 데이터가 업데이트되어 있지만, 다른 데이터베이스에서는 업데이트되지 않을 수도 있다.  또한, 마스터와 슬레이브로 나누어지기 때문에 데이터를 변경하는 쿼리는 단 하나의 데이터베이스에만 요청할 수 있다. 다시 말해서 슬레이브의 데이터를 변경하면, 마스터에 그 변경은 반영되지 않고, 동기화하는 도중 에러를 발생시키기도 한다.  

위의 이야기를 들으면 Cluster가 모든 면에서 좋아 보이지만 꼭 그렇지만은 않다. Replication의 최대 장점은 바로 값의 변경이 매우 빠르다는 것이다. Cluster는 값을 변경하려고 하면 클러스터 군을 이루는 다른 서버들도 값이 변경되었다는 것을 확인해 주어야 한다. 하지만 replication은 마스터의 값만 변경하면 되기 때문에, 값을 변경하는 쿼리가 매우 빠르게 실행된다.  그래서 주로 실시간 동기화가 필요 없는 경우 cluster대신 replication을 사용한다.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgxMjc5Mjg2Myw4NTgyNDEyODBdfQ==
-->