# MongoDB 샤딩 아키텍처

컨피그 서버는 샤드 클러스터에서 사용자가 생성한 데이터베이스와 컬렉션들의 목록을 관리한다. 하지만 모든 데이터베이스와 컬렉션 목록을 관리하는 것이 아니라, 샤딩이 활성화된 데이터베이스와 컬렉션 정보만을 관리한다. 

샤딩이 되지 않은 객체들은 컨피그 서버가 아니라 각 샤드 서버가 로컬로 관리한다. 그리고 이런 샤드를 프라이머리 샤드라고 한다.

컨피그 서버는 각 컬렌션이 여러 사드 서버로 분산되기 위한 데이터 조각을 관리하는데 이것을 청크(Chunk) 한다. 

다음은 라우터 서버로 쿼리를 요청했을때 진행되는 과정을 나타낸다. 

1. 사용자 쿼리가 참조하는 컬렉션의 청크 메타 정보를 컨피그 서버로부터 가져와 라우터 메모리에 캐시
2. 사용자의 쿼리 조건에서 샤딩키를 찾음
	3. 쿼리 조건에 샤당 키가 있으면 해당 샤딩키를 가지는 모든 청크 정보를 라 우터 캐시에서 검색하여 청크를 가지는 모든 샤드로 사용자 쿼리를 요청
	4. 쿼리 존에 샤딩 키가 없다면 모든 샤드 서버로 사용자 쿼리 요청
3. 쿼리를 전송한 대상 샤드서버로부터 쿼리 결과가 오면 병합하여 결과를 반환

1번 과정은 라우터가 청크 메타 정보를 가지고 있지 않거나 라우터가 가진 청크 메타 정보가 오래돼서 맞지 않을 경우만 수행됩니다. 따라서 요청 쿼리가 많다고 해서 매번 컨피그 서버에 메타 정보를 조회하는 것은 아닙니다. 

# 컨피그 서버

컨피그 서버는 샤딩된 클러스터를 운영하는데 있어 필요한 모든 정보를 저장합니다. 컨피그 서버는 버전에 따라 차이가 있지만 다음과 같은 컬렉션을 가지고 있습니다. 

* databases
* collections
	* 샤드 클러스터에 존재하는 모든 컬렉션, 샤당되지 않은 컬렉션은 제외
* chunks
	* 샤딩된 컬렉션의 모든 청크 정보, 샤딩되지 않은 컬렉션의 청크 정보는 제외
* shards
* mongos
	* 각 라우터는 30초 단위로 샤드 클러스터의 모든 멤버와 핑 메세지를 주고 받습니다. mongos 컬렉션은 현재 컨피그 서버와 한번이라도 연결했던 모든 mongos 목록을 저장합니다.
* settings
	* 청크의 밸런싱 관련 작업 설정이 저장됩니다.
	* 청크 사이즈, 청크 밸런싱 활성화 여부,  밸런싱 시작 시작, 병렬 청크 이동 여부등
* version
	* 
* lockpings
	* 컨피그 서버와의 연결 확인시, 어떤 멤버가 언제 연결 상태가 어땟는지 기록합니다.
* locks
	* 사드 클러스터에 많은 멤버들이 서로 작업을 동기화하면서 처리하는 과정에 같은 작업을 동시에 시작하면 충돌이 발생할 수 있습니다. 
	* 이런 충돌을 피하려면 Locks컬렉션의 잠금을 획득해야 합니다.
* changelog
	* 컨피그 서버의 메타 정보 변경을 유발한 이벤트에 대한 정보를 저장합니다. 
	* 청크 스플릿이나 마이그레이션 같은 작업은 전체 샤드 성능에 큰 저하를 가져올 수 있습니다. 이런 경우 changelog로 청크의 변화를 시간대 별로 확인 가능합니다. 
 
 이 컬렉션들은 모두 컨피그 서버에만 저장됩니다. 
 이 메타 데이터는 샤드 클러스터를 유지하기 위한 내부 관리 목적의 데이터 이므로 사용자가 직접 변경하거나 삭제해서는 안됩니다.

## 컨피그 서버 복제

컨피그 서버는 샤딩이 활성화된 유저의 데이터베이스와 컬렉션 정보 그리고 각 컬렉션의 청크 정보를 가지고 있습니다. 이 메타정보들은 일관성 유지를 위한 매우 중요한 정보이므로 반드시 단일 구성이 아닌 복제 서버를 갖추어야 합니다.

리플리카 셋으로 구현된 컨피그 서버를 CSRS(Config Server as Replica Sets)라고 부릅니다. 

이렇게 CSRS 서버를 구축하려면 아래 조건을 만족해야 합니다. 

* 컨피그 서버는 WiredTiger 스토리지 엔진을 사용해야 합니다.
* 리플리카 셋은 아비터를 가질 수 없습니다.
* 리플리카 셋은 지연된 멤버를 가질 수 없습니다.

레플리카 셋 방식의 컨피그 서버는 최소 3개 이상의 멤버를 갖도록 권장합니다. 컨피그 서버에서는 모든 정보 조회 및 변경 쿼리의 Read Concern과 Write Concern을 "majority"로 설정하는데, 이는 전체 레플리카 셋의 과반수에 접근할 수 있어야 쿼리를 수행한다는 것을 의미합니다. 그래서 만약 커피그 서버가 2대이면, 둘중 하나만 연결되지 않아도 정보 조회와 삭제가 불가하게 됩니다.

컨피그 서버가 샤드 클러스터의 중요한 정보를 저장하긴 하지만, MongoDB 서버가 사용자 쿼리를 처리하는데 컨피그 서버가 항상 필요한 것은 아닙니다. 

라우터 서버는 초기 기동시 메타정보를 일괄적으로 자신의 캐시에 저장해둡니다. 샤드 클러스터에 새로운 멤버가 추가/삭제, 컬렉션 생성/삭제, 청크의 분리/이동에만 라우터 서버가 컨피그 서버에 데이터 변경 쿼리를 실행합니다. 

새로 라우터를 재시작 하지만 않으면 실질적으로 컨피그 서버에 모두 연결할 수 없더라도 쿼리 처리에 아무런 문제가 없다. 

그래서 하드웨어 교체나 관리 작업을 위해 컨피그 서버를 재시작하는 작업은 크게 시간에  구애받지 않고 처리가능합니다. 

# 라우터

라우터 Mongos는 사용자의 쿼리 요청을 샤드 서버로 전달하고, 쿼리 결과를 모아 사용자에게 반환하는 프록시 역할을 한다. 

라우터는 컨피그 서버의 정보를 캐시해두고 있어 쿼리를 어느 샤드서버로 보내야할지 판단할 수 있습니다. 

라우터 서버는 샤드로 부터 결과를 병합하여 사용자에게 반환하며, 불필요한 데이터를 제거하는 역할도 합니다. 

다중 쿼리를 수행시키다 보면 , 샤드 키에 맞지 않는 문서를보게 됩니다. (Orphaned Document)는 청크 마이크레이션 중이거나, 실패했거나 사용자가 강제로 키에 맞지 않는 데이터로 변경하는 경우 발생할 수 있습니다. 

이럴때 필터링 영할이 중요하며 만약 라우터가 아닌 샤드 서버로 직접 쿼리를 할 경우 샤드 키에 맞지 않는 

또한 라우터는 정렬이나 LIMIT 그리고 SKIP과 같은 쿼리 옵션이 있습니다. 

정렬이 필요하지 않은 쿼리는 샤드로부터 각 결과를 라운드--로빈 방식으로  가져온 다음 결과를 반환합니다. 하지만 정렬해샤 할 경우는 검색해야할 샤드 서버 중에서 프라이머머리 샤드를 정하고, $Orderby$ 옵션을 통해서 쿼리를 전달한다. 그러면 프라이머리 샤드는 나머지 샤드로 부터 쿼리 결과를 받아 수행한 결가를 라우터 서버로 반환한다. 

MongoDB 2.X에선 정렬을 라우터 서버에서 수행했지만, 라우터에서 데이터 정렬 작업을 하면 처리 능력이 떨어질 수 있어 응답속도가 느려지는 경우가 많았습니다. 그래서 

MongoDB 3.X 버전부터는 정렬과 같은 무거운 작업은 처리 성능이 뛰어난 샤드 서버가 직접 처리하도록 프라이머리 샤드를 선택하고,  정렬을 위임합니다.

LIMIT가 붙으면 각 샤드가 LIMIT가 붙은 쿼리를 각 샤드에서  수행하고 최종적으로 다시 LIMIT처리를 하여 원하는 개수만 가져옵니다.

SKIP 옵션이 붙으면, 이런 작업이 불가하고 전체 샤드에서 필요한 결과를 병합한 다음 SKIP으로 필요한 문서를 버리고 


## 쿼리 분산

라우터는 쿼리 조건을 기준으로 어느 샤드에 쿼리를 요청할 것인지 판단해야 합니다. 

컬렉션은 특정 필드의 값을 기준으로 샤딩될 수 있는데, 샤용자 쿼리가 샤딩 기준 값에 대한 조건을 가지고 있느냐에 따라 라우터가 쿼리를 요청할 서버를 결정할 수 있습니다. 

라우터가 사용자의 쿼리로만 요청하는 형태를 타켓쿼리(Targeted Query)라 하며, 모든 서버로 요청하는 쿼리를 브로드캐스트 쿼리라 합니다. 둘의 효율은 상황에 따라 다릅니다. 

### 타겟 쿼리

샤드 키 조건으로 사용자가 쿼리가 원하는 데이터가 있는 샤드 서버를 알 수 있습니다. 그리고 실제로 그 샤드서버로만 쿼리를 보냅니다. 

![Choosing a good Shard Key in MongoDB | Blog of Ken W. Alger](https://i2.wp.com/www.kenwalger.com/blog/wp-content/uploads/2017/06/ShardingExample.png?resize=600%2C366)

* 찾고자하는 청크는 여러 샤드로 분포가 될 수 있기 때문에 타겟 쿼리라고 해서 꼭 단일 샤드에만 쿼리를 보내는 것이 아닙니다.
* 샤드 키로는 단일 필드 뿐만 아니라 복수 필드로도 사용 가능합니다. 

SELECT, UPDATE, DELETE의 경우 조건이 샤드 키를 포함하는 경우 타겟 쿼리로 동작할 수 있습니다. 

INSERT의 경우, INSERT 되는 문서가 항상 샤드 키를 포함하므로 항상 타겟 쿼리로 작동합니다. 

### 브로드캐스트 쿼리(Broadcast Query)

샤드 키를 쿼리 조건으로 가지지 않는 경우에는 라우터가 작업 범위를 특정 샤드로 줄일 수가 없습니다. 이런 경우는 해당 쿼리는 모든 샤드로 요청되고 이를 브로드캐스트 쿼리라고 합니다. 

## 커넥션 풀 관리

MongoDB 라우터는 MongoDB 드라이버(클라이언트 드라이버)와 MongoDB 샤드서버를 중계하는 역할이므로 클라이언트와 서버쪽 커넥션을 모두 가지고 있어야 합니다. 

하지만 클라이언트쪽은 독립적으로 커넥션이 유지 되므로 커넥션 수를 제어하기가 쉽자 않습니다. 


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwOTI0MzA0OTgsODcxMDkyODA0LC0zMT
c0NzcwNzksLTcxMDI2NDExMSwtMTEyNzEzOTE1MSwtMTkxMDA2
NDMxNywxMDc1MTgyMTgxLDEzMjM3MzQ1NTUsLTUzODUzNjQyMi
w1MzE0MzQ4NjMsMTAwMjY2Mjk3MSwyMTMzODg3NTIsLTk1MDIz
MTYwOCw1ODc4MDA2MzIsLTIxMjEzNjk0NjEsMjAxMjYyMTE2Ni
w3NDc3MTkxNzgsNzMwOTk4MTE2XX0=
-->