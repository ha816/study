# Overview

스토리지 엔진은 사용자의 데이터를 디스크와 메모리에 저장하고 읽어오는 역할을 합니다. 아래 그림은 MongoDB에 있는 스토리지 엔진의 특징을 정리해 둔 그림입니다.

![Building Applications with MongoDB's Pluggable Storage Engines ...](https://webassets.mongodb.com/_com_assets/cms/StorageEngineArchIMG2-ju0tb22fup.png)

MySQL과 비슷하게 MongoDB도 다양한 스토리지 엔진을 사용할 수 있도록 스토리지 엔진이 플러그인 형태로 제공됩니다. MongoDB 스토리지 엔진은 하나의 인스턴스에서 하나의 스토리지 엔진만 사용이 가능합니다.

> MMAPv1 스토리지
> MongoDB가 처음 출시되었을때 부터 사용되던 스토리지 엔진. 
> 대부분 낮은 버전의 MongoDB의 문제점은 MMAPv1 엔진 자체가 가지고 있던 문제점
> MongoDB 4.2 버전부터 MMAPv1 엔진은 삭제되었습니다.

# WiredTiger

MongoDB의 디폴트 스토리지 엔진. 

WiredTiget 스토리지 엔진의 특징

* Lock-free Algorithm(잠금 경합 최소화)
	* Hazard-Pointer와 Skip-List 메커니즘 적용
* MVCC
	* 

내부적인 잠금 경합 최소화(Lock-free Algorithm)을 위해서 하자드 포인터(Hazard-Pointer)나 스킵 리스트(Skip-List)와 같은 많은 신기술을 채택하였습니다. 

추가적으로 잠금 없는 데이터 읽기(Non-blocking consistent read)를 위한 MVCC 기술과 데이터 파일 압축 그리고 암호화 기능을 모두 제공합니다. 

## WiredTiger 내부 작동 방식

![enter image description here](https://image.slidesharecdn.com/mongodb-wiredtiger-webinar-150709200625-lva1-app6892/95/a-technical-introduction-to-wiredtiger-11-638.jpg?cb=1436472726)


### Cache(공유캐시)

WT 스토리지 엔진에서 사용자의 모든 쿼리는 공유 캐시를 거쳐서 처리됩니다. 땨뮨애 공유 캐시의 최적화는 MongoDB 스토리지 성능에 매우 중요한 역할을 담당합니다. 

일반적인  RDBMS에서는 한 데이터 페이지내의 레코드들의 대한 인덱스를 별도로 관리합니다. 하지만 WT는 데이터 페이지내의 레코드 인덱스를 별도로 관리하지 않습니다. 때문에 WT는 데이터 페이지를 공유 캐시 메모리에 적재할때 적합한 트리 형태의 레코드 인덱스를 재구성하면서 적재합니다. 여러 변환 재구성 과정을 거치기 때문에 RDBMS 보다는 느리게 처리되지만 **공유 캐시 메모리에 적재된 데이터 페이지에서 필요한 레코드를 검색하고 변경하는 작업은 기존 RDBMS보다 훨씬 효율적으로 동작합니다.** 그 이유는 좀 더 나중에 설명하겠습니다. 

짧은 시간 수 많은 쿼리를 처리해야하는 OLTP(On-Line Transaction Processing) 시스템에서는 많은 쿼리들이 공유 캐시에 있는 데이터 페이지를 참조하기 위해 경합하는 경우가 많습니다. 따라서 공유 캐시에 대한 잠금 경합이 성능에 많은 영향을 미치게 됩니다. WT는 잠금 경합을 최소화하기 위해 Lock-Free 알고리즘을 채용하고 있습니다. 일반적으로 Lock-Free 알고리즘은 잠금을 전혀 사용하지 않는 시스템을 말하는 것이 아니라 잠금 경합을 최소화 하는 알고리즘으로 이를 위해서 하자드 포인터와 스킵리스트 자료구조를 활용합니다. 

#### 하자드 포인터(Hazard Pointer)

하자드 포인터는 수정 또는 삭제 되면 위험한 객체 포인터를 말합니다. 

사용자 쓰레드는 쿼리를 처리하기 위해 공유 캐시를 참조하는 쓰레드입니다. 쿼리가 들어오면, 사용자 쓰레드는 사용하려는 데이터 페이지를 자신의 하자드 포인터 리스트에 등록합니다. 필요한 작업을 수행하고 하자드 포인터 리스트에서 사용이 끝난 데이터 페이지를 제거합니다. 

이빅션 쓰레드(Eviction Thread)는 자주 사용되지 않는 데이터 페이지를 제거하여 캐시의 여유 공간을 만들어 주는 쓰레드 입니다. 이때 무조건 제거를 하는 것이 아니라 사용자 쓰레드의 하자드 포인터 리스트에 등록되어 있지 않은 데이터 페이지만을 제거합니다. 반대로 등록되어 있으면 해당 페이지는 건너뛰게 됩니다. 왜냐하면 하자드 포인터 리스트에 데이터 페이지가 있다는 이야기는 해당 데이터 페이지가 수정 또는 삭제되면 않된다는 것을 의미하기 때문입니다.

WT에서 기본적으로 사용가능한 하자드 포인터 갯수는 최대 1000개 입니다. 하자드 포인터의 개수가 부족해서 처리량이 느려진다면 옵션을 변경하여 늘릴 수 있습니다.

#### [스킵 리스트(Skip-List)](https://brilliant.org/wiki/skip-lists/#:~:text=The%20skip%20list%20is%20a,elements,%20but%20no%20new%20elements.)

스킵리스트를 사용하면, 노드 검색, 추가에 별도의 잠금이 필요하지 않습니다. 삭제의 경우는 일부 잠금이 필요할 수 있으나 RDBMS의 보다는 빠르게 처리 됩니다. 종합적으로 스킵 리스트를 사용하면, 잠금 경합이 적어져서 더 좋은 성능을 보입니다. 

RDBMS에서 레코드를 별도의 공간(언두 로그)에 저장하는 이유는 트랜잭션이 롤백 될때 기존 데이터를 복구하기 위함인데, 보통 언두 로그를 잠금 없는 데이터 읽기 용도로도 같이 사용합니다.

WT에서는 스킵리스트가 언두로그의 역할을 하게 됩니다. 스킵리스트에는 변경된 데이터 페이지들이 추가되는 구조 입니다. 검색 쿼리가 들어오면, 변경 이력이 저장된 스킵 리스트에서 검색해 원하는 시점의 데이터 페이지를 가져 갑니다. 

일부 RDBMS에서 데이터 페이지는 한 시점에 하나의 쓰레드만 사용(읽고 쓰기)할 수 있다. 하지만 WT은 스킵 리스트로 여러 쓰레드가 하나의 페이지를 동시에 읽거나 쓸 수 있어 동시 처리 성능이 매우 향상됩니다.

#### 캐시 이빅션(Cache Eviction)

WT는 공유 캐시를 위해서 새로운 디스크 데이터 페이지를 읽어 적재할 수 있도록 빈 공간을 항상 유지해야 합니다. 그렇지 않으면 쿼리가 필요한 데이터 페이지를 가져오지 못해 처리 응답속도가 느려집니다.

공유 캐시의 적절한 빈 공간 유지를 위해 Eviction 쓰레드가 백그라운로 돌아갑니다. 

기본적으로는 현재 공유 캐시에서 페이지 중 자주 사용되지 않은 페이지를 제거합니다. 이 과정에서 공유 캐시스캔을 상당히 많이 수행하게 됩니다. 

그런데 SSD와 같이 매우 빠르게 읽기/쓰기 작업이 가능한 저장 매체가 출시되어 한번에 읽어들 일 수 있는 데이터 페이지수가 많아졌습니다.  WT엔진은 가끔씩 캐시의 데이터 페이지 삭제 속도가 데이터 페이지를 읽어 들이는 속도를 따라가지 못하는 이슈도 있습니다. 

이런 경우 보통 공유 캐시는 80%정도의 사용량을 유지해야 하는데, 그걸 넘어서서 데이터 페이지가 가득차게 됩니다. WT는 이런 상황에서 포그라운드 쓰레드인 사용자 쓰레드로 직접 캐시 이빅션을 추가로 실행합니다.  이렇게 되면 사용자 쿼리가 처리되지 못하고 쿼리 처리 성능이 크게 떨어지게 됩니다. 

#### 체크 포인트(Checkpoint)

WT도 사용자의 요청을 빠르게 처리하면서 커밋된 트랜잭션의 영속성(Durability)을 보전하기 위해 트랜잭션 로그(WAL, 저널 로그)를 먼저 기록하고, 실제 데이터 파일에 기록하는 작업은 사용자의 트랜잭션과 관련없이 뒤로 미루어 한꺼번에 처리한다. 

체크 포인트는 디스크 데이터 파일과 트랜잭션 로그가 동기화되는 시점을 말합니다. 이 체크 포인트는 주기적으로 백그라운드 쓰레드에 의해서 실행되는데, 체크포인트가 실행되어야만 오래된 트랜잭션 로그를 삭제하거나 새로운 트랜잭션 로그로 덮어쓸 수 있게 됩니다. 


체크포인트는 서버 장애가 발생했을때, 복구 시점을 결정하는 기준이 됩니다. 체크포인트의 간격이 너무 길면 서버 복구 시간이 오래걸리고, 너무 짧으면 비번히 체크포인트가 발생하여 성능이 떨어질 수 있습니다. 

WT는 샤프 체크포인트방식을 사용하고 있는데, 샤프 체크 포인트는 평상시에는 디스크 쓰기가 많지 않지만, 체크포인트가 실행되는 시점에 한번에 모아서 페이지를 기록하는 패턴입니다. 

#### 



기본적으로 MongoDB는 단일 문서 단위에 Transactions을 보장합니다. 
만약 사용자가 특정 문서를 변경하면, WT가 트랜잭션을 시작하고 커서를 이용해서 원하는 다큐먼트의 내용을 변경합니다. 변경 내용은 먼저 캐시에 적용되는데, 디스크에 기록되기 전에 변경 내용을 저널 로그에 기록한 다음 사용자에게 작업 처리 결과를 리턴합니다. 

이런 식으로 공유 캐시가 어느 정도 쌓이면 WT는 체크포인트를 발생시켜서 공유 캐시의 더티 페이지들을 모아 디스크에 기록합니다. 이때 메모리 상의 더티 페이지는 디스크에 기롭하기 전 원본 데이터와 변경된 정보의 병합)을 거쳐야하는데, 이를 WT의 Reconciliation 모듈이 처리합니다. 


사용자가 쿼리를 실행하면 블록 매니저(Block Manager)를 통해서 필요한 데이터 블록을 디스크에서 읽어온 다음 공유 캐시에 적재 하고 처리합니다. 

사용자 요청 쿼리가 실행되면 블럭 매니저는 계속해서 새로운 데이터 페이지들을 공유 캐시로 읽어 들여야 하는데, 더 이상 데이터 페이지를 읽어 들일 공간이 없으면 사용자 쿼리를 수행할 수 없게 된다. 이런 상황을 피하기 위해서 WT는 Eviction 모듈을 사용하며, 이 모듈은 공유 캐시가 적절한 메모리 사용량을 유지하도록 공유 캐시에서 자주 사용되지 않는 데이터 페이지들을 제거하는 작업을 수행한다. 

만약 제거해야 하는 데이터 페이지가 더티 페이지라면, 리컨실리에이션을 수행하고 공유 캐시에서 제거합니다.

WT 스토리ㅣ지 엔진의 데이터 블록은 모두 가변사이즈입니다. 





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY4MTY3Njc0MiwyMDc2MjgxMjI5LDE4OD
k1MjYzODcsLTQwOTUzNDcyMywxMDU3MDI1MTAyLC0zMjA1NzU1
MjQsLTI0NzczMDQ2NCwtNTQyMDI4ODkzLDg4MzM0ODM2NiwtMT
k3MDg1OTI0NywtMTM0OTY2MTE4LC0xNTk1MTY1Nzg4LC0xMDQw
MTk4MzAxLC0xODM2MDM3MzA0LC0xNDc4NDk5NjEsLTM3ODcxMz
M3LDc2Njg5MzU3MCw3MDI1MDM3NTAsMTIxMDc1NTk1OCwtMTI5
NTMzMjczN119
-->