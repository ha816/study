# Architecture

## ENGINE

MySQL엔진
: 커넥션핸들러와 SQL파서 및 전처리기 그리고 옵티마이저가 중심을 이룬다. 그리고 성능 향상을 위해 MyISAM의 키 캐시나 InnoDB의 버퍼풀과 같은 보조 저장소 기능이 포함되어 있다. MySQL엔진은 DBMS의 두뇌와 같은 처리를 수행한다. 

스토리지 엔진
: 실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 역할은 스토리지 엔진이 담당한다.  MySQL엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있다. 

핸들러 API
: MySQL엔진이 쿼리 수행을 위해 각 스토리지 엔진에게 쓰기 또는 일기를 요청하는데 이러한 요청을 핸들러 요청이라고 한다. 그리고 이때 사용되는 API를 핸들러 API라고 한다. 

```
create table test_table (...) ENGINE =INNODB, MyISAM;
```

## THREAD Structure
MySQL은 프로세스 기반이 아니라 스레드 기반으로 동작한다. 
스레드는 크게 포그라운드 스레드(클라이언트 스레드)와 백그라운드 스레드로 구분할 수 있다.

포그라운드 스레드(Foreground Thread)
: MySQL서버에 접속한 클라이언트의 수 많큼 존재한다. 주로 각 클라이언트에 사용자의 요청쿼리를 처리하는 역할을 한다. 클라이언트의 커넥션이 종료되면 다시 Thread pool로 돌아간다. 

백그라운드 스레드(Background Thread)
: 여러 중요한 작업이 백그라운드 스레드로 수행된다. 버퍼의 데이터를 디스크로 쓰는 쓰기 쓰레드(Write Thread)와 로그 쓰레드(Log Thread)가 대표적이다.

사실 쓰기 작업은 지연(버퍼링, 누적)하여 처리될 수 있지만, 읽기 작업은 절대 지연되면 안된다. 일반적인 DBMS은 쓰기작업을 버퍼링하여 일괄 처리하는 기능이 있다.

## Memory Structure

메모리는 MySQL 파라미터로 설정해 둔 만큼 운영체제로 부터 메모리를 할 당 받는다. 메모리 영역은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 두 영역의 차이는 서버 내의 스레드가 공유하는 영역인지 아닌지에 따라 구별된다.

글로벌 메모리 영역(Global Memory Area)
: 모든 스레드가 공유하는 영역이다. 2개 이상의 글로벌 메모리 영역을 받을 수도 있지만, 마찬가지로 모든 스레드가 볼 수 있다.

로컬 메모리 영역(Local Memory Area, Session Memory Area, Client Memory Area)
: 클라이언트 쓰레드가 사용하는 대표적인 메모리 영역이다. 클라이언트 쓰레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역. 또 서버와 커넥션을 맺는 세션이라 하여 세션 메모리 영역이라고도 한다.

## 쿼리 실행 구조
파서 - 전처리기 - 옵티마이저 - 쿼리 실행기 

파서(Parser)
:  들어온 쿼리를 토큰(MySQL이 인식하는 최소 단위의 어휘)으로 분리해 트리 형태의 구조를 만드는 작업을 한다. 이 과정에서 문법 오류가 있으면 오류 메세지를 반환한다.

전처리기
: 파서 과정에서 만들어진 트리를 기반으로 다른 유형의 문제점을 확인한다. 예를 들면, 접근 권한 여부와 컬럼, 테이블등이 존재하는지 여부를 확인한다. 

옵티마이저
: 쿼리를 어떻게 가장 저렴한 비용으로 빠르게 처리할지 결정하는 역할을 담당한다. 어떻게 하면 옵티마이저가 나은 선택을 하도록 유도하는가가 중요하다.

실행기
: 실행기는 옵티마이저에서 만든 계획대로 여러 핸들러에게 필요한 작업을 요청하고 받은 결과를 클라이언트에게 반환한다. 핸들러는 실행기의 요청에 따라 핸들러가 대응하는 스토리지 엔진을 조작하여 필요한 작업을 수행한다. 

## 쿼리 캐시(Query Cache)

쿼리 캐시는 타 DBMS에서는 볼 수 없는 MySQL만의 독특한 기능이다. **쿼리 캐시는 단어의 의미와는 달리 SQL 문장을 캐시하는 것이 아니라 쿼리의 결과를 메모리에 캐시해두는 기능이다.** 
쿼리 캐시 구조는 Map으로 구현되어 있다. 키는 쿼리 문장 자체이고, 값은 해당 쿼리의 결과이다. 실제 쿼리할 때는 상당한 부분의 처리 절차가 있다. 이를 무시하고 동일한 쿼리 문장이 요청되었다고 해서 바로 캐시된 결과를 보내선 안된다. 캐시 결과를 내려보기 

쿼리 캐시의 결과를 내려보내기 전 확인 절차

1. 요청된 쿼리 문장이 캐시에 존재하는가?
2. 해당 사용자가 쿼리를 볼 수 있는 권한이 있는가?
3. 트랜잭션 내에 실행된 쿼리의 경우, 그 결과가 범위내의 트랜잭션에서 만들어진 결과인가?
4. 캐시가 만들어지고 난 후 데이터가 다른 사용자에 의해 변경되지 않았는가?
5. 쿼리에 사용된 내장함수, 저장함수등이 캐시되어도 동일한 결과를 보장하는가?
	6. 
6. 쿼리 결과가 캐시해두기에는 너무 크지 않은가?
7. 그 밖에 캐시를 사용하지 못하게 하는 요소가 있는가?






<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQ5MjExMjI4MCwtOTU1MDQ3NDE1LC0xMD
M1NDk4NTYxLDUxMDM4MTQwOSwtOTQ2OTIzMzI4LC0xNTk2OTIy
NDI2LDkyMTYzNjE0NCw3MTQxNDg0NTMsMzM2MjY0MjM4LDE4OT
IxOTg1MjksMTU2NzAxNDMxNSwzMzMyNzMxNjcsLTM3NjU4OTUz
NCwzOTk4MjI1NjMsMTM0NjIzODA0LC0xNjM0ODUxMzAyLC0xMz
gzNTkxODkwLDg1MTQ2NzAwOCwxNTM4MDg1NTg4LDEzMzg1NTM2
NTJdfQ==
-->