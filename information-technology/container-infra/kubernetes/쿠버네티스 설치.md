

# Kubectl Commands


`kubectl version`
버전 체크하기

`kubectl cluster-info`
클러스터 정보 보기 

`kubectl get nodes`
우리의 애플리케이션을 host하는데 사용할 수 있는 모든 노드들을 보여줍니다. 

`kubectl proxy`
현재 쿠버네티스 클러스터에서 외부와 연결되는 proxy를 엽니다. 설정된 uri경로로 접근하면 kubectl의 명령을 실행해 볼 수 있다.


`kubectl describe pods`

Pod’s container: IP address, the ports used and a list of events related to the lifecycle of the Pod.


# 쿠버네티스 deployment

일단 쿠버네티스 클러스터를 구동시키면, 그 위에 컨테이너화된 애플리케이션을 배포할 수 있습니다. 그러기 위해서, 쿠버네티스 디플로이먼트 설정을 만들어야 합니다. 디플로이먼트는 쿠버네티스가 애플리케이션의 인스턴스를 어떻게 생성하고 업데이트해야 하는지를 지시합니다. 디플로이먼트가 만들어지면, 쿠버네티스 마스터가 해당 디플로이먼트에 포함된 애플리케이션 인스턴스가 클러스터의 개별 노드에서 실행되도록 스케줄합니다.

애플리케이션 인스턴스가 생성되면, 쿠버네티스 디플로이먼트 컨트롤러는 지속적으로 이들 인스턴스를 모니터링합니다.. 인스턴스를 구동 중인 노드가 다운되거나 삭제되면, 디플로이먼트 컨트롤러가 인스턴스를 클러스터 내부의 다른 노드의 인스턴스로 교체합니다. **이렇게 머신의 장애나 정비에 대응할 수 있는 자동 복구(self-healing) 메커니즘을 제공합니다.**

![](https://d33wubrfki0l68.cloudfront.net/152c845f25df8e69dd24dd7b0836a289747e258a/4a1d2/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg)

# App 배포해보기

`kubectl create deployment` 을 사용하며 app을 배포할 수 있습니다. deployment 이름과 도커 이미지의 위치를 입력하면 됩니다.

```
kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
deployment.apps/kubernetes-bootcamp created
```

배포 리스트를 보고 싶다면  `kubectl get deployments`를 사용하면 됩니다. 노드 상의 도커 컨테이너 안에서 동작 중인 app 인스턴스를 볼 수 있습니다. 

# 쿠버네티스 오브젝트 기술하기

쿠버네티스에서 오브젝트를 생성할 때, (이름과 같은)오브젝트에 대한 기본적인 정보와 더불어, 의도한 상태를 기술한 오브젝트 spec을 제시해 줘야만 합니다. 오브젝트를 생성하기 위해 쿠버네티스 API를 사용할 때, API 요청 안에 오브젝트 Spec 정보를 포함시켜 줘야만 합니다.

```yaml
apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment # deployment 타입의 쿠버네티스 오브젝트 
metadata:
  name: nginx-deployment # 쿠버네티스 오브젝트 이름
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers: # 컨테이너 설정
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

위 예시와 같이 .yaml 파일을 이용하여 디플로이먼트를 생성하기 위한 하나의 방식으로는  `kubectl`  커맨드-라인 인터페이스에 인자값으로  `.yaml`  파일을 건네는 커맨드 `kubectl apply`를 이용하는 것 입니다. 

```shell
kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
```

그 출력 내용은 아래와 같이 deployment가 생성되었다고 알려줍니다. 

```
deployment.apps/nginx-deployment created
```

### 필수 필드

생성하고자 하는 쿠버네티스 오브젝트에 대한  `.yaml`  파일 내, 다음 필드는 필수 값입니다.

-   `apiVersion` 
	- 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지
-   `kind`
	- 어떤 종류의 오브젝트를 생성하고자 하는지
-   `metadata`
	- `name`  문자열,  `UID`, 그리고 선택적인  `namespace`를 포함하여 오브젝트를 유일하게 구분지어 줄 필드를 입력
-   `spec`  
	- 오브젝트에 대해 어떤 상태 또는 spec을 가지게 할지

쿠버네티스 오브젝트의 종류(kind)에 따라 `spec`의 정확한 포맷이 다릅니다. 더욱이 그 오브젝트 특유의 고유한 중첩된 필드를 가질 수도 있습니다. [Kubernetes API Reference](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/)  는 쿠버네티스를 이용하여 생성할 수 있는 오브젝트에 대한 모든 spec 포맷을 살펴볼 수 있도록 해준다. 

예를 들어, Pod에 대한  `spec`  포맷은  [PodSpec v1 Core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core)  에서 확인할 수 있고, 디플로이먼트에 대한  `spec`  포맷은  [DeploymentSpec v1 apps](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#deploymentspec-v1-apps)에서 확인할 수 있습니다.


# 관리 명령

쿠버네티스 오브젝트를 관리할때는 하나의 기법만 사용하여 관리해야 합니다. 동일한 오브젝트에 대해 혼합된 방식의 기법은 혼란을 야기합니다.

## 명령형 커맨드(Imperative commands)

명령형 커맨드를 사용할 경우, 사용자는 클러스터 내 활성 오브젝트를 대상으로 직접 동작시킵니다. 사용자는  `kubectl`  커맨드에 인수 또는 플래그로 작업을 제공합니다.

이것은 클러스터에서 일회성 작업을 개시하거나 동작시키기 위한 가장 단순한 방법이다. 이 기법은 활성 오브젝트를 대상으로 직접적인 영향을 미치기 때문에, 이전 구성에 대한 이력을 제공해 주지 않습니다.

```sh
kubectl create deployment nginx --image nginx
```

## 명령형 오브젝트 구성(Imperative object configuration)

명령형 오브젝트 구성에서 kubectl 커맨드는 작업(생성, 교체 등), 선택적 플래그, 그리고 최소 하나의 파일 이름을 정의해야 합니다. 그 파일은 YAML 또는 JSON 형식으로 오브젝트의 완전한 정의를 포함해야만 합니다.



```sh
kubectl create -f nginx.yaml // 구성 파일에 정의된 오브젝트를 생성한다.
kubectl delete -f nginx.yaml -f redis.yaml // 두 개의 구성 파일에 정의된 오브젝트를 삭제한다.
kubectl replace -f nginx.yaml // 활성 동작하는 구성을 덮어씀으로써 구성 파일에 정의된 오브젝트를 업데이트한다.
```

## 선언형 오브젝트 구성(Declarative object configuration)

선언형 오브젝트 구성을 사용할 경우, 사용자는 로컬에 보관된 오브젝트 구성 파일을 대상으로 작동시키지만, 사용자는 파일에서 수행 할 작업을 정의하지 않는다. 생성, 업데이트, 그리고 삭제 작업은 `kubectl`에 의해 오브젝트 마다 자동으로 감지된다. 이를 통해 다른 오브젝트에 대해 다른 조작이 필요할 수 있는 디렉터리에서 작업할 수 있다.

`configs` 디렉터리 내 모든 오브젝트 구성 파일을 처리하고 활성 오브젝트를 생성 또는 패치한다. 먼저 어떠한 변경이 이루어지게 될지 알아보기 위해 `diff` 하고 나서 적용할 수 있다.

```sh
kubectl diff -f configs/
kubectl apply -f configs/

// 재귀적으로 디렉터리를 처리한다.
kubectl diff -R -f configs/
kubectl apply -R -f configs/
```




[https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/](https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/)
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjY2MDMyMzgsMTIxMzg5MjY3NF19
-->