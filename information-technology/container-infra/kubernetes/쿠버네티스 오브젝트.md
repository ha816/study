# Kubernetes Object

**쿠버네티스는 상태를 관리해야 하는 대상을 오브젝트로 정의합니다.** 기본으로 수십 가지 오브젝트를 제공하고 새로운 오브젝트를 추가하기가 매우 쉽기 때문에 확장성이 좋습니다. 

컨테이너 애플리케이션을 구동하기 위해 반드시 알아야할 몇 가지 중요한 오브젝트가 있습니다. 바로 Pod, 레플리카셋(Replica Set), 서비스(Service), 디플로이먼트(deployment) 입니다. 하나씩 알아봅시다.

##  Pod

포드는 컨테이너를 다루는 가장 기본 단위입니다. 포드는 1개 이상의 컨테이너로 구성된 컨테이너의 집합입니다. 즉 1개의 포드에는 다수의 컨태이너가 존재할 수 있습니다. 

**하나의 포드는 개념적으로 하나의 완전한 애플리케이션입니다.** 만약 한 애플리케이션이 실행되기 위해서 부가적인 기능이 필요하다고 한다면, 포드의 메인 컨테이너를 본연의 애플리케이션으로 삼고 부가적인 기능을 사이드카 컨테이너로 삼을 수 있습니다. 이렇게 포드에 정의된 부가적인 컨테이너를 사이드카라고 하며, 사이드카 컨테이너는 포드 내의 다른 컨테이너와 네트워크 환경 등을 공유하게 됩니다. 때문에 포드에 포함된 컨테이너들을 모두 같은 워커 노드에서 함께 동작합니다. 

![쿠버네티스 Pod - 제타위키](https://z-images.s3.amazonaws.com/thumb/7/76/Module_03_pods.svg/700px-Module_03_pods.svg.png)

자 이제 실제 Pod를 만드는 YAML을 작성해봅시다.

```yaml
apiVersion: v1
kind: Pod
metadata: 
  name: my-nginx-pod
spec:
  containers:
    - name: my-nginx-container
      image: nginx:latest
      ports:
      - containerPort: 80
        protocol: TCP     
```

쿠버네티스의 YAML은 일반적으로 apiVersion, kind, metadata, spec 항목으로 구성됩니다. 

apiVersion
: YAML 파일에서 정의한 오브젝트의 버전을 나타냅니다. 오브젝트의 종류 및 개발 성숙도에 따라 apiVersion 값이 달라질 수 있습니다.

kind
: 오브젝트의 종류를 나타냅니다. 사용할 수 있는 오브젝트 종류는 kubectl api-resources 목록의  KIND 항목으로 확인할 수 있습니다.

metadata
: 라벨, 주석, 이름 등과 같은 리소스의 부가 정보를 입력합니다. 위의 예시에서는 포드의 이름으로 my-nginx-pod를 설정했습니다.

spec
: 리로스를 생성하기 위해 보다 자세한 정보를 입력합니다. 위 예시에서는 실행될 컨테이너 정보를 정의하는 containers항목을 작성한뒤  name 하위 항목에서는 컨테이너의 이름, image에서는 도커 이미지, ports 항목에서는 Nginx 컨테이너가 사용할 80 포트를 지정했습니다.

작성된 YAML 파일은 `kubectl apply -f `명령어로 쿠버네티스에서 생성할 수 있습니다. 


## ReplicaSet

![ReplicaSet](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/replicaset.png)

실제 운영환경에서는 여러 포드를 직접 생성해서 서비스를 하지 않습니다. 동일한 포드의 개수가 많아질 수록 이를 일일이 정의하고 배포하는 것은 매우 비효율적입니다. 특정 포드가 어떠한 이유로든지 삭제되거나, 포드가 위치한 노드에 장애가 발생해 더이상 포드가 접근하지 못하게 되었을때, 직접 포드를 삭제하고 다시 생성하지 않는한 해당 포드는 다시 복구되지 않습니다. 

따라서 쿠버네티스를 사용하면서 포드만 정의해 사용하는 경우는 거의 없습니다. 그리고 이러한 한계를 해결해 주는것은 바로 레플리카 셋입니다. 

레플리카셋은 일정 개수의 포드를 유지하고 실행되도록 관리합니다. 심지어 노드 장애등으로 포드를 사용할 수 없더라도 새로운 포드를 생성하여 실행되도록 합니다. 

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata: 
  name: replicaset-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-nginx-pods-label
  template:
    metadata:
      name: my-nginx-pod
      labels:
        app: my-nginx-pods-label
    spec:
      containers:
    - name: nginx
      image: nginx:latest
      ports:
      - containerPort: 80      
```

spec.replicas
: 동일한 포드를 몇 개 유지시킬지 설정합니다.

spec.template 하위 내용들
: 포드를 생성할때 사용할 템플릿을 설정합니다. 포드를 만들때 사용하던 내용과 동이할게 레플리카 셋에도 적용하여 어떤 포드를 생성할지 명시합니다. 이를 보통 포드 스펙, 포드 템플릿이라고 말합니다.

### 동작원리

레플리카셋을 보면 마치 레플리카 셋이 다수의 포드와 연결된것 처럼 보입니다. 레플리카셋을 생성하면 포드가 생성되고 레플리카 셋을 삭제하면 포드 또한 모두 삭제되기 때문입니다. 그러나 실제론 **레플리카셋은 포드와 연결되어 있지 않습니다**.  오히려 느슨한 연결을 유지하고 있으며, 이런 느슨한 연결은 포드와 레플리카셋의 정의 중 라벨 셀렉터(Label Selector)를 이용해 이루어집니다.

라벨은 포드 등의 쿠버네티스 리로스를 분류할때 유용하게 사용할 수 있는 메타 데이터 입니다. 라벨은 쿠버네티스 리소스의 부가적인 정보를 표현할 수 있을 뿐만 아니라 서로 다른 오브젝트가 서로를 찾아야할때도 사용됩니다. 

예를 들어, 레플리카 셋은 **spec.selector.matchLabel**에 정의된 라벨을 통해서 생성해야할 포드를 찾습니다. 앞서 예제에서는 `app: my-nginx-pods-label` 라벨을 가지는 포드의 개수가 replicas 항목에 정의된 숫자인 3과 일치하지 않으면 포드를 정의하는 포드 템플릿 내용으로 새 포드를 생성하여 유지합니다. 

레플리카셋을 처음 생성했을때는  `app: my-nginx-pods-label`을 가지고 있는 포드가 없기 때문에 3개의 포드를 생성합니다. 만약 `app: my-nginx-pods-label` 라벨을 가지는 포드를 수동으로 미리 생성해 놓는다면 어떻게 될까요? 다행스럽게도 기존 포드를 인식하고 새로운 생성을 하지 않습니다. 하지만 이렇게 직접 레플리카셋과 **동일한 라벨을 가지는 포드를 직접 생성하는 것은 바람직하지 않습니다.** 

> 레플리카셋 VS 레플레케이션 컨트롤러
> 과거 버전의 쿠버네티스는 레플리카셋이 아닌 레플리케이션 컨트롤러란 오브젝트로 포드 갯수를 유지했습니다. 그러나 레플리케이션 컨트롤러은 더 이상 사용되지 않습니다. 두 오브젝트의 차이 중 하나는 레플리카셋인 표현식 기반의 라벨 셀렉터를 사용할 수 있다는 것 입니다.

## Deployment

레플리카셋만으로도 충분히 마이크로서비스 구조의 컨테이너를 구성하고 서비스할 수 있을것 같지만 실제로 쿠버네티스 운영 환경에서 레플리카셋을 YAML 파일에서 사용하는 경우는 거의 없습니다. 대부분은 레플리카셋과 포드의 정보를 정의하는 디플로이먼트를 사용합니다. 

디플로이먼트는 리플리카셋의 상위 오브젝트이기 때문에 디플로이먼트를 생성하면 그에 따른 레플리카셋도 생성됩니다. 따라서 디플로이먼트를 사용하면 포드나 레플리카셋을 생성할 필요가 없습니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: 
  name: my-nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-nginx
  template:
    metadata:
      name: my-nginx-pod
      labels:
        app: my-nginx
    spec:
      containers:
    - name: nginx
      image: nginx:latest
      ports:
      - containerPort: 80      
```
위의 YAML은 사실 레플리카셋의 YAML파일과 비교하여 큰 변경점이 없습니다. 디플로이먼트를 생성하면 my-nginx-delpoyment라는 이름의 오브젝트가 생성되어 있습니다. READY라는 항목에 3/3 출력을 통해 3개의 포드가 정상 동작했다는 것도 알수 있습니다. 

```
kubectl get deployment
kubectl get replicasets
kubectl get pods
```
위 명령어를 치면 하나의 디플로이먼트를 생성했음에도 그에 대응하는 레플리카셋과 포드가 생성된것을 확인할 수 있습니다. 

이런 디플로이먼트를 사용하는 이유는 바로 애플리케이션의 업데이트와 배포의 편의성 때문입니다. 예를 들어, 애플리케이션을 업데이트 할때 레플리카셋의 변경 사항을 저장하는 리비전(Revision) 정보를 남겨두어 롤백이 가능하고, 무중단 서비스를 위해 포드의 롤링 업데이트 전략을 지정할 수도 있습니다. 

**롤링 업데이트**는 포드 인스턴스를 점진적으로 새로운 것으로 업데이트하여 디플로이먼트 업데이트가 서비스 중단 없이 이루어지도록 합니다. 

디플로이먼트 YAML을 작성하고 아래 명령어를 실행해봅시다.
```yaml
kubectl apply -f deployment-nginx.yaml --record
```
그리고 nginx 버전을 변경하기 위해 아래 명령어를 실행합니다. 참고로 kubectl set image 명령어 대신 YAML 파일을 직접 nginx:1.11로 수정하고 apply 명령어를 적용해도 동일합니다.
```yaml
kubectl set image deployment my-nginx-deployment nginx=niginx:1.11 --record
```

수행 후에 레플리카셋 목록을 출력해 보면 동일한 이름의 두개의 레플리카셋이 생성됩니다. 디플로이먼트는 포드의 정보를 업데이트하면서 새로운 레플리카셋과 포드를 생성하면서 이전 버전의 레플리카셋을 삭제하지 않고 남겨두고 있습니다. 즉 **디플로이먼트는 포드의 정보가 변경될때, 이전 정보를 리비전으로써 보존합니다.** 

만약 롤백을 하고 싶다면 `--to-revision`으로 되돌리려는 리버전 번호를 입력하면 됩니다. 

정리하자면, 디플로이먼트는 여러 리플리카셋을 관리하기 위한 상위 오브젝트입니다. 리플리카셋들의 리비전 관리뿐만 아니라 롤링 업데이트 정책을 사용할 수도 있습니다. 따라서 쿠버네티스에서도 공식적으로 디플로이먼트를 사용할 것을 권장하고 있습니다. 

## Service

포드의 IP는 영속적이지 않아서 항상 변할 수 있다는 점을 주의해야 합니다. 여러 디플로이먼트로 하나의 완벽한 서비스로 연동하려면 포드 IP가 아닌 서로를 발견(Discovery)할 수 있는 좋은 방법이 필요합니다. 

디플로이먼트의 YAML의 파일에는 단지 포드의 애플리케이션이 사용할 내부 포트만 정의합니다. containerPort항목이 바로 내부에서 사용할 포트번호 입니다. 내부 포트만 정의해서 이 포드가 바로 외부로 노출되는 것은 아닙니다. 이 포트를 외부로 노출해 사용자들이 접근하거나, 다른 디플로이먼트의 포드들이 내부적으로 접근하려면 서비스라 불리는 별도의 쿠버네티스 오브젝트를 사용해야 합니다. 

서비스는 포드에 접근하기 위한 규칙을 정의하기 때문에 쿠버네티스에 애플리케이션을 배포하기 위해서는 반드시 알아야할 오브젝트입니다. 서비스의 핵심 기능을 나열하자면 다음과 같습니다. 

* 여러 포드에 쉽게 접근하도록 고유한 이름을 부여
* 여러 포드에 접근할때, 요청을 분산하는 로드 밸런서 기능을 수행
* 클라우드 플랫폼의 로드밸런서, 클러스터 노드의 포트 등을 통해 포드를 외부로 노출

### ClusterIP

ClusterIP 타입의 서비스는 쿠버네티스 내부에서만 포드들에 접근할때 사용합니다. 외부로는 포드를 노출하지 않기 때문에 쿠버네티스 내부에서만 사용되는 포드에 적합합니다.

```yaml
apiVersion: v1
kind: Service
metadata: 
  name: hostname-svc-clusterip
spec:
  ports:
    - name: web-port
      port: 8080
      targetPort: 80
  selector:
    app: webserver
  type: ClusterIP
```

spec.selector
: selector 항목은 이 서비스에서 어떠한 라벨을 가지는 포드에 접근이 가능하도록 허가할 것인지 결정합니다. 위 예시에서는 `app: webserver`라는 라벨을 가진 포드들 집합에 접근 가능한 서비스를 생성합니다. 

spec.ports.port
: 생성된 서비스는 쿠버네티스 내부에서만 사용할 수 있는 고유한 ClusterIP를 할당받습니다. port 항목에는 본 서비스 IP에 접근할때 사용할 포트를 정합니다.

spec.ports.targetPort
: selector 항목에서 정의한 라벨에 의해 접근 대상이 된 포드들이 내부적으로 사용하고 있는 포트를 입력합니다. 즉 포드 템플릿에 정의된 containerPort 항목 값과 같은 같으로 설정해야 합니다. 앞서 디플로이먼트 예시에서는 containerPort 포트를 80으로 선언했기 때문에 ports.targetPort 항목을 80으로 설정합니다.

spec.type
: 이 서비스가 어떤 타입인지 나타냅니다. 서비스 종류에 ClusterIP, NodePort, LoadBalaner 등을 설정할 수 있습니다.

위  yaml로 서비스를 생성하면 hostname-svc-clusterip라는 이름의 서비스가 생성됩니다. 이 서비스를 이용해서 포드에 접근하는 방법은 아주 간단합니다. 고유한 CLUSTER-IP의 IP와 PORT 정보로 요청을 보내면 되비다. 이 IP는 쿠버네티스 클러스터 내부에서만 사용하는 IP로, 이 IP를 통해 서비스에 연결된 포드에 접근 가능합니다. 

기본적으로 서비스에 요청을 보내면, **서비스와 연결된 여러 포드에 대해 자동으로 요청이 분산됩니다.** 즉 서비스는 연결된 포드에 대해선 로드 밸런싱을 수행합니다. 

서비스에는 IP 뿐만 아니라 서비스 이름 자체로도 접근가능합니다. 쿠버네티스는 내부적으로 DNS를 구동하고 있으며 포드들은 자동으로 이 DNS를 사용하도록 설정되기 때문입니다. 

실제로 여러 포드가 내부에서 서로를 찾아 연결해야 할때는 **서비스의 이름과 같은 도메인 이름을 사용하는 것이 일반적입니다**. 즉 포드가 서로 상호작용할때 포드 IP를 알 필요가 없으며, 대신 포드와 연결된 서비스를 사용하여 간단히 포드에 접근 가능합니다.

### NodePort

NodePort 타입의 서비스는 클러스터 외부에서도 접근이 가능합니다. 단 NodePort는 모든 노드의 특정 포트를 개방해 서비스에 접근하는 방식입니다. 

```yaml
apiVersion: v1
kind: Service
metadata: 
  name: hostname-svc-nodeport
spec:
  ports:
    - name: web-port
      port: 8080
      targetPort: 80
      # nodePort: 31000
  selector:
    app: webserver
  type: NodePort
```
ClusterIP와 비교했을때 거의 모든 점이 비슷합니다. NodePort는 ClusterIP와 동작 방법이 다른 것일뿐 동일한 서비스 리소스이기 때문에 라벨 셀렉터, 포트 설정등과 같은 기본 항목의 사용법은 동일합니다. 

위 YAML 파일로 NodePort 타입의 서비스를 생성하고 `kubectl get services`를 사용하면 서비스 정보를 볼 수 있습니다. PORT(s) 항목을 보면 8080 포트 뿐만아니라 새로운 포트가 생성된것을 볼 수 있습니다. **이 포트는 모든 노드에서 동일하게 접근할 수 있는 포트입니다.** 즉 클러스터의 모든 노드에서 내부 IP 또는 외부 IP를 통해 해당 포트로 접근하면 서비스를 이용할 수 있습니다. 

각 노드에서 개방되는 포트는 기본적으로 30000~ 32768 포트 중에 랜덤으로 선택되지만, YAML 파일에 nodePort 항목을 정의하면 원하는 포트를 사용할 수도 있습니다. 

사실 NodePort 서비스는 ClusterIP 기능을 포함하고 있습니다. 따라서 NodePort 타입 서비스는 내부 네트워크와 외부 네트워크 양쪽에서 접근이 가능합니다. 

하지만 실제 운영환경에서 NodePort로 서비스를 외부에 제공하는 경우는 많지 않습니다. NodePort에서 포트 번호를 낮은 번호로 설정하기에는 적절하지 않으며 SSL 인증서 적용, 라우팅등과 같은 복잡한 설정을 서비스에 적용하기가 어렵기 때문입니다. 따라서 **NodePort 서비스 그 자체를 외부로 제공하기 보다는 인그레스(Ingress)라고 불리는 쿠버네티스의 오브젝트를 간접적으로 사용하는 경우가 많습니다.**

### LoadBalancer

LoadBalancer 타입 서비스는 서비스 생성과 **동시에 새로운 추가 로드 밸런서를 생성해 포드와 연결합니다.** NodePort를 사용할때는 각 노드의 IP 주소를 알아야 포드에 접근이 가능했습니다. 만약 클라우드 플랫폼을 지원하는 로드밸런서를 사용한다면 도메인 이름과 IP를 클라우드 플랫폼에서 지원 받기 때문에 더욱 쉽게 포드에 접근이 가능합니다. 

일반적으로 AWS, GCP 등과 같은 클라우드 플랫폼 환경에서만 LoadBalancer 타입을 사용할 수 있습니다. 

물론 필요하다면 직접 보유하고 있는 온프레미스 서버에서도 LoadBalancer를 사용할 수 있습니다. 단 쿠버네티스가 이 기능을 직접 지원하는 것은 아니며 MetalLB나 오픈 스택과 같은 특수한 환경을 직접 구축해야 합니다. 

#### externalTrafficPolicy

LoadBalancer 타입을 사용하면 외부로 부터 들어온 요청은 각 노드 중 하나로 보내지며, 그 노드에서 다시 포드 중 하나로 전달됩니다. 그런데 이 포드가 요청이 할당된 노드에 있는 포드가 아닌 외부의 다른 노드에 포드로 전달되어 처리가 될 수도 있습니다. 이렇게 불필요한 네트워크 홉(hob)이 발생할 수 있습니다.


## Volume

저장소와 관련된 오브젝트입니다. 호스트 디렉토리를 그대로 사용할 수도 있고 EBS 같은 스토리지를 동적으로 생성하여 사용할 수도 있습니다. 사실상 인기 있는 대부분의 저장 방식을  [지원](https://kubernetes.io/docs/concepts/storage/#types-of-volumes)합니다.

# Object Spec - YAML

```yaml
apiVersion: v1
kind: Pod
metadata:
    name: example
spec:
    containers:
    - name: busybox
        image: busybox:1.25
```


오브젝트의 명세Spec는 YAML 파일로 정의하고 여기에 오브젝트의 종류와 원하는 상태를 입력합니다. 이러한 명세는 생성, 조회, 삭제로 관리할 수 있기 때문에 REST API로 쉽게 노출할 수 있습니다. 접근 권한 설정도 같은 개념을 적용하여 누가 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있습니다. 

#  Service

쿠버네티스 파드들은 언젠가는 죽게된다. 실제 파드들은  생명주기를 갖습니다. 
워커 노드가 죽으면, 노드 상에서 동작하는 모든 파드들 또한 사라집니다.

레플리카셋(ReplicaSet)은 애플리케이션이 지속적으로 동작할 수 있도록 새로운 파드들의 생성을 통해 동적으로 클러스터를 미리 지정해 둔 상태로 되돌려 줄 수도 있습니다. 

**쿠버네티스의 서비스**는 **어떤 논리적인 파드 셋과 그 파드들에 접근할 수 있는 정책을 정의하는 추상적 개념**입니다. 서비스는 종속적인 파드들 사이를 느슨하게 결합되도록 해줍니다. 서비스는 모든 쿠버네티스 오브젝트들과 같이 YAML 이용하여 정의합니다. 서비스가 대상으로 하는 파드 셋은 보통  LabelSelector_에 의해 결정됩니다. 

비록 각 파드들이 고유의 IP를 갖고 있기는 하지만, 그 IP들은 서비스의 도움없이 클러스터 외부로 노출될 수 없습니다. 서비스들은 여러분의 애플리케이션들에게 트래픽이 실릴 수 있도록 허용합니다. 서비스들은 ServiceSpec에서  `type`을 지정함으로써 다양한 방식들로 노출을 지원합니다.

-   _ClusterIP_  (기본값) - 클러스터 내에서 내부 IP 에 대해 서비스를 노출해준다. 이 방식은 오직 클러스터 내에서만 서비스가 접근될 수 있도록 해준다.
-   _NodePort_  - NAT가 이용되는 클러스터 내에서 각각 선택된 노드들의 동일한 포트에 서비스를 노출시켜준다.  `<NodeIP>:<NodePort>`를 이용하여 클러스터 외부로부터 서비스가 접근할 수 있도록 해준다. ClusterIP의 상위 집합이다.
-   _LoadBalancer_  - (지원 가능한 경우) 기존 클라우드에서 외부용 로드밸런서를 생성하고 서비스에 고정된 공인 IP를 할당해준다. NodePort의 상위 집합이다.
-   _ExternalName_  - 이름으로 CNAME 레코드를 반환함으로써 임의의 이름(스펙에서  `externalName`으로 명시)을 이용하여 서비스를 노출시켜준다. 프록시는 사용되지 않는다. 이 방식은  `kube-dns`  버전 1.7 이상에서 지원 가능하다.

 
# Service & label

![](https://d33wubrfki0l68.cloudfront.net/cc38b0f3c0fd94e66495e3a4198f2096cdecd3d5/ace10/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg)

Pod는 서로 독립적인 IP주소를 가집니다. 그리고 서비스는 다수의 IP주소를 묶어 하나의 논리적인 서비스 IP주소를 만들 수 있습니다. 그리고 하나로 묶인 파드 셋에 걸쳐서 트래픽을 라우팅하게 됩니다.   

![](https://d33wubrfki0l68.cloudfront.net/b964c59cdc1979dd4e1904c25f43745564ef6bee/f3351/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg)
레이블과 셀렉터는 쿠버네티스의 인스턴스들에 대해 논리적인 기본 그룹핑 단위입니다.
레이블은 오브젝트의 생성 시점 또는 이후 시점에 붙여질 수 있고 언제든지 수정이 가능합니다.
레이블은 오브젝트들에 붙여진 키/밸류 쌍으로 다양한 방식으로 이용 가능합니다.
```yaml
#Label Selector 
s:app=A, s:app=B
#Label
app=A, app=B
```

# Service 정의

쿠버네티스의 서비스는 Pod와 같은 쿠버네티스 인스턴스지만 비슷한 REST 오브젝트 처럼 취급되기도 합니다. 다른 REST 오브젝트와 마찬가지로, 서비스 정의를 API 서버에  `POST`하여 새 인스턴스를 생성할 수 있습니다. 

예를 들어, 각각 TCP 포트 9376에서 수신하고  `app=MyApp`  레이블을 가지고 있는 Pod 세트가 있다고 가정합시다.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp # LabelSelector는 app=MyApp 레이블을 가지는 Pod를 대상으로 한다.
  ports:
    - protocol: TCP
      port: 80 # 수신포트
      targetPort: 9376 #타깃포트

```

이 명세는 “my-service”라는 새로운 서비스 오브젝트를 생성하고,  `app=MyApp`  레이블을 가진 Pod의 TCP 9376 포트를 대상으로 합니다.

쿠버네티스는 이 서비스에 서비스 프록시가 사용하는 IP 주소 ("cluster IP")를 할당합니다. 
서비스 셀렉터의 컨트롤러는 셀렉터와 일치하는 Pod를 지속적으로 검색하고, “my-service”라는 엔드포인트 오브젝트에 대한 모든 업데이트를 POST한다.

> 참고로 서비스는  모든 수신  `port`를  `targetPort`에 매핑할 수 있다. 기본적으로 `targetPort`는  `port`  필드와 같은 값으로 설정됩니다.

클라이언트를 수정하지 않은채로, 백엔드 소프트웨어의 다음 버전에서 Pod의 타깃 포트 번호를 변경할 수도 있습니다. 

서비스의 기본 프로토콜은 TCP입니다. 다른  [지원되는 프로토콜](https://kubernetes.io/ko/docs/concepts/services-networking/service/#protocol-support)을 사용할 수도 있습니다.

많은 서비스가 하나 이상의 포트를 노출해야 하기 때문에, 쿠버네티스는 서비스 오브젝트에서 다중 포트 정의를 지원한다. 각 포트는 동일한  `프로토콜`  또는 다른 프로토콜로 정의될 수 있습니다.


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQxMzM5NDQ0OCwyOTQyNDQ0MzYsLTEyOT
U3NjU2NTIsOTg4NjAxMjQ2LDQ5NTAyMzY2NSw0NzMxODM3NTUs
LTY3MzE0NjUzMSw2MTQ1MDUxMiw2MTQ1MDUxMiwxMjE5MTUzND
cwLDE0MjEyNzEyMzIsNzQ3Mjk1MCwtMTk2Mjk5MzIsLTg3MTkx
MjE3MiwtNTc0ODUxMTQsMjExNDYxNDgwOCwtNTI4NzU4NDU4LC
0xMzQ0MjA0OTU1LDE1MzQ5NDE0MiwtNTQ3Nzk0MTg0XX0=
-->