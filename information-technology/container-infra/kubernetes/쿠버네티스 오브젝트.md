# Kubernetes Object

**쿠버네티스는 상태를 관리해야 하는 대상을 오브젝트로 정의합니다.** 기본으로 수십 가지 오브젝트를 제공하고 새로운 오브젝트를 추가하기가 매우 쉽기 때문에 확장성이 좋습니다. 

컨테이너 애플리케이션을 구동하기 위해 반드시 알아야할 몇 가지 중요한 오브젝트가 있습니다. 바로 Pod, 레플리카셋(Replica Set), 서비스(Service), 디플로이먼트(deployment) 입니다. 하나씩 알아봅시다.

##  Pod

포드는 컨테이너를 다루는 가장 기본 단위입니다. 포드는 1개 이상의 컨테이너로 구성된 컨테이너의 집합입니다. 즉 1개의 포드에는 다수의 컨태이너가 존재할 수 있습니다. 

**하나의 포드는 개념적으로 하나의 완전한 애플리케이션입니다.** 만약 한 애플리케이션이 실행되기 위해서 부가적인 기능이 필요하다고 한다면, 포드의 메인 컨테이너를 본연의 애플리케이션으로 삼고 부가적인 기능을 사이드카 컨테이너로 삼을 수 있습니다. 이렇게 포드에 정의된 부가적인 컨테이너를 사이드카라고 하며, 사이드카 컨테이너는 포드 내의 다른 컨테이너와 네트워크 환경 등을 공유하게 됩니다. 때문에 포드에 포함된 컨테이너들을 모두 같은 워커 노드에서 함께 동작합니다. 

![쿠버네티스 Pod - 제타위키](https://z-images.s3.amazonaws.com/thumb/7/76/Module_03_pods.svg/700px-Module_03_pods.svg.png)

자 이제 실제 Pod를 만드는 YAML을 작성해봅시다.

```yaml
apiVersion: v1
kind: Pod
metadata: 
  name: my-nginx-pod
spec:
  containers:
    - name: my-nginx-container
      image: nginx:latest
      ports:
      - containerPort: 80
        protocol: TCP     
```

쿠버네티스의 YAML은 일반적으로 apiVersion, kind, metadata, spec 항목으로 구성됩니다. 

apiVersion
: YAML 파일에서 정의한 오브젝트의 버전을 나타냅니다. 오브젝트의 종류 및 개발 성숙도에 따라 apiVersion 값이 달라질 수 있습니다.

kind
: 오브젝트의 종류를 나타냅니다. 사용할 수 있는 오브젝트 종류는 kubectl api-resources 목록의  KIND 항목으로 확인할 수 있습니다.

metadata
: 라벨, 주석, 이름 등과 같은 리소스의 부가 정보를 입력합니다. 위의 예시에서는 포드의 이름으로 my-nginx-pod를 설정했습니다.

spec
: 리로스를 생성하기 위해 보다 자세한 정보를 입력합니다. 위 예시에서는 실행될 컨테이너 정보를 정의하는 containers항목을 작성한뒤  name 하위 항목에서는 컨테이너의 이름, image에서는 도커 이미지, ports 항목에서는 Nginx 컨테이너가 사용할 80 포트를 지정했습니다.

작성된 YAML 파일은 `kubectl apply -f `명령어로 쿠버네티스에서 생성할 수 있습니다. 


## ReplicaSet

![ReplicaSet](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/replicaset.png)

실제 운영환경에서는 여러 포드를 직접 생성해서 서비스를 하지 않습니다. 동일한 포드의 개수가 많아질 수록 이를 일일이 정의하고 배포하는 것은 매우 비효율적입니다. 특정 포드가 어떠한 이유로든지 삭제되거나, 포드가 위치한 노드에 장애가 발생해 더이상 포드가 접근하지 못하게 되었을때, 직접 포드를 삭제하고 다시 생성하지 않는한 해당 포드는 다시 복구되지 않습니다. 

따라서 쿠버네티스를 사용하면서 포드만 정의해 사용하는 경우는 거의 없습니다. 그리고 이러한 한계를 해결해 주는것은 바로 레플리카 셋입니다. 

레플리카셋은 일정 개수의 포드를 유지하고 실행되도록 관리합니다. 심지어 노드 장애등으로 포드를 사용할 수 없더라도 새로운 포드를 생성하여 실행되도록 합니다. 

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata: 
  name: replicaset-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-nginx-pods-label
  template:
    metadata:
      name: my-nginx-pod
      labels:
        app: my-nginx-pods-label
    spec:
      containers:
    - name: nginx
      image: nginx:latest
      ports:
      - containerPort: 80      
```

spec.replicas
: 동일한 포드를 몇 개 유지시킬지 설정합니다.

spec.template 하위 내용들
: 포드를 생성할때 사용할 템플릿을 설정합니다. 포드를 만들때 사용하던 내용과 동이할게 레플리카 셋에도 적용하여 어떤 포드를 생성할지 명시합니다. 이를 보통 포드 스펙, 포드 템플릿이라고 말합니다.

### 동작원리

레플리카셋을 보면 마치 레플리카 셋이 다수의 포드와 연결된것 처럼 보입니다. 레플리카셋을 생성하면 포드가 생성되고 레플리카 셋을 삭제하면 포드 또한 모두 삭제되기 때문입니다. 그러나 실제론 **레플리카셋은 포드와 연결되어 있지 않습니다**.  오히려 느슨한 연결을 유지하고 있으며, 이런 느슨한 연결은 포드와 레플리카셋의 정의 중 라벨 셀렉터(Label Selector)를 이용해 이루어집니다.

라벨은 포드 등의 쿠버네티스 리로스를 분류할때 유용하게 사용할 수 있는 메타 데이터 입니다. 라벨은 쿠버네티스 리소스의 부가적인 정보를 표현할 수 있을 뿐만 아니라 서로 다른 오브젝트가 서로를 찾아야할때도 사용됩니다. 

예를 들어, 레플리카 셋은 **spec.selector.matchLabel**에 정의된 라벨을 통해서 생성해야할 포드를 찾습니다. 앞서 예제에서는 `app: my-nginx-pods-label` 라벨을 가지는 포드의 개수가 replicas 항목에 정의된 숫자인 3과 일치하지 않으면 포드를 정의하는 포드 템플릿 내용으로 새 포드를 생성하여 유지합니다. 

레플리카셋을 처음 생성했을때는  `app: my-nginx-pods-label`을 가지고 있는 포드가 없기 때문에 3개의 포드를 생성합니다. 만약 `app: my-nginx-pods-label` 라벨을 가지는 포드를 수동으로 미리 생성해 놓는다면 어떻게 될까요? 다행스럽게도 기존 포드를 인식하고 새로운 생성을 하지 않습니다. 하지만 이렇게 직접 레플리카셋과 **동일한 라벨을 가지는 포드를 직접 생성하는 것은 바람직하지 않습니다.** 

> 레플리카셋 VS 레플레케이션 컨트롤러
> 과거 버전의 쿠버네티스는 레플리카셋이 아닌 레플리케이션 컨트롤러란 오브젝트로 포드 갯수를 유지했습니다. 그러나 레플리케이션 컨트롤러은 더 이상 사용되지 않습니다. 두 오브젝트의 차이 중 하나는 레플리카셋인 표현식 기반의 라벨 셀렉터를 사용할 수 있다는 것 입니다.

## Deployment

레플리카셋만으로도 충분히 마이크로서비스 구조의 컨테이너를 구성하고 서비스할 수 있을것 같지만 실제로 쿠버네티스 운영 환경에서 레플리카셋을 YAML 파일에서 사용하는 경우는 거의 없습니다. 대부분은 레플리카셋과 포드의 정보를 정의하는 디플로이먼트를 사용합니다. 

디플로이먼트는 리플리카셋의 상위 오브젝트이기 때문에 디플로이먼트를 생성하면 그에 따른 레플리카셋도 생성됩니다. 따라서 디플로이먼트를 사용하면 포드나 레플리카셋을 생성할 필요가 없습니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: 
  name: my-nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-nginx
  template:
    metadata:
      name: my-nginx-pod
      labels:
        app: my-nginx
    spec:
      containers:
    - name: nginx
      image: nginx:latest
      ports:
      - containerPort: 80      
```
위의 YAML은 사실 레플리카셋의 YAML파일과 비교하여 큰 변경점이 없습니다. 디플로이먼트를 생성하면 my-nginx-delpoyment라는 이름의 오브젝트가 생성되어 있습니다. READY라는 항목에 3/3 출력을 통해 3개의 포드가 정상 동작했다는 것도 알수 있습니다. 

```
kubectl get deployment
kubectl get replicasets
kubectl get pods
```
위 명령어를 치면 하나의 디플로이먼트를 생성했음에도 그에 대응하는 레플리카셋과 포드가 생성된것을 확인할 수 있습니다. 

이런 디플로이먼트를 사용하는 이유는 바로 애플리케이션의 업데이트와 배포의 편의성 때문입니다. 예를 들어, 애플리케이션을 업데이트 할때 레플리카셋의 변경 사항을 저장하는 리비전(Revision) 정보를 남겨두어 롤백이 가능하고, 무중단 서비스를 위해 포드의 롤링 업데이트 전략을 지정할 수도 있습니다. 

**롤링 업데이트**는 포드 인스턴스를 점진적으로 새로운 것으로 업데이트하여 디플로이먼트 업데이트가 서비스 중단 없이 이루어지도록 합니다. 

디플로이먼트 YAML을 작성하고 아래 명령어를 실행해봅시다.
```yaml
kubectl apply -f deployment-nginx.yaml --record
```
그리고 nginx 버전을 변경하기 위해 아래 명령어를 실행합니다. 참고로 kubectl set image 명령어 대신 YAML 파일을 직접 nginx:1.11로 수정하고 apply 명령어를 적용해도 동일합니다.
```yaml
kubectl set image deployment my-nginx-deployment nginx=niginx:1.11 --record
```

수행 후에 레플리카셋 목록을 출력해 보면 동일한 이름의 두개의 레플리카셋이 생성됩니다. 디플로이먼트는 포드의 정보를 업데이트하면서 새로운 레플리카셋과 포드를 생성하면서 이전 버전의 레플리카셋을 삭제하지 않고 남겨두고 있습니다. 즉 **디플로이먼트는 포드의 정보가 변경될때, 이전 정보를 리비전으로써 보존합니다.** 

만약 롤백을 하고 싶다면 `--to-revision`으로 되돌리려는 리버전 번호를 입력하면 됩니다. 

정리하자면, 디플로이먼트는 여러 리플리카셋을 관리하기 위한 상위 오브젝트입니다. 리플리카셋들의 리비전 관리뿐만 아니라 롤링 업데이트 정책을 사용할 수도 있습니다. 따라서 쿠버네티스에서도 공식적으로 디플로이먼트를 사용할 것을 권장하고 있습니다. 

## Service

포드의 IP는 영속적이지 않아서 항상 변할 수 있다는 점을 주의해야 합니다. 여러 디플로이먼트로 하나의 완벽한 서비스로 연동하려면 포드 IP가 아닌 서로를 발견(Discovery)할 수 있는 좋은 방법이 필요합니다. 

디플로이먼트의 YAML의 파일에는 단지 포드의 애플리케이션이 사용할 내부 포트만 정의합니다. containerPort항목이 바로 내부에서 사용할 포트번호 입니다. 내부 포트만 정의해서 이 포드가 바로 외부로 노출되는 것은 아닙니다. 이 포트를 외부로 노출해 사용자들이 접근하거나, 다른 디플로이먼트의 포드들이 내부적으로 접근하려면 서비스라 불리는 별도의 쿠버네티스 오브젝트를 사용해야 합니다. 

서비스는 포드에 접근하기 위한 규칙을 정의하기 때문에 쿠버네티스에 애플리케이션을 배포하기 위해서는 반드시 알아야할 오브젝트입니다. 서비스의 핵심 기능을 나열하자면 다음과 같습니다. 

* 여러 포드에 쉽게 접근하도록 고유한 이름을 부여
* 여러 포드에 접근할때, 요청을 분산하는 로드 밸런서 기능을 수행
* 클라우드 플랫폼의 로드밸런서, 클러스터 노드의 포트 등을 통해 포드를 외부로 노출

### ClusterIP

ClusterIP 타입의 서비스는 쿠버네티스 내부에서만 포드들에 접근할때 사용합니다. 외부로는 포드를 노출하지 않기 때문에 쿠버네티스 내부에서만 사용되는 포드에 적합합니다.

```yaml
apiVersion: v1
kind: Service
metadata: 
  name: hostname-svc-clusterip
spec:
  ports:
    - name: web-port
      port: 8080
      targetPort: 80
  selector:
    app: webserver
  type: ClusterIP
```

spec.selector
: selector 항목은 이 서비스에서 어떠한 라벨을 가지는 포드에 접근이 가능하도록 허가할 것인지 결정합니다. 위 예시에서는 `app: webserver`라는 라벨을 가진 포드들 집합에 접근 가능한 서비스를 생성합니다. 

spec.ports.port
: 생성된 서비스는 쿠버네티스 내부에서만 사용할 수 있는 고유한 ClusterIP를 할당받습니다. port 항목에는 본 서비스 IP에 접근할때 사용할 포트를 정합니다.

spec.ports.targetPort
: selector 항목에서 정의한 라벨에 의해 접근 대상이 된 포드들이 내부적으로 사용하고 있는 포트를 입력합니다. 즉 포드 템플릿에 정의된 containerPort 항목 값과 같은 같으로 설정해야 합니다. 앞서 디플로이먼트 예시에서는 containerPort 포트를 80으로 선언했기 때문에 ports.targetPort 항목을 80으로 설정합니다.

spec.type
: 이 서비스가 어떤 타입인지 나타냅니다. 서비스 종류에 ClusterIP, NodePort, LoadBalaner 등을 설정할 수 있습니다.

위  yaml로 서비스를 생성하면 hostname-svc-clusterip라는 이름의 서비스가 생성됩니다. 이 서비스를 이용해서 포드에 접근하는 방법은 아주 간단합니다. 고유한 CLUSTER-IP의 IP와 PORT 정보로 요청을 보내면 되비다. 이 IP는 쿠버네티스 클러스터 내부에서만 사용하는 IP로, 이 IP를 통해 서비스에 연결된 포드에 접근 가능합니다. 

기본적으로 서비스에 요청을 보내면, **서비스와 연결된 여러 포드에 대해 자동으로 요청이 분산됩니다.** 즉 서비스는 연결된 포드에 대해선 로드 밸런싱을 수행합니다. 

서비스에는 IP 뿐만 아니라 서비스 이름 자체로도 접근가능합니다. 쿠버네티스는 내부적으로 DNS를 구동하고 있으며 포드들은 자동으로 이 DNS를 사용하도록 설정되기 때문입니다. 

실제로 여러 포드가 내부에서 서로를 찾아 연결해야 할때는 **서비스의 이름과 같은 도메인 이름을 사용하는 것이 일반적입니다**. 즉 포드가 서로 상호작용할때 포드 IP를 알 필요가 없으며, 대신 포드와 연결된 서비스를 사용하여 간단히 포드에 접근 가능합니다.

### NodePort

NodePort 타입의 서비스는 클러스터 외부에서도 접근이 가능합니다. 단 NodePort는 모든 노드의 특정 포트를 개방해 서비스에 접근하는 방식입니다. 

```yaml
apiVersion: v1
kind: Service
metadata: 
  name: hostname-svc-nodeport
spec:
  ports:
    - name: web-port
      port: 8080
      targetPort: 80
      # nodePort: 31000
  selector:
    app: webserver
  type: NodePort
```
ClusterIP와 비교했을때 거의 모든 점이 비슷합니다. NodePort는 ClusterIP와 동작 방법이 다른 것일뿐 동일한 서비스 리소스이기 때문에 라벨 셀렉터, 포트 설정등과 같은 기본 항목의 사용법은 동일합니다. 

위 YAML 파일로 NodePort 타입의 서비스를 생성하고 `kubectl get services`를 사용하면 서비스 정보를 볼 수 있습니다. PORT(s) 항목을 보면 8080 포트 뿐만아니라 새로운 포트가 생성된것을 볼 수 있습니다. **이 포트는 모든 노드에서 동일하게 접근할 수 있는 포트입니다.** 즉 클러스터의 모든 노드에서 내부 IP 또는 외부 IP를 통해 해당 포트로 접근하면 서비스를 이용할 수 있습니다. 

각 노드에서 개방되는 포트는 기본적으로 30000~ 32768 포트 중에 랜덤으로 선택되지만, YAML 파일에 nodePort 항목을 정의하면 원하는 포트를 사용할 수도 있습니다. 

사실 NodePort 서비스는 ClusterIP 기능을 포함하고 있습니다. 따라서 NodePort 타입 서비스는 내부 네트워크와 외부 네트워크 양쪽에서 접근이 가능합니다. 

하지만 실제 운영환경에서 NodePort로 서비스를 외부에 제공하는 경우는 많지 않습니다. NodePort에서 포트 번호를 낮은 번호로 설정하기에는 적절하지 않으며 SSL 인증서 적용, 라우팅등과 같은 복잡한 설정을 서비스에 적용하기가 어렵기 때문입니다. 따라서 **NodePort 서비스 그 자체를 외부로 제공하기 보다는 인그레스(Ingress)라고 불리는 쿠버네티스의 오브젝트를 간접적으로 사용하는 경우가 많습니다.**

### LoadBalancer

LoadBalancer 타입 서비스는 서비스 생성과 **동시에 새로운 추가 로드 밸런서를 생성해 포드와 연결합니다.** NodePort를 사용할때는 각 노드의 IP 주소를 알아야 포드에 접근이 가능했습니다. 만약 클라우드 플랫폼을 지원하는 로드밸런서를 사용한다면 도메인 이름과 IP를 클라우드 플랫폼에서 지원 받기 때문에 더욱 쉽게 포드에 접근이 가능합니다. 

일반적으로 AWS, GCP 등과 같은 클라우드 플랫폼 환경에서만 LoadBalancer 타입을 사용할 수 있습니다. 

물론 필요하다면 직접 보유하고 있는 온프레미스 서버에서도 LoadBalancer를 사용할 수 있습니다. 단 쿠버네티스가 이 기능을 직접 지원하는 것은 아니며 MetalLB나 오픈 스택과 같은 특수한 환경을 직접 구축해야 합니다. 

#### externalTrafficPolicy

LoadBalancer 타입을 사용하면 외부로 부터 들어온 요청은 각 노드 중 하나로 보내지며, 그 노드에서 다시 포드 중 하나로 전달됩니다. 그런데 이 포드가 요청이 할당된 노드에 있는 포드가 아닌 외부의 다른 노드에 포드로 전달되어 처리가 될 수도 있습니다. 이렇게 불필요한 네트워크 홉(hob)이 발생할 수 있습니다.

요청 전달 메커니즘은 서비스 속성 중에 externalTrafficPolicy에 정의되어 있습니다. `kubectl get -o yaml`을 보면 Cluster로 설정되어 있습니다.

Cluster는 기본적으로 NodePort와 LoadBalancer가 사용하는 방식입니다. 이를 Local로 설정하면 요청 전달시 **노드가 생성한 포드로만 전달이 가능합니다. ** 로컬 노드에 위차한 포드 중 하나로만 요청이 전달됩니다. 즉 추가적인 네트워크 홉이 발생하지 않습니다.

```yaml
apiVersion: v1
kind: Service
metadata: 
  name: hostname-svc-lb-local
spec:
  externalTrafficPolicy: Local
  ports:
    - name: web-port
      port: 80
      targetPort: 80
      # nodePort: 31000
  selector:
    app: webserver
  type: LoadBalancer
```

그렇지만 externalTrafficPolicy를 Local로 설정하는 것이 무조건 좋은 것은 아닙니다. 각 노드에 포드가 고르지 않게 스케줄링이 되어 있다면, 요청이 고르게 분산되지 않을 수도 있기 때문입니다. 

두개의 노드 A,B 가 존재하고 A에 두개의 포드, B에 한개의 포드가 스케쥴링 된 상태라면 노드에서 밸런싱이 잘 되어도 실제 포드가 받는 부하의 양은 동일하지 않습니다.  즉 특정 노드의 포드에 부하가 집중되거나 적어질수도 있으며, 이는 곧 자원 활용률(utilization)측면에서 바람직하지 않을 수도 있습니다. 

Cluster와 Local 모두 장단점이 있기 때문에 뚜렷한 정답은 없습니다. **불필요한 네트워크 홉으로 인한 레이턴시가 중요치 않다면 Cluster를 써도 괜찮습니다. 아니라면 Local을 사용하는게 좋을 수도 있습니다.**

### ExternalName

보통은 앞서 본 ClusterIP, NodePort, LoadBalancer 세 가지만 알아도 충분하지만, 쿠버네티스를 외부 시스템과 연동할때는 ExternalName 타입의 서비스를 사용할수도 있습니다. ExternalName 을 사용하면 **서비스가 외부 도메인을 가리키도록 설정할 수 있습니다.** 

```yaml
apiVersion: v1
kind: Service
metadata: 
  name: externalname-svc
spec:
  type: ExternalName
  externalName: my.database.com
```

예를 들어, 코버네티스의 포드들이 externalname-svc라는 이름으로 요청을 보내는 경우,  쿠버네티스의 DNS는 my.databse.com으로 접근하도록 CNAME 레코드를 반환합니다. 즉 externalname-svc로 요청을 보내면 my.database.com에 접근하게 도비니다. ExternalName 서비스는 코버네티스와 별개로 존재하는 레거시 시스템에 연동해야 하는 상황에서 유용하게 사용할 수 있습니다. CNAME 레코드는 Canonical Name의 줄임말로, 도메인을 가리키는 다른 이름입니다. 


## Volume

저장소와 관련된 오브젝트입니다. 호스트 디렉토리를 그대로 사용할 수도 있고 EBS 같은 스토리지를 동적으로 생성하여 사용할 수도 있습니다. 사실상 인기 있는 대부분의 저장 방식을  [지원](https://kubernetes.io/docs/concepts/storage/#types-of-volumes)합니다.

 
# Service & label

![](https://d33wubrfki0l68.cloudfront.net/cc38b0f3c0fd94e66495e3a4198f2096cdecd3d5/ace10/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg)

Pod는 서로 독립적인 IP주소를 가집니다. 그리고 서비스는 다수의 IP주소를 묶어 하나의 논리적인 서비스 IP주소를 만들 수 있습니다. 그리고 하나로 묶인 파드 셋에 걸쳐서 트래픽을 라우팅하게 됩니다.   

![](https://d33wubrfki0l68.cloudfront.net/b964c59cdc1979dd4e1904c25f43745564ef6bee/f3351/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg)
레이블과 셀렉터는 쿠버네티스의 인스턴스들에 대해 논리적인 기본 그룹핑 단위입니다.
레이블은 오브젝트의 생성 시점 또는 이후 시점에 붙여질 수 있고 언제든지 수정이 가능합니다.
레이블은 오브젝트들에 붙여진 키/밸류 쌍으로 다양한 방식으로 이용 가능합니다.
```yaml
#Label Selector 
s:app=A, s:app=B
#Label
app=A, app=B

## Ingress 설정

Ingress는 입구라는 의미입니다. 다양한 웹 애플리케이션을 하나의 로드 밸런서로 서비스하기 위해 Ingress를 사용합니다. 웹 애플리케이션을 배포하는 과정을 보면 외부에서 직접 접근할 수 없도록 애플리케이션을 내부망에 설치하고 외부에서 접근이 가능한  `ALB`나  `Nginx`,  `Apache`를 프록시 서버로 활용합니다. 프록시 서버는 도메인과 Path 조건에 따라 등록된 서버로 요청을 전달하는데 서버가 바뀌거나 IP가 변경되면 매번 설정을 수정해줘야 합니다. 쿠버네티스의 Ingress는 이를 자동화하면서 기존 프록시 서버에서 사용하는 설정을 거의 그대로 사용할 수 있습니다. 새로운 도메인을 추가하거나 업로드 용량을 제한하기 위해 일일이 프록시 서버에 접속하여 설정할 필요가 없습니다.

하나의 클러스터에 여러 개의 Ingress 설정을 할 수 있어 관리자 접속용 Ingress와 일반 접속용 Ingress를 따로 관리할 수 있습니다.


## 클라우드 지원

![Cloud](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/cloud-company.png)

쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능AutoScaling이 있고 IP를 할당받아 로드밸런스LoadBalancer로 사용할 수 있습니다. 외부 스토리지를 컨테이너 내부 디렉토리에 마운트하여 사용하는 것도 일반적인데 이를 위해 클라우드 별로 적절한 API를 사용하는 모듈이 필요합니다. 쿠버네티스는 Cloud Controller를 이용하여 클라우드 연동을 손쉽게 확장할 수 있습니다. AWS, 구글 클라우드, 마이크로소프트 애저는 물론 수십 개의 클라우드 업체에서 모듈을 제공하여 관리자는 동일한 설정 파일을 서로 다른 클라우드에서 동일하게 사용할 수 있습니다.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTkwNTEzMjI0NywxMTAxNzg2MjAwLDE1MT
g4NDYzNzIsLTQ3MDMwMzkxNCwyOTQyNDQ0MzYsLTEyOTU3NjU2
NTIsOTg4NjAxMjQ2LDQ5NTAyMzY2NSw0NzMxODM3NTUsLTY3Mz
E0NjUzMSw2MTQ1MDUxMiw2MTQ1MDUxMiwxMjE5MTUzNDcwLDE0
MjEyNzEyMzIsNzQ3Mjk1MCwtMTk2Mjk5MzIsLTg3MTkxMjE3Mi
wtNTc0ODUxMTQsMjExNDYxNDgwOCwtNTI4NzU4NDU4XX0=
-->