# 쿠버네티스 기본 개념

## 쿠버네티스의 특징

* 모든 리소스는 오브젝트 형태로 관리됩니다.
	* 대부분 리소스를 오브젝트라 불리는 형태로 관리합니다. 
	* 컨테이너의 집합(pods), 컨테이너의 집합을 관리하는 컨트롤러 (Replica Set), 사용자(Service Account), 노드(Node) 까지도 하나의 보르젝트로 사용할 수 있습니다.
* 쿠버네티스는 명령어로도 사용할 수 있지만, YAML파일을 선호합니다.
	*  YAML 파일의 용도는 컨테이너 뿐만 아니라 거의 모든 리소스 오브젝트들에 사용될 수 있습니다. 예를 들어, 컨테이너의 설정값(ConfigMap), 비밀 값(Secrets)등도 모두 YAML 파일로 정의합니다.
	* 실제 서비스 배포에도 kubectl 명령어가 아닌 여러 YAML 파일을 정의해 쿠버네티스에 적용하는 방식으로 동작합니다. 따라서 쿠버네티스를 잘 사용하는 방법을 YAML 파일을 잘 작성하는 것과 거의 같습니다.

## DesiredState

![Desired state](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/desired-state.png)

쿠버네티스에서 가장 중요한 것은  **desired state - 원하는 상태**  라는 개념입니다. 원하는 상태라 함은 관리자가 바라는 환경을 의미하고 좀 더 구체적으로는 얼마나 많은 웹서버가 떠 있으면 좋은지, 몇 번 포트로 서비스하기를 원하는지 등을 말합니다.

 쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 알아야 합니다.

쿠버네티스는 복잡하고 다양한 작업을 하지만 자세히 들여다보면  **현재 상태current state**를 모니터링하면서 관리자가 설정한  **원하는 상태**를 유지하려고 내부적으로 이런저런 작업을 하는 단순한(?) 로직을 가지고 있습니다.

이러한 개념 때문에 관리자가 서버를 배포할 때 직접적인 동작을 명령하지 않고 상태를 선언하는 방식을 사용합니다. 

예를 들어 “nginx 컨테이너를 실행해줘. 그리고 80 포트로 오픈해줘.”는 현재 상태를 원하는 상태로 바꾸기 위한  **명령imperative**입니다. 
“80 포트를 오픈한 nginx 컨테이너를 1개 유지해줘”는 원하는 상태를  **선언declarative**  한 것입니다.  

```
$ docker run # 명령
$ kubectl create # 상태 생성
```

# Kubernetes Object

**쿠버네티스는 상태를 관리해야 하는 대상을 오브젝트로 정의합니다.** 기본으로 수십 가지 오브젝트를 제공하고 새로운 오브젝트를 추가하기가 매우 쉽기 때문에 확장성이 좋습니다. 

컨테이너 애플리케이션을 구동하기 위해 반드시 알아야할 몇 가지 중요한 오브젝트가 있습니다. 바로 Pod, 레플리카셋(Replica Set), 서비스(Service), 디플로이먼트(deployment) 입니다. 하나씩 알아봅시다.

##  Pod

컨테이너를 다루는 기본 단위입니다. Pod는 쿠버네티스에서 배포할 수 있는 가장 작은 단위로 한 개 이상의 컨테이너와 스토리지, 네트워크 속성을 가집니다. 같은 Pod에 속한 컨테이너는 스토리지와 네트워크를 공유하고 서로 localhost로 접근할 수 있습니다. 

Pod는 컨테이너 애플리케이션을 배포하기 위한 기본 단위로 사용됩니다. 

![Pod](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/pod.png)

컨테이너를 하나만 사용하는 경우도 반드시 Pod으로 감싸서 관리합니다.

## ReplicaSet

![ReplicaSet](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/replicaset.png)

Pod을 여러 개(한 개 이상) 복제하여 관리하는 오브젝트입니다. Pod을 생성하고 개수를 유지하려면 반드시 ReplicaSet을 사용해야 합니다. ReplicaSet은 복제할 개수, 개수를 체크할 라벨 선택자, 생성할 Pod의 설정값(템플릿)등을 가지고 있습니다. 직접적으로 ReplicaSet을 사용하기보다는 Deployment등 다른 오브젝트에 의해서 사용되는 경우가 많습니다.

## Service
네트워크와 관련된 오브젝트입니다. Pod을 외부 네트워크와 연결해주고 여러 개의 Pod을 바라보는 내부 로드 밸런서를 생성할 때 사용합니다. 내부 DNS에 서비스 이름을 도메인으로 등록하기 때문에 서비스 디스커버리 역할도 합니다.

## Volume

저장소와 관련된 오브젝트입니다. 호스트 디렉토리를 그대로 사용할 수도 있고 EBS 같은 스토리지를 동적으로 생성하여 사용할 수도 있습니다. 사실상 인기 있는 대부분의 저장 방식을  [지원](https://kubernetes.io/docs/concepts/storage/#types-of-volumes)합니다.

# Object Spec - YAML

```yaml
apiVersion: v1
kind: Pod
metadata:
    name: example
spec:
    containers:
    - name: busybox
        image: busybox:1.25
```


오브젝트의 명세Spec는 YAML 파일로 정의하고 여기에 오브젝트의 종류와 원하는 상태를 입력합니다. 이러한 명세는 생성, 조회, 삭제로 관리할 수 있기 때문에 REST API로 쉽게 노출할 수 있습니다. 접근 권한 설정도 같은 개념을 적용하여 누가 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있습니다.

## 쿠버네티스 배포방식

쿠버네티스는 애플리케이션을 배포하기 위해 원하는 상태(desired state)를 정의(yaml)하고  오브젝트(object)에 라벨Label을 붙이는 방식으로  API 서버에 전달하는 방식을 사용합니다.

“컨테이너를 2개 배포하고 80 포트로 오픈해줘”라는 간단한 작업을 위해 다음과 같은 구체적인 명령을 전달해야 합니다.

> “컨테이너를 Pod으로 감싸고 type=app, app=web이라는 라벨을 달아줘. type=app, app=web이라는 라벨이 달린 Pod이 2개 있는지 체크하고 없으면 Deployment Spec에 정의된 템플릿을 참고해서 Pod을 생성해줘. 그리고 해당 라벨을 가진 Pod을 바라보는 가상의 서비스 IP를 만들고 외부의 80 포트를 방금 만든 서비스 IP랑 연결해줘.”


음.. “정말 뭐 하나 배포할 때마다 저렇게 복잡하게 설정한다고?”라는 의구심이 들 수 있지만 이건 모두 사실입니다. Cloud code, Helm, Knative를 사용하면 조금 편해지긴 하지만 기본적으로 너무 복잡하고 러닝 커브가 높은 편입니다.


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQ5Njg4MTgxNiwxNzkxMDIzMDU1XX0=
-->