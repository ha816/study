# Introduction

모든 애플리케이션은 최소한 하나의 스레드는 가지고 있어야 한다. 
직접 스레드를 만들 수 도 있는데 새로운 스레드를 만들때 마다 코드는 해당 스레드에서 즉시 실행된다. 

새로운 스레드를 생성할때는 새로운 Thread객체를 생성해야 한다. 이 객체는 Runnable 인터페이스의 객체를 전달받는다. 또한 Runnable 인터페이스는 public void run()이란 메세드가 있는데, **스레드를 실행할때 이 run()메서드를 직접 호출하면 안된다.** 

Thead 객체의 start메서드를 호출한 후에는 run 멧더를 호출해서 JVM에서 코드를 실행하는데 필요한 새로운 스레드를 생성한다. 

Thread 클래스는 병렬 실행이 가능한 스레드를 만들 수 있도록 JVM을 호출한다는 점이 특별하다. start 메서드를 소스 코드에서 확인할 수 있다면 네이티브 메서드인 start0으로 호출하는 private 메서드 역시 확인할 수 있다.Thread 수행 순서를 결정하는 것은 전적으로  JVM이다. 

## Executor Framework

동시성 프레임워크(Executor Framework)는 자바 4에서 도입되었고 **메모리 측면에서의 효율성 있는 동시성을 위한 여러 클래스**들을 제공한다. 

스레드를 생성하는 과정에서는 메모리의 자원을 많이 소비하게 되는데, Executor 인터페이스는 스레드를 미리 생성하고, 그 수를 제한하며, 사용된 스레드를 재사용함으로써 자원을 효율성을 높인다. 

자바에서 Thread 생성은 시스템 자원이 많이 드는 연산이므로 운영체제는 애플리케이션에서 실행되는 스레드 갯수를 제한하게 된다. Thread pool을 이용함으로써 새로운 스레드를 이용하기 보다는 재사용을 하게 된다. 

자바 동시성 프레임워크는 일반적인 경우에 사용하는 스레드 풀을 제공하며 이를 확장해서 쓸수 있다. 
동시성 프레임 워크에서 제공하는 Excutor 인터페이스는 execute(Runnable)를 정의한다. 

Excutors 클래스의 생성된 풀을 이용하면 Exectuor 객체 대신에 ExcutorService 객체를 반환한다. ExcutorService 객체는 Excutor 객체와는 달리 코드 실행을 중단시킬 수 있는 기능이 있다.
 
동시성 코드가 짜기 어려운 이유는 쓰레드가 동시 다발적으로 실행되기 때문이다. 하나의 공유 자원에 대해서 다른 쓰레드가 자원의 상태를 읽거나 수정을 하는 동안에는 해당 상태가 변경되지 않도록 공유를 잠궈둬야 한다. 

모든 자바 객체는 스스로 락을 유지할 수 있는 능력이 있다. 따라서 synchronized(object) 코드를 감싸서 한번에 스레드 하나만 코드 블록 안에서 실행 할수 있도록 한다. 물론 이런 락에는 성능이 느려진다. 스레드는 잠겨 있는 동안 다른 작업을 기다려야 함으로 성능이 떨어진다. 그러므로 읽고 쓸 필요가 없으면 최대한 빨리 락을 해제하는 것이 좋다.

-   쓰레드 풀 사용(무거운 쓰레드는 미리 할당 가능)
-   태스크와 쓰레드를 생성하고 관리하는 것을 분리
	- 태스크(task == Runnable 한 구현체)
-   쓰레드 풀안의 쓰레드는 한번에 하나씩 여러 태스크를 실행
-   태스크 큐를 이용한 태스크 관리
-   Executor Service를 더이상 필요 없으면 중지
-   Executor Service가 멈추면 모든 쓰레드도 중지

### ExecutorService

![enter image description here](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http://cfile7.uf.tistory.com/image/250ED44B58D7697A25088A)

Customer라는건 Application에서 해당 ExecutorService를 사용하는 요청자이고 submit을 하게 되면, ExecutorService 내부에서 해당 작업을 내부적으로 스케쥴링 하면서 적절하게 일을 처리한다. 
ExecutorService의 submit 메서드 호출시 파라미터로 task를 넘기면 ExcecutorService의 TaskQueue에서 해당 task를 관리하게 된다. 
Task Queue에 들어온 task는 Thread Pool에서 하나의 스레드가 맡아 처리한다.
작업 처리가 끝난 스레드는 Task Queue큐에서 새로운 task를 가져와 처리한다.
  
submit 메서드를 보면 아래와 같은데 **Task의 종류는 Runnable과 Callable 두 가지 종류가 있다는 것을 알 수 있다.** 
```
public Future<?> submit(Runnable task) {...}
public <T> Future<T> submit(Callable<T> task) {...}
```
Runnable의 run 메서드는 return값이 없다. Callable의 call 메서드는 return값이 존재한다. 따라서 Callable은 해당 작업의 결과를 반환할 수 있고, Future Object를 반환한다. Future Object는 task의 상태와 task가 끝이 났는지, 취소되었는지 확인하는 메서드를 제공하고, 작업을 취소하거나 결과를 복구할 수 있다. 

### Executors

Executor Service 인스턴스를 생성하는 Factory 클래스

```
public static ExecutorService newFixedThreadPool(int nThreads);
public static ExecutorService newCachedThreadPool();
public static ExecutorService newSingleThreadExecutor();
public static ExecutorService newSingleThreadScheduledExecutor();
```
예제
```
ExecutorService execService = Executors.newFixedThreadPool(2); 
execService.execute(new MyThreadTask());
execService.execute(new MyThreadTask());
execService.shutdown();
```

### Atomic 클래스

자바 동시성 프레임 워크에는 모든 기본 타입을 Wrapping하는 Atomic 클래스가 있다. 이 클래스들은 모든 원자 연산을 보장한다. 즉 다른 쓰레드는 **모두 메서드 호출이 완료될때까지 이 클래스의 참조가 수정되지 않는다.** 즉 Atomic한 클래스의 객체는 메서드가 값을 읽고 쓰는 동안 변경되지 않는 것을 보장해주기 때문에 synchronized 메서드가 불필요 하다. 

>왜 불변 객체를 써야하는가? 

불변객체는 값이 변하지 않기 때문에 스레드에서 락을 사용하지 않아도 된다. 이는 동기화된 코드 블록 사이에서 값 하나를 이용할 수 있을때까지 대기하는 시간을 아낄 수 있다는 말이다.  불변 객체의 값을 수정해야할 경우 수정된 새로운 객체를 만들어야 한다. 





> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY0OTQ0MDgxMSwtNTgzMjcwOTEwLDE0OD
Y2MTMyNSwtMzY2MzMwNzAzLC0xNDU2ODM3OTk0LC04NTk5NjEy
MzAsNTU5OTI5MTEzLDEzMzg5NTM0NDBdfQ==
-->