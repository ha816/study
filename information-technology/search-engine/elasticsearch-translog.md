# Overview

엘라스틱 서치는 분산 시스템이 지원해야 하는 고가용성(High Availability)을 제공하기 위해 내부적으로 Translog라는 특수한 형태의 파이르 유지하고 관리하고 있다. 장애 복구를 위한 백업 데이터 및 데이터 유실 방지를 위한 저장소로써 Translog를 적극 활용하고 있다. 

# Translog의 동작순서

샤드에 어떤 변경 사항이 생길경우 Translog 파일에 먼저 해당 내역을 기록한 후 내부에 존재하는 루씬 인덱스로 데이터를 전달한다. 루씬으로 전달된 데이터는 인메모리 버포로 저장되고 주기적으로 처리되어 결과적으로 세그먼트가 된다. 

엘라스틱서치에서 기본적으로 1초에 한번씩 Refresh 작업이 수행되는데, 이를 통해 추가된 세그먼트의 내용을 읽을 수 있게 되고 검색에 사용된다. 하지만 Refresh 작업이 일어나더라도 Translog 파일에 기록된 내용은 삭제되지 않고 계속 유지된다. 이처럼 **Translog는 일어나는 모든 변경사항을 담고 있는 특수한 형태의 로그이다.** 이러한 특성을 이용해서 엘라스틱 서치는 Translog의 내역을 바탕으로 장애 발생 시 복구 작업을 수행할 수 있다. 

하지만 Translog 파일에 계쏙 로그가 누적될 수 는 없다. 특정 시점이 되면 불필요한 과거 로그는 삭제된다. 그렇다면 언제 Translog의 내용이 삭제 될까?

엘라스틱 서치에서 제공하는 Flush는 내부적으로 fsync()함수로 물리적인 디스크에 변경 내역을 기록한다. 이 작업은 운영체제 입장에서는 많은 리소스가 필요한 무거운 작업이기 때문에 정책적으로 실행 시간을 조정할 수 있고 기본적으로 5초에 한번 수행된다. 

Flush 작업 성공적으로 마무리되고 디스크 동기화에 성공하면 누적되어 있던 Translog 파일의 내용이 비로소 삭제 된다. Flush가 일어난다는 것은 디스크에 물리적으로 기록된다는 것이고 이는 영구적으로 보관된다는 것을 의미하기에 이 시점까지의 로그는 더 이상 필요치 않게 된다. 결과적으로 Translog 내부 로그는 의미가 없어지고 이 시점에 Flush 이전 정보는 모두 삭제 된다. 

동작 순서 정리
1. 데이터가 추가되면 Translog에 기록되고 동시에 인메모리 버퍼에 추가된다.
2. Refresh가 수행되면 인메모리 버퍼에서는 사라지지만 Translog에는 계속 남아있다.
3. Translog가 일정 크기 이상으로 커지면 Flush작업이 수행된다.
4. Commit Point가 디스크에 Flush된다.
5. 시스템 캐시의 내용이 디스크에 Flush된다.
6. TransLog 기록이 삭제된다.

# Translog의 존재 이유

가장 큰 목적은 장애 복구를 위해서다. 엘라스틱서치는 실시간에 가까운 검색을 제공하기 위해 1초마다 Refresh 작업을 수행하지만 이는 불안정한 상태라고 할 수 있다. (Refresh는 물리적인 디스크로 동기화를 하지 않은 상태다) 
장애 발생시 완벽한 복구를 위해서는 물리적인 디스크로 동기화 하는 Flush가 언젠가는 이루어 져야만 한다. 하지만 Flush는 매우 무거운 작업이다. 

다음과 같은 장애 현상을 한번 생각해보자.

>Flush에 의해 루씬 Commit 작업이 시작됬고 완료 되지 못한 상황에서 샤드에 장애가 발생
>이 경우 상대적으로 쉽게 해결이 가능한데, 샤드가 강제 종료되면 진행 중이던 루씬 Commit 작업이 롤백되기 때문에 샤드가 재실행되고 나면 Translog의 로그 내역으로 간단히 복구가 가능하다. 
>Translog의 내역을 바탕으로 순차적으로 인메모리 버퍼를 복구하고 Refresh가 수행되면 다음 Flush시점에 루씬 Commit이 수행된다.

>변경사항이 순간적으로 많아져서 루씬의 Commit이 긴시간 일어나게 되었고 그 동안 많은 데이터 변경 요청이 한꺼번에 샤드로 들어온다면?
>이 경우는 상황이 다소 복잡하다. 루씬 Commit 작업이 수행되는 시간이 길어진다고 해서 Commit이 일어나는 동안 샤드로 전달된 변경사항이 Commit 작업이 끝날때까지 반영 되지 않는 다면 실시간 검색을 지원한다는 의미가 많이 퇴색될 것이다. 그래서 Commit이 일어나는 동안에 들어온 변경사항은 루씬의 인메모리 버퍼로 전다하지 않고 Translog에 임시 저장해두고 다음 Commit 반영될때까지 유지한다.
>샤드는 이런 특별한 상황에 대한 임시 저장소로 Translog가 사용된다는 것을 이미 알고 있기 때문에 세그먼트 검색을 수행하기 전에 Translog에 임시로 저장한 변경 사항이 없는지 먼저 확인하게 된다. 이러한 매커니즘을 이용하면 루씬 Commit작업이 아무리 긴 시간 일어나더라도 변경사항에 대한 데이터 유실 없이 서비스를 안정적으로 유지할 수 있다. 

Translog의 주목적은 클러스터를 운여하는 중에 데이터가 손실되지 않도록 보장하는 것이다. Translog 파일을 일종의 임시 보관소로도 사용할 수 있기 때문에 루씬에 문제가 발생하더라도 데이터의 유실 없이 서비스가 가능해진다. 

운영 중에 샤드에 크래시가 발생할 경우에도 Translog를 사용한다. Translog를 이용하면 샤드를 완벽히 복구할 수 있기 때문이다. **직전 루씬 Commit 작업 이후의 모든 내역이 Translog에 고스란히 기록되어 있기 때문에 다시 한번 재실행하면 샤드를 완벽하게 복구하는 것이 가능해 진다.**

하지만 Translog의 크기가 커질 수록 장애 발생시 복구하는데 걸리는 시간도 그에 비례해서 커진다. 복구를 위해선 루씬 Commit 이후 모든 내역을 재실행에서 세그먼트를 재생성하는 과정이 필요하기 때문이다. Translog 파일이 크다는 것은 복구를 위해 재생성해야할 세그먼트가 많다진다는 것ㅇ

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjQ0MDI0MDA2LDIzMzcwMTYyLC01MzU1Mj
E2NTEsMTgxNDI4OTEzMywxNjc0NTA3NDI4LDE1MTE1MDg4NzRd
fQ==
-->