# Overview

엘라스틱 서치는 분산 시스템이 지원해야 하는 고가용성(High Availability)을 제공하기 위해 내부적으로 Translog라는 특수한 형태의 파이르 유지하고 관리하고 있다. 장애 복구를 위한 백업 데이터 및 데이터 유실 방지를 위한 저장소로써 Translog를 적극 활용하고 있다. 

# Translog의 동작순서

샤드에 어떤 변경 사항이 생길경우 Translog 파일에 먼저 해당 내역을 기록한 후 내부에 존재하는 루씬 인덱스로 데이터를 전달한다. 루씬으로 전달된 데이터는 인메모리 버포로 저장되고 주기적으로 처리되어 결과적으로 세그먼트가 된다. 

엘라스틱서치에서 기본적으로 1초에 한번씩 Refresh 작업이 수행되는데, 이를 통해 추가된 세그먼트의 내용을 읽을 수 있게 되고 검색에 사용된다. 하지만 Refresh 작업이 일어나더라도 Translog 파일에 기록된 내용은 삭제되지 않고 계속 유지된다. 이처럼 **Translog는 일어나는 모든 변경사항을 담고 있는 특수한 형태의 로그이다.** 이러한 특성을 이용해서 엘라스틱 서치는 Translog의 내역을 바탕으로 장애 발생 시 복구 작업을 수행할 수 있다. 

하지만 Translog 파일에 계쏙 로그가 누적될 수 는 없다. 특정 시점이 되면 불필요한 과거 로그는 삭제된다. 그렇다면 언제 Translog의 내용이 삭제 될까?

엘라스틱 서치에서 제공하는 Flush는 내부적으로 fsync()함수로 물리적인 디스크에 변경 내역을 기록한다. 이 작업은 운영체제 입장에서는 많은 리소스가 필요한 무거운 작업이기 때문에 정책적으로 실행 시간을 조정할 수 있고 기본적으로 5초에 한번 수행된다. 

Flush 작업 성공적으로 마무리되고 디스크 동기화에 성공하면 누적되어 있던 Translog 파일의 내용이 비로소 삭제 된다. Flush가 일어난다는 것은 디스크에 물리적으로 기록된다는 것이고 이는 영구적으로 보관된다는 것을 의미하기에 이 시점까지의 로그는 더 이상 필요치 않게 된다. 결과적으로 Translog 내부 로그는 의미가 없어지고 이 시점에 Flush 이전 정보는 모두 삭제 된다. 

동작 순서 정리
1. 데이터가 추가되면 Translog에 기록되고 동시에 인메모리 버퍼에 추가된다.
2. Refresh가 수행되면 인메모리 버퍼에서는 사라지지만 Translog에는 계속 남아있다.
3. Translog가 일정 크기 이상으로 커지면 Flush작업이 수행된다.
4. Commit Point가 디스크에 Flush된다.
5. 시스템 캐시의 내용이 디스크에 Flush된다.
6. TransLog 기록이 삭제된다.

# Translog의 존재 이유

가장 큰 목적은 장애 복구를 위해서다. 엘라스틱서치는 실시간에 가까운 검색을 제공하기 위해 1초마다 Refresh 작업을 수행하지만 이는 불안정한 상태라고 할 수 있다. (Refresh는 물리적인 디스크로 동기화를 하지 않은 상태다) 
장애 발생시 완벽한 복구를 위해서는 물리적인 디스크로 동기화 하는 Flush가 언젠가는 이루어 져야만 한다. 하지만 Flush는 매우 무거운 작업이다. 

다음과 같은 장애 현상을 한번 생각해보자.

>Flush에 의해 루씬 Commit 작업이 시작됬고 완료 되지 못한 상황에서 샤드에 장애가 발생
>이 경우 상대적으로 쉽게 해결이 가능한데, 샤드가 강제 종료되면 진행 중이던 루씬 Commit 작업이 롤백되기 때문에 샤드가 재실행되고 나면 Translog의 로그 내역으로 간단히 복구가 가능하다. 
>Translog의 내역을 바탕으로 순차적으로 인메모리 버퍼를 복구하고 Refresh가 수행되면 다음 Flush시점에 루씬 Commit이 수행된다.

>변경사항이 순간적으로 많아져서 루씬의 Commit이 긴시간 일어나게 되었고 그 동안 많은 데이터 변경 요청이 한꺼번에 샤드로 들어온다면?
>이 경ㅇ


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjAwOTYwMDQ3NCwtNTM1NTIxNjUxLDE4MT
QyODkxMzMsMTY3NDUwNzQyOCwxNTExNTA4ODc0XX0=
-->