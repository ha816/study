# Overview

일반적으로 개발환경과 운영환경은 하드웨어적으로 큰 차이가 있다. 하드웨어 성능이나 운영체제 설정이 다를 경우 동일한 결과를 보장하지 않기 때문에 개발환경에서 클러스터를 구축하고 얻은 데이터를 운영환경에 그대로 사용해서는 안된다. 개발 완료 후 반드시 운영환경에서 재확인 하는 과정이 필요하다. 

엘라스틱서치는 운영환경이라고 판단되면 실행시 부트 스트랩(Bootstrap)이라는 과정으로 잘못된 설정이나 문제점을 친절히 알려준다. 이를 통해 일반적인 설정 오류는 방지할 수 있다. 하지만 시간이 흘러 데이터가 많아지면 잠재되어 있던 문제가 나타날것이다. 처음 시스템을 구축할때 최적화가 되었더라도 데이터의 종류와 양에 따라 계속 답이 달라질 수 있으므로 주요 포인트들을 주기적으로 확인해야 한다. 

# 노드 부트스트랩 과정의 이해

엘라스틱서치에는 부트스트랩이라는 과정이 있다. 그리고 엘라스틱서치 노드는 최초 실행시 항상 부트스트랩 체크라는 과정을 거친다. 이 과정이 왜 필요하고 그리고 그 과정에서 어떤 일이 일어나는지 알아보자.

## 부트스트랩 과정이 필요한 이유

과거게은 엘라스틱서치 설정 중 일부가 잘못됬거나 필수적인 리소스 할당이 되지 않으면 단순히 경고(Warning) 메세지를 로그에 출력하는 방식을 택했다. 그러다 보니 경험 없는 대다수의 운영자는 잠재되어 있는 문제의 심각성을 인지못하고 그냥 넘어가기가 부지기수 였다. 

그런 이유로 최신 버전에서는 운영시 발생가능한 문제점을 미연에 방지하기 위해 좀 더 강력한 검사를 수행하게 됬고 이러한 과정이 부트스트랩 체크(Bootstrap Checks)라 한다. 

부트스트랩 과정에서 필수 설정이 잘못된 경우, 잘못된 사실을 사용자에게 알리고 정상적으로 수정될때 까지 엘라스틱서치를 강제 종료하여 필수 설정이 완료되어야만 엘라스틱서치가 실행되도록 강제한다. 

사용자는 간단한 테스트를 하고 싶을 뿐인데 가끔 강제적인 부트스트랩 때문에 환경설정에 더 많은 시간을 할애하게 될 경우가 있다. 그래서 엘라스틱서치는 내부적으로 개발모드와 운영모드 두 가지의 개념이 존재한다. 

개발모드(Development Mode)
: 실행시 IP 주소가 루프백으로 설정된 경우, 엘라스틱서치는 개발모드로 실행된다고 판단한다. 개발모드로 실행될 경우, 부트스트랩 체크과정이 무시된다. 개발 모드로 동작하면 로컬에서 동작하기 때문에 다른 노드와 클러스터를 구성할 수 없다. 말 그대로 개발환경에서 테스트 목적으로만 사용할 수 있다.

운영모드(Product Mode)
: 운영모드는 반드시 부트스트랩 체크과정을 필수로 거친다. 그리고 실행시 IP 주소를 할당받기 때문에 당연히 다른 엘라스틱서치 노드와도 클러스터 구성이 가능하다. 클러스터에 존재하는 모든 노드는 항상 부트스트랩 체크 과정을 거치는 것이 좋다.


## 부트스크랩 체크과정 따라가기

1. 힙 크기 체크(Heap size check)
JVM옵션 중 기본 힙 크기와 최대 힙 크기 옵션이 별도로 존재한다. 최소 메모리를 쓰다가 큰 메모리를 쓰게되는데 엘라스틱서치는 스와핑을 최소화하기 위해 전체 힙 메모리에 대해 Memory Lock을 수행한다. 소프트 설정과 하드 설정의 값이 다르면 소프트 과정(기본 힙) 크기만큼만 Memory 대상으로 잡는다. 그러한 이유로 Memory Lock 설정을 하더라도 나증에 늘어난 힙 크기만큼 메모리는 스와핑 대상이 될수도 있다. 이를 위해 이 단계에서는 **JVM의 기본 힙 크기와 최대힙 크기가 같은지 검사한다.**

2. 파일 디스크립터 체크(File descriptor check)
리눅스에선 모든 것이 파일로 처리된다.  일반적인 파일은 물론이고 소켓, 시스템 콜 등 모든 것이 파일로 처리된다. 그렇기 때문에 파일 디스크립터의 수가 매우 중요한 요소다. 특히 엘라스틱서치는 경우, 내부의 루씬이 역색인을 구성하는 정보를 모두 파일로 처리하기 떄문에 더 많은 디스크립터가 필요하다. 이를 위해 **파일 디스크립터가 충분히 존재하는지 검사한다.**

3. 메모리 락 체크(Memory lock check)
JVM 메모리 관리를 위해 주기적으로 GC를 수행한다. 이 과정에서 메모리 확보하기 위해 불필요한 객체를 찾게 되고 이러한 객체를 힙 영역에서 제거함으로써 메모리를 확보한다. 가비지 컬렉션이 수행될 경우 모든 힙 메모리르 검사해야 한다. 하지만 이때 힙을 구성하는 메모리 페이지 조각 중 단 하나라도 디스크에 스왑 아웃 되어 있다면 이를 메모리에 다시 올리는 스왑인 작업을 반드시 해야 한다. 이러한 스왑 in, 스왑 out 작업은 JVM 애플리케이션에 큰 부담을 준다. 엘라스틱서치는 스와핑을 최대한 피하도록 안내하며, 힙에 할당된 메모리는 스와핑 대상이 되지 않도록 Memory Lock을 이용해 잠그도록 안내한다. 이를 위해 이 단계에서는 **엘라스틱서치에 할당된 힙 메모리의 Memory Lock 여부를 검사한다.** 

4. 최대 스레드 수 체크(Maximum number of threads check)
엘라스틱 서치는 대량의 요청을 빠르게 처리하기 위해 내부를 기능별로 나누어 여러 단계의 모듈로 구성되어 있다. 각 모듈은 큐와 쓰레드풀을 가지고 있기 때문에 요청에 대한 처리량(throughput)을 조절하면서 탄력적으로 처리하는 것이 가능하다. 모든 Thread Pool Executor가 여유롭게 스레드를 생성하도록 엘라스틱서치가 최소 4096개 이상의 스레드를 생성하도록 하는게 좋다. 이를 위해 이 단계에선 **애플리케이션이 생성할 수 있는 최대 쓰레드 수를 검사한다.** 

5. 최대 메모리 크기 체크(Maximum size virtual memory check)
내부에 존재하는 루씬은 인덱스 생성 및 관리를 효율적으로 하기 위해 mmap을 이용해 메모리 매핑을 수행한다. mmap을 이용하면 JVM을 통하지 않고도 리눅스 커널로 직접 시스템 콜을 실행할 수 있어 고성능 자바 애플리케이션에서 많이 사용한다. mmap은 커널 레벨의 메모리를 직접 할당받아 애플리케이션의 가상 메모리 주소의 매핑해서 동작하기 때문에 가상 메모리 크기에 제한이 없는것이 유리한다. 엘라스틱서치에서는 mmap를 효율적으로 사용하기 위해 애플리케이션의 가상 메모리 크기를 무제한으로 설정하도록 안내한다. 이를 위해 이 단계에선 리눅스가 생성하는 애플리케이션의 **가상 메모리 크기가 무제한으로 설정되어 있는지 검사한다.** 

6. 최대 파일 크기 체크(Max file size check)
리눅스에서 생성 가능한 파일 크기는 얼마일까? 리눅스에서는 하나의 파일이 가질 수 있는 최대 파일 ㅋ



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE2MTQ5MDQxNywtMTM5MDI3NTAxNywxOT
QzMzczNDk2LDIwODQ2Mzc3MjQsMTY2NTE2MTk1MCwtNDQ4MjAx
OTgyLDQwMDM5MTQ4OCwtNDExNzY5NzY4LC0xNTc3ODA4ODMxXX
0=
-->