# Overview

클러스터는 최대 몇개의 인덱스를 생성할 수 있을까? 하나의 샤드 크기는 얼마가 적당할까? 이런 질문은 엘라스틱서치를 운영하는 사람들에게는 한번쯤 고민해봤을 질문이다. 

시간이 흐를수록 관리되는 데이터는 점점 커진다. 현재 서비스가 원할히 된다고 해서 앞으로 서비스가 잘 될거란 보장은 없다. 분산 시스템의 경우 이론상 데이터가 무한히 증가할 수 있기 때문에 최적화의 필요성이 더욱 더 커진다. 

분산 검색 시스템인 엘라스틱서치를 운영한다는 것은 항상 최적화를 고민해야 한다는 것과 같다. 이번 장에서는 운영하면서 한번쯤 고민해야할 사항을 알아보겠다.

# 운영 중 샤드 개수 수정이 불가한 이유

클러스터에서 운영 중인 인덱스는 원칙적으로 수정이 불가능하다. 인덱스를 생성할때 한번 설정된 샤드의 개수는 절대 변경이 불가능하기 때문에 데이터의 크기가 최대 얼마까지 증가할 것인지 잘 계산해서 최초 인덱스 생성시 샤드의 개수를 신중하게 결정해야 한다. 

샤드에는 두 종류가 존재한다. 첫번째는 실제 서비스가 일어나느 프라이머리 샤드이다. 실질적인 CRUD를 제공하는 샤드로 엘라스틱서치에서 핵심요소이다. 이 프라이머리 샤드를 일반적으로 샤드로 부른다. 두번째는 레플리카 샤드다. 기본적으로 장애 복구를 위해 존재한다. 하지만 프라이머리 샤드와 동일한 데이터를 가지고 있기 때문에 평상시에는 읽기 분산에도 활용된다. 

엘라스틱서치에서는 최초 인덱스를 생성할때 settings 속성을 이용해 샤드와 레플리카 개수를 각각 정의할 수 있다. 

number_of_shards
: 샤드의 개수(number_of_shards)는 전체 데이터를 몇개의 샤드로 나누어 보관할지를 의미한다. 이 값으로 프라이머리 샤드의 개수가 결정된다.

number_of_replicas

: 레플리카 개수(number_of_replicas)는 몇개의 복사본 세트를 만들것인지를 의미한다. 이 속성 값으로 레플리카 샤드 세트의 개수가 결정된다.

한 임의의 인덱스를 생성할때 만약 5개의 샤드와 1개의 레플리카 세트를 만든다고 했고 시간이 흘러 인덱스에 총 1억건의 데이터가 색인 됐다고 가정해보자. 5개의 프라이머리 샤드를 설정했기 때문에 각 샤드는 2천건의 데이터를 가져가게 될것이다. 

이런 상황에서 검색 성능을 향상 시키기 위해 물리적인 장비를 추가 투입해서 샤드 5개를 추가하기로 했다고 하자. 이런 경우 기존 프라이머리 샤드의 개수를 5개에서 10개로 변경하면 모든 문제가 간단히 해결될 것이다. 하지만 엘라스틱서치에서는 한번 생성된 프라이머리 샤드 개수의 변경을 허용치 않는다. 도대체 그 이유는 무엇일까?

엘라스틱 서치 샤드는 루씬 인덱스의 확장이라고 했다. 각 샤드는 내부에 독립적인 루씬 라이브러리를 가지고 있으며, 루씬은 단일 서버에서만 동작하는(Stand Alone) 검색 엔진이다. 

이러한 특성 때문에 샤드 내부의 루씬 입장에서는 함께 인덱스를 구성하는 다른 샤드의 존재를 전혀 눈치채지 못한다. 루씬 입장에서는 엘라스틱 서치를 구성하는 전체 데이터가 별도로 존재하고 자신은 그 중 일부만 가지고 있다는 사실을 알 수가 없는것이다. 오직 자신이 가지고 있는 일부 데이터만을 가지고 색인과 검색이 최대한 효율적으로 이뤄지도록 노력할 뿐이다. 한마디로 정리하자면 **단순히 2천건의 데이터를 가지고 있는 완전히 독립적인 루씬 5개가 존재한다는 것이다.** 

프라이머리 샤드의 개수를 변경한다는 것은 각각 독립적인 루씬이 가지고 있는 데이터들을 모두 재조정한다는 의미와 같다. 만약 루씬의 개수가 5개에서 10개로 늘어난다면 각 루씬이 가지고 있는 세그먼트가 잘게 쪼개져 일부 세그먼트들을 새롭게 추가된 루씬쪽으로 전송되어야 할 것이다. 그리고 새로 추가된 루씬은 여기저기서 전송된 세그먼트 조각들을 모아서 다시 합치는 작업을 수행해야 할 것이다. 세그먼트의 불변성을 위해서 원칙적으로 세그먼트의 변경을 불가능하다. 이러한 이유로 현재는 프라이머리 샤드의 개수를 변경할 방법이 없는것이다. 

엘라스틱 서치에서는 프라이머리 샤드의 개수를 변경하기 위해서는 새로운 인덱스를 생성하고 재색인 하도록 안내한다. 그리고 이를 지원하기 위해 ReIndex API를 제공한다. 

## Reindex API

**현재로서는 샤드 개수를 변경하기 위해 인덱스를 재생성하고 전체 데이터를 처음 부터 재색인하는 방법밖에 없다.** 이를 위해 엘라스틱서치에서는 이미 존재하는 인덱스를 새로운 인덱스로 다시 색인하는 Reindex API를 제공한다. 이를 이용하면 비교적 손쉽게 새로운 인덱스로 재색인할 수 있다. 

```
POST _reindex {
	"source" : { "index": "movie" },
	"dest" : {"index": "new_movie"}
}
```

# 레플리카 샤드 복제본 수는 얼마가 적당할까?

프라이머리 샤드는 처음 설정한 샤드 개수 변경이 불가능하지만 레플리카 샤드의 복제본 수는 운영 중에도 언제든 변경이 가능하다. 레플리카 샤드를 추가하고 싶은 경우 기존 프라이머리 샤드를 복사하기만 하면 되기 때문이다. 

일반적으로 장애가 발생했을때 빠른 복구를 위해 1개 이상의 복사본 세트를 사용하는게 좋다. 레플리카 샤드는 직접 생성할 샤드 개수를 지정할 수 없다. 단지 몇 개의 복사본 세트를 가질지 정할 뿐이다. 이는 레플리카 샤드가 프라이머리 샤드 전체를 복사해야만 그 의미가 있기 때문이다. 


number_of_replicas 값은 레플리카에 사용할 복사본 세트의 개수를 말한다. **실제 생성될 레플리카 샤드의 개수를 말하는게 아니다.** 실제 운영될 레플리카 샤드 개수는 그 인덱스에서 사용하는 프라이머리 샤드의 개수 * 레플리카 세트 개수(number_of_shards * number_of_replicas)이다.

복사본 세트의 수를 지정함으로써 모든 프라이머리 샤드가 복사되기 때문에 클러스터 내부에서 운영하고 있는 전체 샤드 개수를 고려해서 적절한 복사본 세트를 운영해야 한다. 장애 복구나 읽기 성능 향상을 위해 레플리카를 많이 사용하게 되지만 한가지 주의해야 할 점이 있다. 레플리카 세트의 수를 결정할 경우에는 사전에 충분한 테스트가 필요한데, **너무 많은 복사본이 존재하는 경우, 자칫 전체적인 색인 성능의 저하로 이루어질 수 있기 때문이다.** 

레플리카 샤드도 프라이머리 샤드와 마찬가지로 내부에 루씬을 가지고 있다. 엘라스틱 서치에 데이터가 추가되면 마스터 노드에 의해 적절히 라운팅 되어 특정 프라이머리 샤드로 데이터가 전송된다. 해당 샤드 내부에서는 루씬에 의해 새그먼트가 생성되는데, 레플리카도 이와 동일한 검색 결과를 보장해야 하기 때문에, 존재하는 모든 레플리카 샤드에도 데이터가 전송된다. 이처럼 프라이머리 샤드와 레플리카 샤드는 모두 동일한 세그먼트 생성 과정을 거치게 되는 것이다. 이러한 과정때문에 모든 복사본에 일관성이 부여된다. 이 일관성 때문에 레플리카를 이용해 읽기 분산이 가능해 진다. 

레플리카에도 프라이머리와 마찬가지 매커니즘으로 동작하기 때문에 리플리카가 많아질 수록 색인 성능이 비례해서 하락한다. 읽기 분산이 중요한 경우에는 색인 성능을 일부 포기하고 레플리카 세트 수를 늘리는 것이 좋을테고, 빠른 색인이 더 중요한 경우에는 읽기 분산을 일부 포기하고 레플리카 세트 수를 줄이는 것이 좋을 것이다. 

다행히 복사본의 수는 운영 중에 언제라도 변경이 가능하다. 그렇게 때문에 처음에 서비스를 운영할때는 복제본의 수를 최소화해서 운영을 시작하는 것이 좋다. 운영 중에 노드의 장애나 데이터 량에 따른 읽기 분산을 지속적으로 모니터링하고 이를 바탕으로 탄력적으로 북사본의 수를 조절해 나나가는 것을 권장한다. 

# 클러스터에서 운영 가능한 최대 샤드 수는?

**먼저 결론부터 이야기하자면 전체 샤드의 수에 대한 특별한 제한은 없다.** 이론 상 클러스터에는 인덱스가 무한대로 생성될 수 있기 때문이다. 하지만 개별 인덱스를 설정할대 설정 가능한 최대 샤드의 수는 현재 1024개로 제한되어 있다.  


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExOTEwMjUyNjcsODg0MTc0MzI3LC0xNj
YxNzc5NDcsLTMxOTE1MDgxNV19
-->