# Overview

구글이나 네이버에서 제공하는 다양한 서비스는 빼놓을 수 없는 포털 사이트 서비스이다. 이 검색 서비를 부르는 용어도 다양한데, 검색 엔진, 검색 시스템, 검색 서비스 등의 용어가 대표적이다. 

대다수의 독자는 위 세 가지 용어가 비슷하다고 생각할 것이다. 하지만 세 가지 용어는 명백히 다르다. 

검색 엔진(search engine)
: 광활한 웹에서 정보를 수집해 검색 결과를 제공하는 프로그램이다.

검색 시스템(search system)
: 대용량 데이터를 기반으로 신뢰성 있는 검색 결과를 제공하기 위해 검색 엔진을 기반으로 구축된 시스템을 통칭하는 용어이다. 

검색 서비스(search service)
: 검색엔진을 기반으로 구축한 검색 시스템을 활용해 검색 결과를 서비스로 제공한다. 

## 검색 시스템의 구성요소

수집기(collector)
: 수집기는 웹 사이트, 블로그, 카페 등 웹에서 필요로 하는 정보를 수집하는 프로그램이다. 크롤러(crawler), 스파이더(spider), 웜(worms)등으로 불린다. 파일, 데이터베이스, 웹페이지 등 웹상의 대부분의 정보가 수집 대상이다. 

스토리지(storage)
: 데이터베이스에 데이터를 저장하는 물리적 저장소다. 검색 엔진은 색인한 데이터를 스토리지에 보관한다.

색인기(Indexer)
: 검색엔진이 수집한 정보에서 사용자의 질의와 일치하는 정보를 찾으려면 수집된 데이터를 검색가능한 구조로 가공하여 저장해야 한다. 이 역할을 하는 것이 색인기이다. 색인기는 다양한 형태소 분석기를 조합해 정보에서 의미가 있는 용어를 추출하고 검색에 유리한 역색인 구조로 데이터를 저장한다. 

검색기(searhcer)
: 사용자의 질의를 입력받아 색인기에서 저장한 역색인 구조에서 일치하는 문서를 찾아 반환한다. 질의와 문서가 일치하는 지를 유사도 기반의 검색 순위 알고리즘으로 판단한다. 검색기 또한 색인기와 마찬가지로 형태소 분석기를 이용해 사용자 질의에서 유의미한 용어를 추출해 검색한다. 따라서 사용하는 형태소 분석기에 따라 검색 품질이 달라진다. 

## 관계형 데이터베이스와 차이점

검색 엔진을 설명할때 항상 비교되는 것이 관계형 데이터베이스(RDBMS)이다. 두 가지 모두 질의와 일치하는 데이터를 찾아 사용자에게 제공한다는 점에서 유사점이 많다. 하지만 관계형 데이터 베이스만의 검색 기능으로는 한계가 있다.

RDBMS에서는 모든 데이터는 중복을 제거하고 정형의 데이터로 구조화해서 행과 열로 구성된 테이블로 저장된다. SQL문을 이용한 정보 검색은 텍스트 매칭을 통한 단순한 검색만이 가능하다. 텍스트를 여러 단어로 변형하거나 여러 개의 동의어나 유의어를 활용한 검색을 불가능하다. 

반면에 검색엔진은 데이터베이스에서는 불가능한 비정형 데이터를 색인하고 검색할 수 있다. 형태소 분석을 통해 사람이 구사하는 자연어의 처리가 가능해지고 역색인 구조를 바탕으로 빠른 검색 속도를 보장한다. 

| 엘라스틱서치| 관계형 데이터베이스|
|--|--|
|인덱스(Index)  |  데이터베이스(Database)|
|샤드(Shard)  |  파티션(Partition)|
|타입(Type)  |  테이블(Table)|
|문서(Document)|  행(Row)|
|필드(Field)| 열(Col)|
|매핑(Mapping)| 스키마(Schema)|
|Query DSL| SQL|

위 차트는 엘라스틱 서치와 관계형 데이터베이스의 주요 개념을 배교해서 보여준다. 엘라스틱 서치에서 타입은 테이블과 같은 역할을 한다. 
하나의 행을 문서라고 부르며, 해당 문서는 데이터베이스의 테이블에서 한 행을 말한다. 

## 검색 시스템과 엘라스틱서치

대량의 데이터를 빠르게 검색하기 위해 고안된 NoSQL(No Structured Query Language)를 많이 사용한다. 엘라스틱 서치도 NoSQL의 일종으로 분산 처리를 통해 실시간에 준하는 빠른 검색이 가능하다. 기존 데이터 베이스에서는 처리하기 어려운 비정형의 데이터도 검색할 수 있으며, 전문 검색과 구조 검색 모두를 지원한다. 기본적으로 검색 엔진이지만 MongoDB나 Hbase처럼 대용량 스토리지로도 활용할 수 있다. 

엘라스틱 서치의 장점은 아래와 같다.

* 오프소스 검색엔진
	* 아파치 재단의 루씬(Lucene)을 기반으로 개발된 오픈소스 검색엔진이다. 
* 전문 검색
	* 단순 텍스트 검색 기능뿐만 아니라 좀 더 고차원적인 전문 검색이 가능하다. 전문 검색이란 내용 전체를 색인해서 특정 단어가 포함된 문서를 검색하는 것을 말한다. 
* 통계 분석
	* 비정형 로그 데이터를 수집하고 한곳에 모아 통계 분석한다. 엘라스틱 서치와 키바나(Kibana)를 연결하면 실시간으로 쌓이는 로그를 시각화하고 분석할 수 있다.
* Document-Oriented
	* 여러 계층의 데이터를 JSON형식의 구조화된 문서로 인덱스에 저장할 수 있다. 계층 구조로 문서도 한번의 쿼리로 조회할 수 있다.
* 역색인(Inverted Index)
	* 엘라스틱 서치는 루씬 기반의 검색엔진이다. 따라서 엘라스틱서치 또한 역색인을 지원한다. 바면 MongoDB나 카산트라(Casandra)같은 일반적인 NoSQL은 역색인을 지원하지 않는다. 이는 다른 NoSQL 대비 엘라스틱서치의 매우 큰 장점이다. 

엘라스틱 서치의 단점은 아래와 같다.

* 실시간이 아니다. 일반적으로 색인된 데이터는 통상적으로 1초 뒤에나 검색이 가능하다. 색인된 데이터는 내부적으로 커밋과 플러시 같은 복잡한 과정을 거치기 때문에 실시간이 아니다. 엄밀히 말하면 실시간(Near Realtime)이라 할 수 있다.
* 트랜잭션과 롤백 기능을 제공하지 않는다. 엘라스틱 서치는 기본적으로 분산 시스템으로 구성된다. 전체적인 클러스터의 성능을 위해 비용 소모가 큰 롤백(Rollback)과 트랜잭션을 지원하지 않기 때문에 최악의 경우 데이터 손실의 위험이 있다. 
* 데이터의 업데이트를 제공하지 않는다. 엄밀히 말하면 업데이트 명령이 요청될 경우 기존 문서를 삭제하고 새로운 내용으로 문서를 생성하는 방식을 사용한다. 따라서 단순 업데이트에 비해서는 많은 비용이 발생한다. 

## 키바나(Kibana)

키바나는 엘라스틱에서 제공하는 데이터 시각화 프로그램이다. 당장은 시각화 기능이 필요하진 않지만 키바나를 이용하면 색인된 데이터를 검색하거나 문서를 추가하거나 삭제하는 등의 기능을 손쉽게 구현할 수 있다. 사실 키바나에서 제공하는 UI가 매우 유용하다. 

# 엘라스틱 서치 코어

엘라스틱 서치가 기본적으로 분산 시스템을 지향하다보니 생소한 용어가 많다. 용어가 무엇인지 잘 파악하면 전체 아키텍처를 이해하는데 많은 도움이 된다. 엘라스틱 서치를 구성하는 주요 구성요소로 어떤 것이 있는지 알아보자.

## 기본 용어

### 인덱스, 색인

인덱스(색인)는 실제 데이터 저장 공간이다. 색인은 다소 비슷한 특성을 가진 문서들의 모임으로도 이해할 수 있다. 이를테면 고객 데이터에 대한 색인, 제품 카탈로그에 대한 색인, 주문 데이터에 대한 색인을 각각 둘 수 있다. 인덱스의 이름은 반드시 모두 소문자여야 하며 추가, 수정, 삭제, 검색은 RESTful API로 수행할 수 있다. 만약 인덱스가 없는 상태에서 데이터가 추가된다면 데이터를 이용해 인덱스가 자동 생성된다. 

하나의 인덱스는 하나의 타입만 가지며 하나의 물리적인 노드에 여러 개의 논리적인 인덱스를 생성할 수 있다. 검색 시 인덱스 이름으로 문서 데이터를 검색하며, 여러 개의 인덱스를 동시에 검색하는 것도 가능하다. 

엘라스틱 서치를 분산환경으로 구성하면 하나의 인덱스가 여러 노드에 분산 저장되어 관리된다. 엘라스틱 서치는 인덱스 생성시 기본적으로 5개의 프라이머리 샤드와 1개의 레플리카 샤드 세트를 생성한다. 각 샤드 수는 인덱스를 생성할때 옵션으로 변경할 수 있다. 

### 샤드

색인된 문서는 하나의 인덱스에 담긴다. 인덱스 내부에 색인된 데이터는 물리적인 공간에 여러 개의 파티션으로 나뉘어 구성되는데, 이 파티션을 엘라스틱 서치에서는 샤드(Shard)라 부른다. 엘라스틱 서치는 다수의 샤드로 문서를 분산 저장하고 있어 데이터 손실 위험을 최소화 할 수 있다. 

### 타입
타입은 인덱스의 논리적 구조를 말한다. 엘라스틱 서치 6.0이하 버전에서는 하나의 인덱스에 여러 타입을 설정이 가능했지만 6.1버전부터는 인덱스당 하나의 타입만 사용할 수 있다. 

### 문서
문서(Document)는 엘라스틱 서치에서 데이터가 저장되는 최소단위이다. 기본적으로 JSON 포맷으로 데이터가 저장된다. 문서는 데이터베이스와 비교하자면 테이블의 행을 의미한다. 
하나의 문서는 다수의 필두로 구성되어 있는데 각 필드는 데이터의 형태에 따라 용도에 맞는 데이터 타입(DataType)을 정의해야 한다. 또한 문서는 중첩 구조를 지원하기 때문에 이로 문서안에 문서를 지정하는 것도 가능하다. 

### 필드

필드(Field)는 문서를 구성하기 위한 속성이다. 일반적으로 데이터베이스의 컬럼과 비교할 수 있으니 컬럼이 정적인 데이터 타입인데 반해 필드는 좀 더 동적인 타입이다. 

하나의 필드는 목적에 따라 다수의 데이터 타입을 가질 수 있다. 영화 정보를 담아둔 문서에 제목 필드가 있다고 생각해보자. 영화 제목을 검색할때 매칭 검색을 하거나 초성을 이용한 검색이 모두 지원되도록 하려면 제목 필드는 2개의 데이터 타입을 가져야 한다. 

### 매핑
매핑은 문서의 필드와 필드 속성을 정의하고 그에 따른 색인 방법을 정의하는 프로세스다. 인덱스의 매핑 정보에는 여러가지 데이터 타입을 지정할 수 있지만 필드명은 중복해서 사용할 수 없다.

## 클러스터(Cluster)

 클러스터는 여러 노드(서버)의 집합으로 구성되며, 그림에서는 하나의 클러스터만 가정했지만, 여러 개의 클러스터를 구성할 수도 있으며, 이럴때는 클러스터의 이름으로 클러스터를 구분한다. 이 이름은 중요한데, 어떤 노드가 어느 클러스터에 포함되기 되는지를 이름으로 판별하기 때문이다. 

![enter image description here](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https://t1.daumcdn.net/cfile/tistory/99AB08425C9F17D928)

참고로 한 shard가 replication을 쓰는 경우, primary와 replica shard는  같은 노드에 존재할 수 없다. 

## 노드(Node)

노드는 클러스터에 포함된 단일 서버로서 데이터를 저장하고 클러스터의 색인화 및 검색 기능에 참여한다. 노드는 클러스터처럼 이름으로 식별되는데, 기본 이름은 시작 시 노드에 지정되는 임의 UUID(Universally Unique IDentifier)이다. 원한다면 기본 이름 대신 어떤 노드 이름도 정의할 수 있다. 이 이름은 관리의 목적에서 중요한데 네트워크의 어떤 서버가 Elasticsearch 클러스터의 어떤 노드에 해당하는지 식별해야 하기 때문이다.

노드 별로 분산 처리를 위해선 다양한 형태의 노드를 조합해서 클러스터를 구성해야 한다. 기본적으로 마스터 노드가 노드 추가, 삭제와 같은 전체적인 클러스터를 관리하고 데이터 노드는 데이터 검색, 색인등을 수행한다. 설정에 따라 4가지 유형의 노드가 존재한다. 

### 마스터 노드(Master Node)

마스터 노드는 노드 추가와 제거 같은 클러스터 수준의 전반적인 작업을 대표해서 처리한다. 따라서 네트워크 속도가 빠르고 지연이 없는 노드를 마스터 노드로 선정해야 한다. 다수의 노드를 마스터 노드로 설정할 수 있지만 결과적으로 하나의 노드만이 마스터 노드로 선출되어 동작한다. 

### 데이터 노드(Data Node)

데이터 노드는 문서가 실제 저장되는 노드다. 데이터가 분산 저장되는 물리적 공간인 샤드가 배치되는 노드이기도 하다. 색인 작업은 CPU, 메모리, 스토리지 같은 컴퓨팅 리로스를 많이 소모하기 때문에 리소스 모니터링이 필요하다. 

데이터 노드는 가능한 한 마스터 노드와 분리해서 구성하는 게 좋다. 단 색인할 문서가 적으면 함께 구성해도 상관은 없다. 

### 인제스트 노드(Ingest Node)
색인에 앞서 데이터 전처리를 위한 노드다. 데이터의 포맷을 변경하기 위해 스크립트로 전처리 파이프라인을 구성하고 실행할 수 있다. 

### 코디네이팅 노드(Coordinating Node)

마스터 노드, 데이터 노드, 인제스트 노드의 역할을 하지 않고 단순히 들어온 요청을 라운드 로빈 방식으로 분산시켜주는 노드다. 


# 엘라스틱서치 주요 API

 엘라스틱 서치는 RESTful 방식의 API를 제공하며, JSON 기반으로 통신한다. 기본적으로 HTTP 통신을 위해 9200번 포트를 사용한다. 

문서를 색인하기 위해서는 기본적으로 인덱스가 존재 해야 한다. 인덱스를 통해 입력되는 문서의 필드를 정의하고 각 필드에 알맞은 데이터 타입을 지정할 수 있다. 

>index vs indices 용어정리
>index: 색인 데이터
>indices: 매핑 정보를 저장하는 논리적인 데이터 공간

사실 엘라스틱 서치는 사용 편의성을 위해서 스키마리스(Schemaless)라는 기능을 제공한다. 문서를 색인하기 위해서는 기본적으로 필요한 인덱스 생성 과정 없이 문서를 추가해도 문서가 색인 되도록 지원하는 일종의 편의 기능이다. 

하지만 스키마리스는 가급적 사용하지 않도록 하자. 왜냐하면 스키마리스 사용은 성능과 밀접한 연관이 있기 때문에 특수한 상황에서만 사용해야 한다. 

## 인덱스 관리 API

인덱스 관리 API는 말 그대로 인덱스 관리를 위해 사용되는 API이다. 대표적으로는 인덱스 추가 및 삭제가 가능하다. 

### 인덱스 생성

```
--생성하려는 movie 인덱스
PUT /movie {
	"settings": {
		"number_of_shards": 3,
		"number_of_replicas": 2,
	},
	"mappings": {
		"_doc": {
			"properties" : {
				"movieCd": {"type":"integer"},
				"movieNm": {"type":"text"},
				"openDt": {"type":"date"},
				"typeNm": {"type":"keyword"},
				...
			}
		}
	}
}
```

인덱스 생성시에는 매핑이라는 세부 설정을 이용할 수 있는데, 매핑은 문서와 문서에 포함된 필드, 필드 타입 등을 세세하게 지정하는 것이 가능한 설정 방법이다. 인덱스 생성시 이러한 매핑 정보를 추가할 수 있다. 

**주의할 점은 한번 생성된 매핑 정보를 변경할 수 없다.** 만약 잘못 생성했거나 변경해야하는 경우에는 데이터를 삭제하고 다시 색인하는 수 밖에 없다. 

### 인덱스 삭제

인덱스 삭제의 경우도 주의할 점이 있다. 바로 인덱스를 삭제하면 다시는 복구할 수 없기 때문이다. 인덱스 삭제는 신중하게 하자.

##  문서 관리 API

문서 관리 API는 실제 문서를 색인하고 조회, 수정, 삭제를 지원하는 API다. 이를 이용해서 문서를 색인하고 내용을 수정하거나 삭제 할 수 있다. 엘라스틱 서치는 기본적으로 검색엔진이기 때문에 다양한 검색 패턴을 지원하는 Search API를 별도로 제공한다. 하지만 색인된 문서의 ID를 기준으로 문서를 다뤄야 할 경우는 문서 관리 API를 사용한다. 

문서 관리 API는 다음과 같은 세부 기능을 제공한다. 
* Index API
	* 한 건의 문서를 색인한다. 
* Get API
	* 한 건의 문서를 조회한다.
* Delete API
	* 한 건의 문서를 삭제한다.
* Update 
	* 한 건의 문서를 업데이트한다.

문서 관리 API는 기본적으로 한 건의 문서를 처리하기 위한 기능을 제공하며 Single document API라고도 부른다. 하지만 클러스터를 운영하다보면 다수의 문서를 처리해야 하는 경우도 종종 발생할 것이다. 이런 경우 Multi-document API도 제공한다. 

* Bulk API
	* 한 건의 문서를 색인한다. 
* Multi Get API
	* 한 건의 문서를 조회한다.
* So on...


## 검색 API

엘라스틱 검색 API의 사용방식은 크게 두 가지 방식이 있다. 

1. HTTP URI 형태의 파라미터를 URI에 추가해 검색하는 방법
2. RESTful API방식인 QueryDSL을 사용해 요청 본문(Request Body)에 질의 내용을 추가해 검색하는 법

Request Body 방식(2)은 URI 방식(1)보다 제약 사항이 적기 때문에 현업에서는 Request Body식을 선호한다. Uri 방식은 간단한 검색을 하거나 디버깅할 때 간편하게 사용하는 경우에 종종 사용된다. 

간단한 표현식이라면 두 가지 형식을 섞어서 사용하는 것도 가능하다. 예를 들어, Query를 URI 방식으로 사용하고 나머지 기능을 JSON 형태로 사용해도 된다. 

### URI 방식의 검색 질의

먼저 살펴볼 URI 방식의 검색 질의는 문서 ID인 _id값을 사용해 문서를 조회하는 방식이다. 결국 URL에 파라미터를 붙여 조회하는 식이다. 예컨데 123이라는 키를 가진 문서를 질의하려면 GET 메서드를 사용해 다음과 같이 검색할 수 있다. 

```
GET /movie/_doc/123?pretty=true
```

### Request Body 방식의 검색 질의

URI 검색 질의는 여러 필드를 각기 다른 검색어로 질의하는 것이 어렵다. 쿼리의 조건이 복잡하고 길어지기 때문이다. 이럴 때는 JSON 방식으로 질의하는게 좋다. JSON  포맷을 이용해 RESTful방식으로 질의하면 매우 복잡한 질의도 쉽게 표현할 수 있고 여러 조건을 한번에 처리할 수 있다. 사용법은 간단하다. 앞서 만든 URI 파리미터를 JSON 포맷으로 옮기기만 하면 된다.

```
POST /{index 명}/_search {
	JSON 쿼리 구문
}
```

## 집계 API

과거에는 통계작업을 위해 루씬이 제공하는 패싯(Facets) 기능을 많이 활용했다. 하지만 패싯은 디스크 기반으로 동작했고 분산환경에는 최적화가 되지 않았기 때문에 대용량 데이터의 통계 작업에는 적합하지 않았다.

엘라스틱 서치에서는 5.0이후에 패싯 방식의 통계방식을 과감히 버리고 독자적인 집계 API를 내놓았다. 집계 API는 기본적으로 메모리를 기반으로 동작하기 때문에 대용량의 데이터 통계작업이 가능해졌다. 


# 데이터 모델링

엘라스틱 서치에서 색인할 문서의 데이터 유형에 따라 필드에 적절한 데이터 타입을 지정해야 한다. 이 과정을 매핑이라 하며, 매핑은 색인될 문서의 데이터 모델링이라 할 수 있다. 

## 매핑 API 이해하기 

매핑은 색인시 데이터가 어디에 어떻게 저장될지 결정하는 설정이다. 데이터 베이스의 스키마에 대응하는 개념이라고도 할 수 있는데 인덱스에 추가되는 각 데이터 타입을 구체적으로 정의하는 일이다. 

문서에 존재하는 필드의 속성을 정의할때 각 필드 속성에는 데이터 타입과 메타데이터가 포함된다. 이를 통해 색인 과정에서 문서가 어떻게 역색인으로 변환되는지 상세하게 정의할 수 있다. 

데이터 베이스에서 테이블 컬럼의 정보를 정의하는 것이 중요하듯 엘라스틱 서치에서도 데이터 타입을 정의하는 것은 매우 중요하다. 엘라스틱서치는 기본적으로 스키마리스이기 때문에 명시적으로 필드를 정의하지 않아도 데이터 유형에 따라 필드 데이터 타입에 대한 매핑 정보가 자동으로 생성된다. 자동 매핑 방식은 언뜻 편리해보이지만 실수로 잘못 지정된 매핑 정보가 지정될 경우 수정할 방법이 없으므로 매우 주의해야 한다. 

이미 만들어진 매핑 정보를 확인하려면 _mapping API를 사용하면 된다. 
```
GET movie_search/_mapping -- 생성된 index movie_search 매핑 정보 가져오기
```

### 매핑 파라미터 
매핑 파라미터는 색인할 필드의 데이터를 어떻게 저장할지에 대한 다양한 옵션을 제공한다. 

#### analyzer
해당 필드의 데이터를 형태소 분석하겠다는 의미의 파라미터다. 색인과 검색 시 지정한 분석기로 형태소 분석을 수행한다. text 데이터 타입의 필드는 analyzer 매핑 파라미터를 기본적으로 사용해야 한다. 별도의 분석기를 지정하지 않으면 Standard Analyzer로 형태소 분석을 수행한다. 

#### normalizer
normalizer 매핑 파라미터는 term query에 분석기를 사용하기 위해 사용된다. 예를 들어 keyword 데이터 타입의 경우 원문을 기준으로 문서가 색인되기 때문에 cafe, Cafe, Cafe'는 서로 다른 문서로 인식된다. 하지만 해당 유형을 normalizer를 통해 분석기에 asciifoldings같은 필터를 사용하면 같은 데이터로 인식되게 할 수 있다. 

#### ~~boost~~
필드에 가중치(weight)를 부여한다. 가중치에 따라 유사도 점수(_score)가 달라지기 때문에 boost 설정 시 검색 결과의 노출 순서에 영향을 준다. 만약 색인 시점에 boost 설정을 하게 된다면 재색인하지 않는 이상 가중치 변경을 할 수 없기 때문에 주의해서 사용해야 한다.
최신 엘라스틱 서치에서는 색인시 boost 설정을 사용할 수 없도록 바뀌었다. 

#### coerce
색인 시 자동 변환을 허용할지 여부를 말하는 파라미터다. 예를 들어 "10"과 같은 숫자 형태의 문자열이 integer 타입의 필드로 들어온다면 자동으로 형변환을 수행하여 정상적으로 처리한다. 하지만 coerce를 미사용으로 설정 해둔다면 색인에 실파한다. 

#### copy_to
매핑 파라미터를 추가한 필드 값을 지정한 필드로 복사한다. 예컨대 keyword 타입의 필드에 copy_to 매핑 파라미터를 사용해 다른 필드로 값을 복사하면 복사된 필드에서는 text 타입을 지정해 형태소 분석을 할 수도 있다.

#### fielddata
엘라스틱 서치가 힙 공간에 생성하는 메모리 캐시다. 과거에는 fielddata를 많이 사용했지만 메모리 부족현상과 잦은 GC로 현재는 거의 사용되지 않는다. 최신 버전의 엘라스틱 서치에서는 doc_values라는 새로운 형태의 캐시를 제공하고 있으며, text 타입 필드를 제외한 모든 필드는 기본적으로 doc_values 캐시를 사용한다. 
fielddata를 사용해야만 하는 경우도 있다. text 타입의 필드는 기본적으로 분석기에 의해 형태소 분석이 되기 때문에 집계나 정렬등의 기능을 수행할 수 없다. 하지만 부득이 하게 text 타입 필드에 대해서 집계나 정렬을 수행하는 경우도 있다. 이러한 경우에 fielddata를 사용할 수 있다. 하지만 fielddata는 메모리에 생성되는 캐시이기 때문에 최소한으로 사용하자. 기본적으로 fielddata는 비활성화 되어있다.

#### doc_values
엘라스틱 서치에서 사용하는 기본 캐시다. text 타입을 제외한 모든 타입에서 기본적으로 doc_values 캐시를 사용한다. doc_values는 루씬 기반의 캐시 방식인데 과거에는 캐시를 모두 메모리에 올려 사용했으나 현재는 힙 사용에 부담을 없애고 운영체제의 파일 시스템 캐시를 통해 디스크에 있는 데이터에 빠르게 접근할 수 있다. 이로 인해 GC 비용이 들지 않으면서도 메모리 연산과 비슷한 성능을 보인다. 
필드를 정렬, 집계할 필요가 없고 스크립트에서 필드 값에 엑세스할 필요가 없다면 디스크 공간 절약을 위해 doc_values를 비활성화 할수도 있다. 한 번 비활성화된 필드는 인덱스를 재색인 하지 않는한 변경이 불가능하다.

#### dynamic
매핑에 필드를 추가할 때 동적으로 생성할지, 생성하지 않을지를 결정한다. 동적 생성 필드의 처리 방법으로 세 가지 설정 중 하나를 선택할 수 있다. 
true: 새로 추가되는 필드를 매핑에 추가한다.
false: 새로 추가되는 필드를 무시한다. 
strict: 새로운 필드가 감지되면 예외가 발생하고 문서 자체가 색인되지 않는다. 

#### enabled
검색 결과에 포함하지만 색인은 하고 싶지 않은 경우도 있다. 메타 성격의 데이터가 그렇다. 예컨대 일반적인 게시판이라면 제목과 요약 글만 색인하고 날짜와 사용자 ID는 색인하지 않는 경우다. 색인을 원치 않는 날짜와 사용자 ID의 매핑 파라미터 중 enabled를 false로 설정하면 _source에서는 검색이 되지만 색인은 하지 않는다. 

#### format
엘라스틱 서치는 날짜/시간을 문자열로 표시한다. 이때 날짜/시간을 문자열로 변경할때 미리 구성한 포맷을 사용할 수 있다.
basic_date -> yyyyMMdd
basic_date_time -> yyyyMMdd'T'HHmmss.SSSZ

#### ignore_above
필드에 저장되는 문자열이 지정한 크기를 넘어서면 빈 값으로 색인한다. 

#### ignore_malformed
엘라스틱서치에서는 잘못된 데이터 타입을 색인할고 하면 예외가 발생하고 문서전체가 색인되지 않는다. 이 파라미터를 사용하면 해당 필드만 무시하고 문서는 색인할 수 있다.

#### index
특정 필드값을 색인할지를 결정한다. 기본값은 true이며 false이면 해당 필드를 색인하지 않는다.

#### fields
다중 필드(multi_field)를 설정할 수 있는 옵션이다. 필드안에 또다른 필드 정보를 추가할 수 있어 같은 string 값을 각각 다른 분석기로 처리할 수 있다. 

#### norms
문서의 _score 값 계산에 필요한 정규화 인수를 사용할지 여부를 설정한다. 기본값은 true이다. _score 계산이 필요없거나 단순 필터링 용도로 사용하는 필드는 비활성화해서 디스크 공간을 절약할 수 있다.

#### null_value
색인시 문서에 필드가 없거나 필드의 값이 null이면 색인 시 필드를 생성하지 않는다. 이 경우 null_value를 설정하면 문서의 값이 null이더라도 필드를 생성하고 그에 해당하는 값을 저장한다.

#### position_increment_gap
배열 형태의 데이터를 색인할때 검색의 정확도를 높이기 위해 제공하는 옵션이다. 단어와 단어 사이의 간격(gap)을 허용할지를 설정한다. 

#### properties
오브젝트 타입이나 중첩 타입의 스키마를 정의할때 사용하는 옵션으로 필드의 타입을 매핑한다. 오브젝트 필드 및 중첩 필드에는 properties 서브 필드가 있다. 이 properties는 object나 nested를 포함한 모든 데이터 타입이 될 수 있다. 

#### search_analyzer
일반적으로 색인과 검색시 같은 분석기를 사용한다. 만약 다른 분석기를 사용하고 싶으면 검색시 사용할 분석기를 별도로 지정할 수 있다. 

#### similarity
유사도 측정 알고리즘을 지정한다. 유사도 측정 방식의 기본 알고리즘인 BM25를 다른 알고리즘으로 변강할 수 있다.

| 알고리즘 | 설명|
|--|--|
|BM25  | Okapi BM25 알고리즘으로 엘라스틱 서치가 사용하는 기본 유사도 측정 알고리즘이다. |
|classic | TF/IDF 기반 알고리즘이다. 문서 내 용어의 갯수와 전체 용어의 갯수로 유사도를 계산한다.|
|boolean|복잡한 수학적 모델을 사용하지 않고 단순히 boolean연산으로 유사도를 측정한다. score는 검색어 일치 여부에 따라 결정되며, 일치 여부에 따라 쿼리의 가중치(boost)에 사용된 점수로만 유사도를 계산한다.|

#### store
필드의 값을 저장해 검색 결과에 값을 포함하기 위한 매핑 파라미터다. 기본적으로 _source에 색이된 문서가 저장된다. 

#### term_vector
루씬에서 분석된 용어의 정보를 포함할지 여부를 결정하는 매핑 파라미터이다. 

| 알고리즘 | 설명|
|--|--|
|no  | term vector를 저장하지 않는다.|
|yes | 필드와 용어만 저장한다.|
|with_positions|용어, 용어의 시작과 끝 위치를 저장한다.|
|with_offsets|용어, 문자 오프셋을 저장한다.|
|with_positions_offsets|용어, 용어의 시작과 끝 위치, 문자 오프셋을 모두 저장한다.|

### 메타 필드(Meta Fields)

메타 필드는 엘라스틱 서치에서 생성한 문서에 제공하는 특별한 필드이다. 이것은 메타데이터를 저장하는 특수 목적의 필드로서 이를 이용하면 검색 시 문서를 다양한 형태로 제어하는 것이 가능해진다. 

아래는 색인된 문서를 조회한 경우 반환되는 JSON 예이다. 
```
{
	"_index": "movie_search",
	"_type": "_doc",
	"_id": "8",
	"_score": "1",
	"_source": {
		"movieCd": "20178401",
		"movieNm": "검객",
		"typeNm": "장편",
		...
	}
}
```
여기서 제공되는 항목 중 실제 문서의 정보를 담고 있는 항목은 _source 항목이다. 그 밖에 _index, _type, _id, _score 함수는 엘라스틱 서치가 직접 생성한 메타 필드다. 이제 이 메타 필드를 한번 알아보도록 하자.

#### _index

_index 메타 필드는 해당 문서가 속한 인덱스의 이름을 담고 있다. 이를 이용해 검색된 문서의 인덱스를 알 수 있고, 해당 인덱스에 몇개의 문서가 있는지 확인할 수 있다. 

#### _type

해당 문서가 속한 매핑의 타입 정보를 담고 있다. 이로 인덱스 내부에서 타입별로 몇개의 문서가 있는지 확인할 수 있다. 

#### _id

문서를 식별하는 유일한 키 값이다. 한 인덱스에 색인된 문서마다 서로 다른 키 값을 가진다. 

#### _uid

이 필드는 특수한 목적의 식별키다. "#" 태그를 사용해 _type과 _id를 조합해 사용한다. 하지만 내부적으로만 사용되기 때문에 검색시 조회되는 값을 아니다. 

#### _source

문서의 원본 데이터를 제공한다. 내부에는 색인 시 전달된 원본 JSON 문서의 본문이 저장되어 있다. **일반적으로 원본JSON 문서를 검색 결과로 표시할때 사용한다.**

#### ~~_all~~

all 메타 필드는 색인에 사용된 모든 필드의 정보를 가진 메타 필드이다. 모든 필드의 내용이 하나의 텍스트로 합쳐져서 제공된다. 특정 필드가 아닌 문서 전체 필드에서 특정 키워드를 검색한다면 _all  필드를 사용하자 

하지만 _all 필드는 데이터 크기를 너무 많이 차지하는 문제가 있어 엘라스틱 서치 6.0 이상부터는 폐기(deprecated)되었다. 그래서 필드 복사가 필요한 경우 copy_to 파라미터를 사용해야 한다. copy_to를 사용하면 _all과 동일한 효과를 낼 수 있다.

#### _routing 
특정 문서를 특정 샤드에 하기 위해 사용자가 지정하는 메타 필드다. 기본적으로 색인을 하면 해당 문서는 다음 수식에 따라 문서 id를 이용해 문서가 색인될 샤드를 결정한다. 별도의 설정 없이 문서를 색인하면 문서는 샤드에 골고루 분산되어 저장된다.

```

```

> Written with [StackEdit](https://stackedit.io/).

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NTg2OTM3MjMsLTE0NDkwODQ4NTIsMT
MyNjQ3NjU4MiwtMTU0MDM5OTI3MSwtODgwOTIxMDU0LC03ODIy
MTY0NTksLTIwNzQwNTEwNTYsMTUwMjIzMjI0OCw5ODI1MTEyNy
wtMTc0NDYwMTg1NSw1MzI5Mzc5MzMsLTIwNDg0NTg2ODQsLTE4
Nzk3NzM0OTEsLTE4NzQzNDM1MzAsLTE1MzkyNTcwMjEsMzI2Mz
I1MzExLC0xMjE2MjM4MDgzLC0xNjY3ODYwNjY0LDIwNDE3MDE3
OTcsNzQwODI2Mzg3XX0=
-->