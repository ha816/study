# Overview

엘라스틱 서치는 인덱스에 저장된 문서를 검색하도록 다양한 검색 기능을 제공한다. 특정 문장이 검색어로 요청되면 분석기를 통해 분석된 토큰의 일치 여부를 판단해서 그 결과에 점수(score)를 매긴다. 이를 기반으로 순서를 적용해 결과를 사용자에게 최종적으로 출력하게 된다. 

검색의 대상이 되는 필드는 분석이 되는 Text 타입의 유형이 될 수도 있고 분석이 되지 않는 Keyword 타입의 유형이 될수도 있다. 

엘라스틱 서치에서는 다양한 검색 조건을 만족하기 위해 QueryDSL이라는 특수한 쿼리 문법을 제공한다. 

# 검색 API

문장은 색인 시점에 term(텀)으로 분해된다. 토크나이저가 나눈 토큰을 토큰 필터로 처리하고 나면 그것이 바로 term이다. 

엘라스틱서치는 색인 시점에 분석기로 분석된 텀을 역색인 구조로 만들어 내부적으로 저장한다. 검색 시점에는 Keyword 타입과 같은 분석이 불가능한 데이터와 Text 타입과 같은 분석이 가능한 데이터를 구분해서 가능할 경우 분석기로 분석을 수행한다. 

검색 API는 기본적으로 질의(Query)를 기반으로 동작한다. 검색 질의에는 검색하고자 하는 각종 조건들을 명시할 수 있으며 동일한 조건을 URI, Request Body 검색 두 가지로 할 수 있다. 

URI 방법은 루씬에서 사용하는 전통적인 방식이고 Request Body는 RESTful API를 이용해 Request Body에 조건을 표시하는 방법이다. 

## URI

이 방식은 HTTP GET 요청을 활용하는 방식으로 파라미터를 key=value 형태로 전달한다. URL에 검색할 컬럼과 검색어를 직접 지정하면 검색이 수행된다. 파라미터로는 표현의 한계가 있어 복잡한 질의를 작성하는 것을 불가능하다. 그래도 웹브라우저를 통해 빠르게 테스트를 해볼 수 있다는 장점이 있다. 

|파라미터|기본값| 설명|
|--|--|--|
|q |  | 검색을 수행할 쿼리 문자열 조건을 지정한다.|
|df |  |쿼리에 검색을 수행할 필드가 지정되지 않았을 경우, 기본 값으로 검색할 필드를 지정한다|
|analyzer| 검색 새당 필드에 설정된 형태소 분석기|문자열을 형태소 분석할때 사용할 분석기를 지정한다.|
|analyzer_wildcard| false|와일드카드 검색 활성화여부를 지정한다.|
|default_operator|OR|두 개 이상의 검색 조건이 쿼리 문자열에 포함된 경우 검색 조건 연산자를 설정한다.|
|_source| true| 검색 결과에 문서 본문 포함 여부를 지정한다|
|sort|  |검색 결과의 정렬 기준필드를 지정한다|
|from|  |검색을 시작할 문서의 위치를 지정한다|
|size|  |반환할 검색 결과 갯수를 설정한다.|

q 옵션에는 기본적으로 '[필드명]:검색어' 형태로 입력할 수 있으며, 예제와 같이 여러개의 필드를 검색할때는 공백을 입력한 후 추가적인 필드명과 검색어를 입력한다. 

## Request Body 검색

이 방식에서는 HTTP 요청시 본문에 JSON 혀애로 검색 조건을 기록해서 검색을 요청한다. 간단한 검색은 언뜻 보면 URI 방식이 더 좋아 보일것이다. 하지만 JSON 형태로 작성하면 전체적인 방식이 더 잘 보일 것이다. 

# Query DSL

Query DSL로 쿼리를 작성하려면 미리 정의된 문법에 따라 JSON 구조를 작성해야 한다. 기본적인 구조는 다음과 같다.
```
{
	"size":
	"from":
	"timeout":
	
	"_source":{}
	"query":{}
	"aggs":{}
	"sort":{}
}
```
size는 리턴 받는 결과의 갯수를 지정한다. 기본값은 10이다
from은 몇 번째 문서부터 가져올지 지정한다. 기본값은 0이다.
timeoout은 검색을 요청해서 받는데 까지 걸리는 제한 시간을 나타낸다. timeout을 너무 짧게 잡으면 timeout에 걸리지 않은 문서만 결과로 나타나기 때문에 의도치 않은 결과가 나타날 수 있다. 기본값은 무한대이다. 

_source는 검색시 필요한 필드만 출력하고 싶을 때 사용한다.
query는 검색 조건문이 들어가는 공간이다.
aggs는 통계 및 집계 데이터를 사용하는 공간이다.
sort는 문서결과를 어떤 순서로 출력할지에 대한 공간이다.


```
{
	"took":
	"timed_out":
	
	"_shards":{
		"total":
		"successful":
		"failed":
	},

	"hits":{
		"total":
		"max_score":
		"hits":[]
	}
}
```

위의 JSON 형태는 기본 응답 구조이다. 
took은 쿼리 수행 시간을 나타낸다.
timed_out은 쿼리 시간이 초과할 경우 나타난다.
_shards.total은 쿼리를 요청한 저체 샤드의 개수를 나타낸다.
successful은 성공적으로 응답한 샤드의 갯수를 나타낸다.
failed는 응답에 실패한 샤드의 갯수를 나타낸다.

_hits.total은 검색어에 매칭된 문서의 전체 개수를 나타낸다. 
max_score는 일치하는 문서의 스코어 값중 가장 높은 값을 출력한다.
hits는 각 문서 정보와 스코어 값을 보여준다. 

## Query DSL 쿼리와 필터

Query DSL을 잉요해 검색 질의를 작성할 때 조금만 조건이 복잡해지더라도 여러 개의 작은 질의를 조합해서 사용해야 한다. 이때 작성되는 작은 질의들을 두 가지 형태로 나눠서 생각해 볼 수 있다. 실제 분석기에 의한 전문 분석이 필요한 경우와 단순시 필터 조건으로 검색이 가능한 경우다.

엘라스틱 서치에서 전문 분석이 필요한 질의를 쿼리 컨텍스트라고 하며 단순 필터 조건 질의는 필터 컨텍스트라 구분하여 사용한다. 

||쿼리 컨텍스트|필터 컨텍스트|
|--|--|--|
|용도|전문 검색시 사용 | 조건 검색시 사용|
|특징| 분석기에 의해 분석 수행, 연관성 관련 Score 계산, 루씬 레벨에서 분석 과정을 거쳐야 하므로 상대적으로 느림 | 단순 판별 기능, score 관련 계산 하지 않음. 상대적으로 빠름. |

대부분의 경우 쿼리 컨텍스트 방식과 필터 컨텍스트 방식 모두 같은 결과를 얻는다. 하지만 어떤 방식을 사용하느냐에 따라 검색 과정이나 성능이 크게 달라지기 대문에 가능한 용도에 맞게 사용해야 한다. 

### 쿼리 컨텍스트

* 문서가 쿼리와 얼마나 유사한지 스코어 계산을 한다.
* 질의가 요청도리때 마다 루씬을 이용해 계산을 수행하고 결과가 캐싱되지 않는다.
* 일반적으로 전문 검색에 많이 사용한다.
* 캐싱 되지 않고 디스크 연산을 하기에 상대적으로 느리다.

### 필터 컨텍스트

* 쿼리의 조건과 문서가 일치하는지 판별한다.
* 스코어 계산을 하지 않고 단순 매칭 여부를 검사한다.
* 자주 사용되는 필터 결과는 내부적으로 캐싱해둔다.
* 기본 메모리 연산을 수행하기에 빠르다.

## Query DLS의 주요 파라미터

쿼리를 작성할때 공통적으로 자주 사용되는 주요 파라미터가 무엇이 있는지 알아보도록 하자.

### Multi Index 검색

기본적으로 모든 검색 요청은 Multi Index 및 Multi Type검색이 가능하다. 이러한 특성 덕에 다수의 인덱스를 검색해야 할때도 한번의 요청으로 검색 결과를 얻을 수 있다. 검색 요청시 "," 컴마를 이용해 다수의 인덱스 명을 입력할 수 있다. 이때 지정된 모든 인덱스가 검색 대상이 된다. 

아래 쿼리는 move_search, movie_auto 인덱스를 모두 검색한다. 
```
POST movie_search, movie_auto/_search 
...
```

### 쿼리 결과 페이징(from, size)

페이징 구현을 위해선 from 파라미터와 size 파라미터를 사용한다. 제공되는 문서의 시작을 from으로 문서 갯수를 size로 나타낸다.

1 페이지를 from = 0, size = 10으로 조회했다면, 2페이지는 from= 10, size = 10으로 조회하면 된다. 

**주의할 점은 RDBMS와는 다르게 해당 문서만 선택적으로 가져오는 것이 아니라 모든 데이터를 읽고 그 중에서 조건에 맞는 결과를 반환한다.** 예를 들어 위 예제와 같이 2페이지를 읽으려고 하더라도 총 20건의 문서를 읽어야 한다. 전체를 읽어서 사이즈 만큼 필터링 해서 제공하는 구조이기 때문에 페이지 번호가 높아질 수록 쿼리 비용이 높아질수 밖에 없다는 점을 명심하자. 

### 쿼리 결과 정렬(sort)

엘라스틱 서치는 기본적으로 유사도 계산에 의한 스코어 점수 값으로 정렬을 하는데 이것이 아니라 필드의 이름, 날짜, 가격등으로 재정렬을 하고 싶을때가 있다. 이럴때 사용하는 것이 sort 파라미터이다. 

```
...
"sort" : {
	"col1": {
	"order": "asc"
	},
	"_score": {
	"order": "desc"
	}
}
```

### _source 필드 필터링

기본적으로 _source 항목은 문서 내부에 존재하는 모든 필드를 결과로 제공한다. 하지만 항상 모든 필드는 볼 필요는 없으며, 필요에 따라 특정 필드를 검색 결과에서 제거하고 싶을때도 있을 것이다. 그럴땐 _soucre 필드를 필터링 옵션으로 필요한 필드만 검색해서 가져올 수 있다.

```
...
"_source": ["movieNm"] -- movieNm 필드만 가져오기
...
```

### 범위 검색

범위를 기반으로 한 쿼리이다. 

| 문법| 연산자  |
|--|--|--|
|lt(lower than)  | < |
|gt(greater than)  | > |
|lte(lower than or equal  | <= |
|gte(greater than or equal  | >= |

```
...
"query" : {
	"range" : {
		"prdtYear" : {
			"gte": "2016",
			"lte": "2017",
		}
	}
}
...
```

### operator 설정

엘라스틱 검색시 문장이 들어올 경우 기본적으로 OR연산으로 동작한다. 하지만 실무에서는 AND 연산을 통해 정확도를 높여야 할때가 많을 것이다. OR 연산이나 AND 연상르 어떻게 선택적으로 사용하는지 알아보자. 

Query DLS에서는 operator 파라미터로 연산자를 명시하는게 가능하다. 기본적으로 "and"나 "or" 연산자를 명시적으로 지정이 가능하다. 

```
...
"query" : {
	"match" : {
		"movieNm" : {
			"query": "자전차왕 엄복동",
			"operator": "and"
		}
	}
}
...
```

operator를 생략하면 OR연산으로 동작해서 "자전차왕" 혹은 "엄복동"이라는 단어가 들어간 모든 문서가 검색될 것이다. 하지만 AND 연산으로 지정하면 두개의 단어가 모두 존재하는 문서만 결과가 나올 것이다. 

### minimum_should_match 설정

이번에는 OR 연산을 수행할 경우에 사용할 수 있는 옵션을 알아보자. 일반적으로 OR 연산을 수행할 경우 검색 결과가 너무 많아질 수 있다. 이 경우 단어의 갯수가 최소 몇 개 이상 매칭될때만 검색 결과로 나오게 할 수 있는데 minimum_should_match가 그 설정이다. 

OR연산으로 검색할때 해당 파라미터를 사용하면 AND 연산자가 아닌 OR연산으로도 AND 연산과 비슷한 효과를 나타낼 수 있다. 

```
...
"query" : {
	"match" : {
		"movieNm" : {
			"query": "자전차왕 엄복동",
			"minimum_should_match":2
		}
	}
}
...
```
위와 같이 작성한다면  AND 연산과 동일한 효과를 낸다.

### fuzziness 설정

fuzziness 파라미터를 사용하면 단순히 같은 값을 찾는 match Query를 유사한 값을 찾는 Fuzzy Query로 변경할 수 있다. 이는 레벤 슈타인 편집 거리 알고리즘을 기반으로 문서의 필드 값을 여러번 변경하는 방식으로 동작한다. 유사한 검색 결과를 찾기 위해 허용 범위의 텀으로 변경해 가며 문서를 찾아 결과를 출력한다. 

예를 들어, 편집 거리 수를 2로 설정하면 오차범위가 두 글자이하인 검색 결과까지 포함하여 결과를 출력한다. 오차범위 값으로 0,1,2 AUTO 총 4가지를 사용할 수 있는데, 알파벳에는 유용하지만 한국어에는 적용하기 어렵다. 

예를 들어, 영화 제목을 실수로 잘못 적은 경우도 검색되게 하고 싶을때가 있다. "Fly High"가 아닌 "Fl High"라고 입력했다면 Fuzziness설정으로 가장 유사한 검색이 가능해진다.

```
...
"query" : {
	"match" : {
		"movieNmEn" : {
			"query": "Fli High",
			"fuzziness": 1
		}
	}
}
...
```

### boost 설정

boost 설정은 검색에서 가장 많이 사용하는 파라미터 중 하나다. 이 파라미터는 관련성이 높은 필드나 키워드에 가중치를 더 주도록 한다. 영화 데이터의 경우 한글 영화 제목과 영문 영화 제목으로 두 가지 제목필드를 제공하고 있다. 이때 한글 영화 제목에 좀 더 가중치를 두어 검색 결과를 더 상위로 올리고 싶을때 사용 할 수 있다. 

```
...
"query" : {
	"multi_match" : {
		"query": "Fly",
		"fields" : ["movieNm^3", "movieNmEn"]
	}
}
...
```

위 Fly 단어를 movieNm과 movieNmEn이라는 두 개의 필드에서 조회한다. 만약 한글 영화 제목이 일치하게 된다면 한글 영화 제목에서 계산되는 스코어에 가중치 값으로 3을 곱하게 된다.

## Query DLS의 주요 쿼리

엘라스틱서치에서 제공하는 검색 관련 기능은 Query DLS을 이용해 모두 사용할 수 있다. 이번 장에서는 Query DLS의 주요 쿼리에 대해 알아보자. 

### Match All Query

match_all 파라미터를 사용하는 Match Al Query는 색인에 모든 문서를 검색하는 쿼리다. 가장 단순한 쿼리로 저장된 문서를 확인할 때 사용한다. 

```
POST movie_search/_search
{
	"query": {
		"match_all": {}
	}
}
```

### Match Query

텍스트, 숫자, 날짜 등이 포함된 문장을 형태소 분석을 통해 텀으로 분리한 후 이 텀들로 검색 질의를 수행한다.
```
POST movie_search/_search
{
	"query": {
		"match": {
			"moviceNm": "그대 장미"
		}
	}
}
```

"그대 장미"라는 검색어로 Match Query를 요청했기 때문에 해당 질의를 "그대", "장미" 두개의 텀으로 분리한다. 이후 두개의 텀으로 OR연산으로 검색을 수행한다.

### Multi Match Query

Match Query와 기본적인 사용은 동일하나 단일 필드가 아닌 여러 필드를 대상으로 검색할 때 사용한다.

```
POST movie_search/_search
{
	"query": {
		"multi_match": {
			"query": "가족",
			"fields": ["movieNm", "movieNmEn"]
		}
	}
}
```

### Term Query

텍스트 형태의 값을 검색하기 위해서 엘라스틱 서치는 두 가지 매핑 유형을 지원한다.

Text 데이터 타입
: 필드에 데이터가 저장되기 전에 데이터가 분석되어 역색인 구조로 저장된다. 

Keyword 데이터 타입
: 데이터가 분석되지 않고 그대로 필드에 저장된다.

Term Query는 Keyword 데이터 타입을 대상으로 하기 때문에 일반적으로 숫자,  Keyword, 날짜 데이터를 쿼리하는데 사용한다. 

앞에서 보았던 MatchQuery의 경우 텍스트에 대해서 형태소 분석을 통해 검색을 수행하지만 Term Query의 경우 하나의 텀으로 처리하기 때문에 텀이 정확히 존재하지 않는 경우 검색이 되지 않는다. 

### Bool Query

관계형 DBMS에서는 AND, OR 조건으로 묶은 여러 조건을 WHERE 절에서 사용할 수 있다. 엘라스틱서치에서는 하나의 쿼리나 여러 개의 쿼리를 조합해서 더 높은 스코어를 가진 쿼리 조건으로 검색을 할 수 있다 이런 유형의 쿼리를 Compound Query라 하는다, 이를 구현하기 위해 엘라스틱 서치에선 Bool Query를 제공한다. Bool Query를 상위에 두고 하위에 다른 Query들을 사용해 복잡한 조건의 쿼리문을 작성할 수 있다. 

Bool Query는 주어진 쿼리와 논리적으로 일치하는 문서를 복합적으로 검색한다. 

```
POST movie_search/_search
{
	"query": {
		"bool": {
			"must": [],
			"must_not": [],
			"should": [],
			"filter": []
		}
	}
}
```

must의 필드에는 반드시 조건에 만족하는 문서만 검색된다.
must_not 필드에는 조건을 만족하지 않는 문서가 검색된다.
should필드에는 여러 조건 중 하나 이상을 만족하는 문서가 검색된다.
filter 필드에는 조건을 포함하고 있는 문서를 포함한다.

```
POST movie_search/_search
{
	"query": {
		"bool": {
			"must": [
				{
					"term" : {
						"repGenreNm": "코미디"
					}
				},
				{
					"match" : {
						"repNationNm": "한국"
					}
				}
			],
			"must_not": [
				{
					"match" : {
						"typeNm" : "단편"
					}
				}
			],
		}
	}
}
```

보다시피 Bool Query를 이용하면 여러 개의 옵션을 조합해서 복잡한 조건을 구현할 수 있다. 위 JSON은 대표 장르가 "코미디"이고, 제작 국가에 "한국"이 포함되어 있으며 영화 타입 중 "단편"이 제외된 문서를 검색한다. 

### Wildcard Query

검색어가 와일드 카드와 일치하는 구문을 찾는다. 이때 입력된 검색어는 형태소 분석이 이루어지지 않는다. 

와일드 카드 옵션에는 *과 ?가 있다.
*는 문자의 길이와 상관 없이 와일드 카드와 일치하는 모든 문서를 찾는다.
?는 지정된 위치의 한 글자가 다른 경우의 문서를 찾는다.

와일드 카드를 사용할 경우 단어의 첫 글자로는 절대 사용해서는 안된다. 첫 글자로 와일드 카드를 넣으면 색인된 문서 전체를 찾아야하는 불상사가 발생할 수 있기 때문이다. 

### Nested Query

분산 시스템에서 SQL에서 지원하는 조인과 유사한 기능을 수행하려면 엄청나게 많은 비용이 소모된다. 수평적으로 샤드가 얼마나 늘어날지 모르는 상황에서 모든 샤드를 검색해야 할 수도 있기 때문이다.

다행히 엘라스틱 서치에서는 분산 데이터 환경에서도 SQL 조인과 유사한 기능을 수행하는 Nested Query를 제공한다. 

Nested Query는 Nested 데이터 타입의 필드를 검색할때 사용한다. Nested 데이터 타입은 문서 내부에 다른 문서가 존재할때 사용한다. path 옵션으로 중첩된 필드를 명시하고, query 옵션에 Nested 필드 검색에 사용할 쿼리를 입력한다. 



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc1MjAyMjMyMywtNzg3OTQ2MTIsLTE4MT
A5MDI2NjUsOTQ3NDA4NjI3LC0xMDA0NTcyNzkyLC01NjE2MDg1
NTIsLTE1MDk2OTg1MiwxODM2ODgzNzk3LDc4MDgyOTcyNywxND
c2NzM5NjI0LDE0MDQwMDQ3OTQsLTExOTg5MjM4MTgsNTE3MjU5
MzA2LC0xNTAxMzEwMjE1LC0xNTk5ODc2NDI0LDM4ODE2MTUyMy
wtMTk2MzY5MjY5MSwtMzA2Nzg2ODE0LDExNzYxMTg1NjAsMjA3
MTE0NTc5Nl19
-->