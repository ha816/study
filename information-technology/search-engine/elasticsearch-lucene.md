# Overview

엘라스틱서치는 내부적으로 루씬을 통해 검색기능을 수행한다. 루씬의 동작 과정은 고도로 추상화되어 제공되기 때문에 사용자들은 루씬의 존재를 눈치채지 못할 수도 있다. 하지만 루씬의 세부적인 동작 원리를 이해하고 나면 엘라스틱 서치를 이해하는데 큰 도움이 된다. 이번 장에서는 루씬 라이브러리에 대해 알아보자

# 클러스터 관점에서 구성요소 

엘라스틱서치는 기본적으로 클러스터란 단위로 데이터를 제공한다. 클러스터는 하나 이상의 물리적인 노드로 구성되며 각 노드는 모두 데이터 색인 및 검색 기능을 제공하는 일종의 물리적 서버이기도 하다. 즉 노드는 물리적 서버를 뜻하며 다수의 서버가 모여 하나의 클러스터를 구성한다. 

엘라스틱 서치의 최상위 개념인 클러스터로 부터 최하위 개념인 세그먼트까지 하향식으로 살펴보도록 하자.

## 클러스터 

클러스터는 노드(물리적 서버)들의 집합이다. 같은 클러스터 내부의 데이터민 서로 공유가 가능하기 때문에 연관된 노드들끼리 하나의 클러스터로 구성하는 것이 매우 중요하다. 

같은 클러스토로 묶일 노드들은 같은 반드시 같은 클러스터 이름을 가져야 한다. (엘라스틱서치는 이름으로 같은 클러스터인지 아닌지 판별한다)

같은 클러스터에 속한 노드들은 평소 데이터 색인이나 검색 작업을 함께 수행하게 되고 장애가 발생했을때도 데이터 복구를 위해 서로 협력해서 복구한다.

>Cross Cluster Search
>실무에서 업무를 하다보면 데이터 성격에 따라 다수의 클러스터를 운영하게 된다. 데이터가 커지고 복잡해지면 필연적으로 다수의 클러스터를 함께 검색해야하는 일도 빈번히 발생한다.
>엘라스틱서치에서는 이처럼 다양한 필요에의해서 다수의 클러스터를 한번에 검색할 수 있는 기능을 제공하는데 그것이 Cross Cluster search다. 

## 노드(Node)

실행 중인 엘라스틱 서치를 노드라고 부른다. 좀더 정확하게는 다수의 물리 서버에 엘라스틱 서치를 설치하고 실행된 엘라스틱서치 인스턴스를 노드라고 한다.

노드는 클러스터를 이루는 구성원이며 실제 데이터를 가지고 있는 단일 서버이기도 하다. 실행 시 노드는 클러스터에 의해  UUID(Universally Unique IDentifier)가 할당되고 클러스터 내에서는 할당된 UUID로 서로를 식별한다. 기본값으로 부여되는 UUID를 원치 않는다면 직접 이름도 설정할 수 있다. 같은 클러스터 내부에서 유일한 노드를 식별하는 것은 매우 중요하기 때문에 신중해질 필요가 있다. 

같은 클러스터 내부에 존재하는 모든 노드는 서로 다른 노드와 수시로 정보를 주고 받는다. 기본적으로 모든 노드는 마스터 노드와 데이터 노드의 역할을 동시에 수행하도록 설정되어 있는데, 실제 운영에서는 역할에 따라 노드를 구분하는 것이 좋다. 

특히 마스터 노드의 경우, 클러스터 전체를 제어하기 때문에 물리적으로 분리해서 독립적으로 운영하는 것이 좋다.

## 인덱스(Index)

인덱스는 유사한 특성을 가지고 있는 문서들을 모은 컬렉션이다. 클러스터 내부에 생성되는 모든 인덱스는 클러스터 내에서 유일한 인덱스명을 가져야 한다. 이 인덱스 이름을 통해서 데이터 생성, 수정, 삭제, 검색이 이루어지기 때문에 매우 중요하다. 참고로 인덱스 명은 반드시 소문자로 만들어야 한다. 엘라스틱 서치에서 강제하는 사항이므로 반드시 지켜야 한다.

## 문서(Document)

문서는 검색 대상이 되는 실제 물리적인 데이터를 말한다. 문서는 인덱스를 생성할 수 있는 기본적인 정보 단위이고 JSON 형식으로 표현된다. 인덱스에 원하는 만큼 많은 문서를 저장할 수 있고 실제로는 샤드 형태로 나누어져 다수의 노드로 분산 저장된다.

## 샤드(Shard)

인덱스에서는 엄청나게 많은 문서가 저장될 수 있다. 하나의 하드웨어에서 제공하는 리소스의 물리적인 한계를 넘기 위해 도입한 개념이 바로 샤드이다. 이를 이용하면 데이터를 분삭 저장할때 손쉽게 수평확장이 가능해진다. 

샤드는 인덱스 전체 문서 데이터의 부분 집합으로 이해하면된다. 부분집합이지만 갹 샤드는 자신이 가지고 있는 데이터만으로도 독립적으로 검색 서비스가 가능하다. 

실제로 인덱스에 쿼리를 요청하면 인덱스가 가지고 있는 모든 샤드로 검색 요청이 전달되고 각 샤드에서 1차적인 검색이 이뤄진 후 그 결과를 취합해서 최종 결과로 제공한다. 인덱스가 샤드로 분산되는 과정이나 검색 요청이 각 샤드에 분산되어 처리되는 복잡한 프로세스는 사용자에게 완벽하게 블랙박스이다. 

>샤딩이 중요한 이유
>지속적으로 증가하는 컨텐츠가 수평적으로 분할되어 하드웨어의 한계를 극복할 수 있다.
>여러 노드에서 샤드를 통해 분산 처리되므로 성능이나 처리량을 향상 시킬 수 있다.

## 레플리카

샤드의 복제본을 레플리카 (Replica)라고 한다. 엘라스틱 서치에서는 인덱스를 생성할때 기본적으로 1개의 레플리카 세트를 생성한다. 검색 시 레플리카가 적극적으로 활용되기 때문에 이를 이용하면 일기 분산이 유리해진다. 

수평적으로 분산된 시스템을 운영할때는 언제든 장애가 나타날 수 있다. 네트워크 특성상 특정 노드가 오프라인으로 변경될 경우 페일오버(Failover) 메커니즘을 적극적으로 활용하는 것이 좋은데 엘라스틱서치에서는 레플리카를 이용한 페일오버 메커니즘을 제공하고 있고 이를 이용해 안정적인 클러스터 운영을 보장한다. 

인덱스가 생성될 때 샤드 개수와 레플리카 개수를 자유롭게 설정할 수 있다.하지만 인덱스가 생성된 이후에는 샤드 개수를 변경하는 것이 불가능하기 때문에 이 점에 유의하자. 그에 반해 레플리카의 갯수는 인덱스를 생성한 이후에도 자유롭게 변경하는 것이 가능하다. 그렇게 때문에 운영 중 트래픽 증가에 대한 유연한 대응이 가능해진다. 이는 검색 엔진의 특성상 읽기 연산이 대부분이기 때문에 매우 유용한 기능이다.

>엘라스틱 서치의 고가용성
>엘라스틱서치에서는 샤드나 노드에 장애가 발생할 경우, 즉각적인 복구가 가능하기 때문에 안정적인 클러스터 운영이 가능해진다. 페일오버 메커니즘을 송공적으로 구현하기 위해 레플리카는 기본적으로 원본 샤드가 존재하지 노드에서 생성된다. 또한 검색 시 샤드와 레플리카에서 병렬로 실행될 수 있기 때문에 검색 성능이 좋아진다.

## 세그먼트

문서들은 빠른 검섹에 유리하도록 설계된 특수한 자료구조로 저장된다. 샤브 내부에 루씬 라이브러리를 포함하고 있는데, 이를 통해 대부분의 검색 기능을 제공한다. 루씬에 데이터가 색인되면 데이터는 최소의 단위인 토큰으로 분리되고 토큰은 특수한 형태의 자료구조로 저장되는데, 이를 세그먼트라 한다. 

세그먼트는 읽기에 최적화된 자료구조로이다. 

# 엘라스틱서치 샤드 VS 루씬 인덱스

루씬은 다수의 클래스로 구성되어 있는 검색 라이브러리이고, 이 중에서 가장 중요한 클래스가 바로 IndexWriter와 IndexSearcher이다. 간단히 설명하자면 IndexWriter는 데이터를 색인하는 클래스이고, IndexSearcher는 색인된 데이터를 검색 결과로 제공하는 클래스다. 사실 이 두개의 클래스가 루씬의 핵심이라고 해도 과언이 아니다. 

IndexWriter와 IndexSearcher를 가지고 색인과 검색을 동시에 제공하는 루씬 인스턴스를 루씬 인덱스라고 하는데, 사실 하나의 엘라스틱서치 샤드는 하나의 루씬 인덱스라고 설명할 수 있다. 우리가 알고 있는 엘라스틱서치 인덱스는 물리적으로 분산된 엘라스틱서치 샤드를 논리적인 관점에서 하나의 거대한 데이터로 보는 것이다. 

![enter image description here](https://cdn-images-1.medium.com/max/1600/1*3xcgM8oZUTSV5ZVEjCRnNA.png)

루씬 인덱스 내부에는 세그먼트라는 특수한 자료구조가 다 존재한다. 루씬 인덱스는 다수의 세그먼트를 이용해 검색을 수행하는데, 세그먼트는 내부적으로 역색인 구조이기 때문에 이를 통해 빠름 검색 결과를 얻을 수 있다. 

물론 샤드가 단순히 루씬 그 자체만은 아니다. 샤드 내부적으로 엘라스틱서치에서 추가한 다양한 기능을 포함하고 있기 때문이다. 하지만 그 본질이 루씬 인덱스임은 변함이 없다. 결론적으로 하나의 샤드는 자체적으로 데이터를 색인하고 검색할 수 있는 가장 작은 단위의 단일 검색엔진이라고도 할 수 있다. 

엘라스틱 서치는 독립적인 루씬 인덱스를 엘라스틱 서치의 샤드라는 형태로 확장해서 제공한다. 루씬 인덱스가 자기자신이 가지고 있는 세그먼트 내에서만 검색이 가능한 것과는 달리 샤드는 모든 샤드가 가지고 있는 세그먼트를 논리적으로 통합해서 검색할 수 있다. 

분산 시스템 특성상 시스템의 고가용성을 보장하기 위해 다수의 샤드와 레플리카를 하나로 묶어서 클러스터를 구성하고 일련의 과정은 사용자에게 철저히 숨긴다.

세그먼트
: 루씬 내부에 존재하는 자료구조로, 역색인 구조로 생성되어 읽기에 최적화되어 있다. 하나의 루씬 내부에서만 존재하며 확장이 불가능하다.

루씬 인덱스
: 검색과 색인 기능을 가진 최소한의 검색엔진이다.  IndexWriter와 IndexSearcher를 이용해 작업을 수행하며, 자신이 가진 세그먼트만 작업 대상으로 삼을 수 있다.

엘라스틱서치 샤드
: 엘라스틱서치에서 제공하는 가장 작은 단위 검색엔진. 내부적으로 루씬을 확장해서 검색엔진 역할을 수행한다. 다수의 샤드가 협력해서 존재하는 모든 세그먼트를 검색할 수 있다. 

루씬 인덱스의 경우 데이터를 저장할때 내부에 가지고 있는 세그먼트로만 처리가 가능했다. 엘라스틱서치 샤드는 이러한 한계를 넘어 데이터를 무한대로 확장할 수 있게 해준다. 

서비스를 운영하다보면 시간이 지남에 따라 데이터 크기에 점점 더 커지고 그에 비례해서 성능상의 문제가 발생할 가능성 또한 커진다. 클러스터에 저장된 데이터가 많이질수록 문제가 발생했을때 이를 해결하는 것도 어려워진다. 

클러스터의 성능 문제가 발생하면 샤드 수에 대해 고민을 다시 하게 되는데 말했듯이 **샤드 수는 운영중에 변경이 불가능하다.** 그러므로 맨 처음으로 인덱스를 설계할때 데이터 크기에 대해 충분한 고민을 하고 그에 따라 샤드의 수를 신중하게 결정해야 한다.

# 근실시간 검색(near real time)

엘라스틱서치는 처음부터 근실시간(Near Real Time) 검색을 제공하는 것을 목표로 개발되었다. 어떻게 실시간에 가까운 검색이 제공될 수 있을까? 

## 색인 작업시 세그먼트의 기본 동작

하나의 루씬 인덱스는 다수의 세그먼트로 구성되어 있다. 읽기 성능이 중요한 검색 엔진에서는 하나의 세그먼트로 검색 요청을 처리하는 것 보다 다수의 세그먼트를 생성해 나누어 처리하는 것이 훨씬 효율적이다. 

![enter image description here](https://www.programmersought.com/images/409/1c42be389219e95a5327a096c31c59a1.png)

루씬은 검색 요청을 받으면 다수의 작은 세그먼트 조각들이 각 검색 결과를 만들어내고 이를 통합해서 결과로 응답한다. 이러한 **검색 방식을 세그먼트 단위 검색(Per-Segment Search)** 라고 한다. (초록색 DB모형이 세그먼트) 세그먼트는 역색인 구조를 지닌 파일 자체를 의미하는데 세그먼트 내부에는 실제로 색인덴 데이터가 역색인 구조로 저장되어 있다.

루씬에는 세그먼트를 관리하기 위한 용도로 커밋 포인트(Commit Point)라는 자료구조를 제공한다. 커밋 포인트는 여러 세그먼트의 목록 정보를 가지고 있으며, 검색 요청시 이를 적극 활용 한다. 루씬의 IndexSearcher는 검색 요청시 커밋 포인트를 이용해 가장 오래된 세그먼트 부터 차례대로 검색한 후에 각 결과를 하나로 합친다. 

최초 색인 작업 요청이 루씬에 들어오면 IndexWriter로 색인 작업이 이루어지고 결과물로 하나의 세그먼트가 생성된다. 그 후 추가 색인 작업이 요청될때마다 새그러 세그먼트가 추가되고 커밋 포인트에 기록된다. 색인 작업이 일어날때 마다 이런식으로 세그먼트의 개수는 늘어난다. 

검색 작업 요청시 IndexSearcher가 커밋 포인트를 활용해 모든 세그먼트를 읽고 검색 결과를 제공한다. 이때 존재하는 모든 세그먼트를 검색하기 때문에 데이터의 누락은 문제가 없다. 

세그먼트의 갯수가 너무 많아지면 읽기의 성능 저하가 생길수 있기 때문에 이를 위해 루씬은 백그라운드에서 주기적으로 세그먼트 파일을 병합(Merge)하는 작업을 수행한다. 이를 통해 모든 세그먼트를 물리적으로 하나의 파일로 병합한다. 

정책에 따라 몇개의 세그먼트가 순차적으로 선택되어 합쳐지고, 일정 시간이 흘러 더 색인 작업이 없는 상태가 되면 하나의 큰 세그먼트만 남는다. 

![enter image description here](https://www.bloghome.com.cn/content/images/2019/05/segment-merging-bw-1.png)

루씬은 역색인 구조로 세그먼트를 만든다 기본적으로 한번 디스크에 저장된 세그먼트는 수정이 불가능하게 관리된다. 예외적으로 주기적인 병합 작업을 제외하고는 절대 수정을 허용하지 않는다. 이렇기 때문에 색인 작업이 수행될때마다 새로운 세그먼트가 생성될수 밖에 없는 구조이다. 

루씬에 요청이 들어왔을때 상황에 따라 동작하는 방식

 최초 색인 요청
 1. IndexWriter가 세그먼트를 생성
 2. IndexSearcher가 생성된 세그먼트를 읽어 검색 제공 

추가 색인 요청
 1. IndexWriter가 세그먼트를 추가 생성
 2. 세그먼트가 추가 생성되는 동안 기존 세그먼트만 읽어 검색 결과 제공
 3. 세그먼트 생성이 완료되면 생성된 세그먼트도 마저 읽어 결과 제공

주기적 세그먼트 병합 작업

 1. IndexWriter가 Merge 대상이 되는 세그먼트를 복제
 2.  IndexWriter가 복제한 세그먼트를 하나로 병합
 3. 복제 세그먼트들이 병합되는 동안 IndexSearcher는 원본 세그먼트를 읽어 검색 수행
 4. 복제본 세그먼트의 병합이 완료되면 원본 세그먼트와 교체하고 원본 세그먼트 삭제
 5. IndexSearcher는 새로운 세그먼트를 읽어 검색 결과 제공

## 세그먼트 불변성

세그먼트의 불변성은 루씬의 입장에서는 매우 중요한 특성이다. 주로 대용량 텍스트를 다루어야 하는 역색인 구조에서는 불변성이 제공하는 여러 장점이 있다. 

>동시성 문제 회피
>불변성이 보장되면 잠금(Lock)이 필요 없어진다. 다수의 쓰레드가 동작하는 다중 쓰레드 환경에서 동시성 문제를 불변성이 보장되면 간단히 피해갈 수 있다.

>시스템 캐시 적극적 활용 가능
>데이터가 OS 커널에서 제공하는 시스템 캐시에 생성되면 일정 시간동안은 그대로 유지된다. 불변성을 보장하지 않으면 데이터가 변경될때 마다 캐시를 수정해야 하는데, 이는 매우 큰 비용이므로 최대한 지양해야한다.

>높은 캐시 적중률(Hit ratio)
>시스템 캐시의 수명이 길어져 검색 시 데이터를 항상 메모리에서 읽어와 큰 성능향상을 꾀할 수 있다.

>리소스 절감
>역색인 구조를 만드는 과정에서 많은 시스템 리소스(가 사용된다.




> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYyNjgzNDU1NCwtMTE5OTgyMTYwOSwtMz
EwODQyNjY4LDE2OTQ5NTQwOSwxNjM2NzI4NDg0LDEwMjg2Mzk0
OTAsLTExODkxNjQzNywtMTgzOTU1MDcyNywyNzY5NzA4NzksLT
kyODM0NDQ0NSw5MTc5MDE0NjMsMTA5MDY0ODU4MCwtMTIwMjE3
MDY4NCwtMTE3ODAzMTQ1MSwtMTY5ODU3MDEzMiwtODgyOTEyOD
Q2LC0zOTk5MzkyNjEsMTkwNjc5NDYyNCwtODI0NTI1NjA2LC0x
MjM0NTIyMjE5XX0=
-->