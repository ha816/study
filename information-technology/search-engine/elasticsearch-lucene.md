# Overview

엘라스틱서치는 내부적으로 루씬을 통해 검색기능을 수행한다. 루씬의 동작 과정은 고도로 추상화되어 제공되기 때문에 사용자들은 루씬의 존재를 눈치채지 못할 수도 있다. 하지만 루씬의 세부적인 동작 원리를 이해하고 나면 엘라스틱 서치를 이해하는데 큰 도움이 된다. 이번 장에서는 루씬 라이브러리에 대해 알아보자

# 클러스터 관점에서 구성요소 

엘라스틱서치는 기본적으로 클러스터란 단위로 데이터를 제공한다. 클러스터는 하나 이상의 물리적인 노드로 구성되며 각 노드는 모두 데이터 색인 및 검색 기능을 제공하는 일종의 물리적 서버이기도 하다. 즉 노드는 물리적 서버를 뜻하며 다수의 서버가 모여 하나의 클러스터를 구성한다. 

엘라스틱 서치의 최상위 개념인 클러스터로 부터 최하위 개념인 세그먼트까지 하향식으로 살펴보도록 하자.

## 클러스터 

클러스터는 노드(물리적 서버)들의 집합이다. 같은 클러스터 내부의 데이터민 서로 공유가 가능하기 때문에 연관된 노드들끼리 하나의 클러스터로 구성하는 것이 매우 중요하다. 

같은 클러스토로 묶일 노드들은 같은 반드시 같은 클러스터 이름을 가져야 한다. (엘라스틱서치는 이름으로 같은 클러스터인지 아닌지 판별한다)

같은 클러스터에 속한 노드들은 평소 데이터 색인이나 검색 작업을 함께 수행하게 되고 장애가 발생했을때도 데이터 복구를 위해 서로 협력해서 복구한다.

>Cross Cluster Search
>실무에서 업무를 하다보면 데이터 성격에 따라 다수의 클러스터를 운영하게 된다. 데이터가 커지고 복잡해지면 필연적으로 다수의 클러스터를 함께 검색해야하는 일도 빈번히 발생한다.
>엘라스틱서치에서는 이처럼 다양한 필요에의해서 다수의 클러스터를 한번에 검색할 수 있는 기능을 제공하는데 그것이 Cross Cluster search다. 

## 노드(Node)

실행 중인 엘라스틱 서치를 노드라고 부른다. 좀더 정확하게는 다수의 물리 서버에 엘라스틱 서치를 설치하고 실행된 엘라스틱서치 인스턴스를 노드라고 한다.

노드는 클러스터를 이루는 구성원이며 실제 데이터를 가지고 있는 단일 서버이기도 하다. 실행 시 노드는 클러스터에 의해  UUID(Universally Unique IDentifier)가 할당되고 클러스터 내에서는 할당된 UUID로 서로를 식별한다. 기본값으로 부여되는 UUID를 원치 않는다면 직접 이름도 설정할 수 있다. 같은 클러스터 내부에서 유일한 노드를 식별하는 것은 매우 중요하기 때문에 신중해질 필요가 있다. 

같은 클러스터 내부에 존재하는 모든 노드는 서로 다른 노드와 수시로 정보를 주고 받는다. 기본적으로 모든 노드는 마스터 노드와 데이터 노드의 역할을 동시에 수행하도록 설정되어 있는데, 실제 운영에서는 역할에 따라 노드를 구분하는 것이 좋다. 

특히 마스터 노드의 경우, 클러스터 전체를 제어하기 때문에 물리적으로 분리해서 독립적으로 운영하는 것이 좋다.

## 인덱스(Index)

인덱스는 유사한 특성을 가지고 있는 문서들을 모은 컬렉션이다. 클러스터 내부에 생성되는 모든 인덱스는 클러스터 내에서 유일한 인덱스명을 가져야 한다. 이 인덱스 이름을 통해서 데이터 생성, 수정, 삭제, 검색이 이루어지기 때문에 매우 중요하다. 참고로 인덱스 명은 반드시 소문자로 만들어야 한다. 엘라스틱 서치에서 강제하는 사항이므로 반드시 지켜야 한다.

## 문서(Document)

문서는 검색 대상이 되는 실제 물리적인 데이터를 말한다. 문서는 인덱스를 생성할 수 있는 기본적인 정보 단위이고 JSON 형식으로 표현된다. 인덱스에 원하는 만큼 많은 문서를 저장할 수 있고 실제로는 샤드 형태로 나누어져 다수의 노드로 분산 저장된다.

## 샤드(Shard)

인덱스에서는 엄청나게 많은 문서가 저장될 수 있다. 하나의 하드웨어에서 제공하는 리소스의 물리적인 한계를 넘기 위해 도입한 개념이 바로 샤드이다. 이를 이용하면 데이터를 분삭 저장할때 손쉽게 수평확장이 가능해진다. 

샤드는 인덱스 전체 문서 데이터의 부분 집합으로 이해하면된다. 부분집합이지만 갹 샤드는 자신이 가지고 있는 데이터만으로도 독립적으로 검색 서비스가 가능하다. 

실제로 인덱스에 쿼리를 요청하면 인덱스가 가지고 있는 모든 샤드로 검색 요청이 전달되고 각 샤드에서 1차적인 검색이 이뤄진 후 그 결과를 취합해서 최종 결과로 제공한다. 인덱스가 샤드로 분산되는 과정이나 검색 요청이 각 샤드에 분산되어 처리되는 복잡한 프로세스는 사용자에게 완벽하게 블랙박스이다. 

>샤딩이 중요한 이유
>지속적으로 증가하는 컨텐츠가 수평적으로 분할되어 하드웨어의 한계를 극복할 수 있다.
>여러 노드에서 샤드를 통해 분산 처리되므로 성능이나 처리량을 향상 시킬 수 있다.

## 레플리카

샤드의 복제본을 레플리카 (Replica)라고 한다. 엘라스틱 서치에서는 인덱스를 생성할때 기본적으로 1개의 레플리카 세트를 생성한다. 검색 시 레플리카가 적극적으로 활용되기 때문에 이를 이용하면 일기 분산이 유리해진다. 

수평적으로 분산된 시스템을 운영할때는 언제든 장애가 나타날 수 있다. 네트워크 특성상 특정 노드가 오프라인으로 변경될 경우 페일오버(Failover) 메커니즘을 적극적으로 활용하는 것이 좋은데 엘라스틱서치에서는 레플리카를 이용한 페일오버 메커니즘을 제공하고 있고 이를 이용해 안정적인 클러스터 운영을 보장한다. 

인덱스가 생성될 때 샤드 개수와 레플리카 개수를 자유롭게 설정할 수 있다.하지만 인덱스가 생성된 이후에는 샤드 개수를 변경하는 것이 불가능하기 때문에 이 점에 유의하자. 그에 반해 레플리카의 갯수는 인덱스를 생성한 이후에도 자유롭게 변경하는 것이 가능하다. 그렇게 때문에 운영 중 트래픽 증가에 대한 유연한 대응이 가능해진다. 이는 검색 엔진의 특성상 읽기 연산이 대부분이기 때문에 매우 유용한 기능이다.

>엘라스틱 서치의 고가용성
>엘라스틱서치에서는 샤드나 노드에 장애가 발생할 경우, 즉각적인 복구가 가능하기 때문에 안정적인 클러스터 운영이 가능해진다. 페일오버 메커니즘을 송공적으로 구현하기 위해 레플리카는 기본적으로 원본 샤드가 존재하지 노드에서 생성된다. 또한 검색 시 샤드와 레플리카에서 병렬로 실행될 수 있기 때문에 검색 성능이 좋아진다.

## 세그먼트

문서들은 빠른 검섹에 유리하도록 설계된 특수한 자료구조로 저장된다. 샤브 내부에 루씬 라이브러리를 포함하고 있는데, 이를 통해 대부분의 검색 기능을 제공한다. 루씬에 데이터가 색인되면 데이터는 최소의 단위인 토큰으로 분리되고 토큰은 특수한 형태의 자료구조로 저장되는데, 이를 세그먼트라 한다. 

세그먼트는 읽기에 최적화된 자료구조로이다. 

# 엘라스틱서치 샤드 VS 루씬 인덱스

루씬은 다수의 클래스로 구성되어 있는 검색 라이브러리이고, 이 중에서 가장 중요한 클래스가 바로 IndexWriter와 IndexSearcher이다. 간단히 설명하자면 IndexWriter는 데이터를 색인하는 클래스이고, IndexSearcher는 색인된 데이터를 검색 결과로 제공하는 클래스다. 사실 이 두개의 클래스가 루씬의 핵심이라고 해도 과언이 아니다. 

IndexWriter와 IndexSearcher를 가지고 색인과 검색을 동시에 제공하는 루씬 인스턴스를 루씬 인덱스라고 하는데, 사실 하나의 엘라스틱서치 샤드는 하나의 루씬 인덱스라고 설명할 수 있다. 우리가 알고 있는 엘라스틱서치 인덱스는 물리적으로 분산된 엘라스틱서치 샤드를 논리적인 관점에서 하나의 거대한 데이터로 보는 것이다. 

![enter image description here](https://cdn-images-1.medium.com/max/1600/1*3xcgM8oZUTSV5ZVEjCRnNA.png)

루씬 인덱스 내부에는 세그먼트라는 특수한 자료구조가 다 존재한다. 루씬 인덱스는 다수의 세그먼트를 이용해 검색을 수행하는데, 세그먼트는 내부적으로 역색인 구조이기 때문에 이를 통해 빠름 검색 결과를 얻을 수 있다. 

물론 샤드가 단순히 루씬 그 자체만은 아니다. 샤드 내부적으로 엘라스틱서치에서 추가한 다양한 기능을 포함하고 있기 때문이다. 하지만 그 본질이 루씬 인덱스임은 변함이 없다. 결론적으로 하나의 샤드는 자체적으로 데이터를 색인하고 검색할 수 있는 가장 작은 단위의 단일 검색엔진이라고도 할 수 있다. 

엘라스틱 서치는 독립적인 루씬 인덱스를 엘라스틱 서치의 샤드라는 형태로 확장해서 제공한다. 루씬 인덱스가 자기자신이 가지고 있는 세그먼트 내에서만 검색이 가능한 것과는 달리 샤드는 모든 샤드가 가지고 있는 세그먼트를 논리적으로 통합해서 검색할 수 있다. 

분산 시스템 특성상 시스템의 고가용성을 보장하기 위해 다수의 샤드와 레플리카를 하나로 묶어서 클러스터를 구성하고 일련의 과정은 사용자에게 철저히 숨긴다.

세그먼트
: 루씬 내부에 존재하는 자료구조로, 역색인 구조로 생성되어 읽기에 최적화되어 있다. 하나의 루씬 내부에서만 존재하며 확장이 불가능하다.

루씬 인덱스
: 검색과 색인 기능을 가진 최소한의 검색엔진이다.  IndexWriter와 IndexSearcher를 이용해 작업을 수행하며, 자신이 가진 세그먼트만 작업 대상으로 삼을 수 있다.

엘라스틱서치 샤드
: 엘라스틱서치에서 제공하는 가장 작은 단위 검색엔진. 내부적으로 루씬을 확장해서 검색엔진 역할을 수행한다. 다수의 샤드가 협력해서 존재하는 모든 세그먼트를 검색할 수 있다. 

루씬 인덱스의 경우 데이터를 저장할때 내부에 가지고 있는 세그먼트로만 처리가 가능했다. 엘라스틱서치 샤드는 이러한 한계를 넘어 데이터를 무한대로 확장할 수 있게 해준다. 

서비스를 운영하다보면 시간이 지남에 따라 데이터 크기에 점점 더 커지고 그에 비례해서 성능상의 문제가 발생할 가능성 또한 커진다. 클러스터에 저장된 데이터가 많이질수록 문제가 발생했을때 이를 해결하는 것도 어려워진다. 

클러스터의 성능 문제가 발생하면 샤드 수에 대해 고민을 다시 하게 되는데 말했듯이 **샤드 수는 운영중에 변경이 불가능하다.** 그러므로 맨 처음으로 인덱스를 설계할때 데이터 크기에 대해 충분한 고민을 하고 그에 따라 샤드의 수를 신중하게 결정해야 한다.

# 근실시간 검색(near real time)

엘라스틱서치는 처음부터 근실시간(Near Real Time) 검색을 제공하는 것을 목표로 개발되었다. 어떻게 실시간에 가까운 검색이 제공될 수 있을까? 

## 색인 작업시 세그먼트의 기본 동작

하나의 루씬 인덱스는 다수의 세그먼트로 구성되어 있다. 읽기 성능이 중요한 검색 엔진에서는 하나의 세그먼트로 검색 요청을 처리하는 것 보다 다수의 세그먼트를 생성해 나누어 처리하는 것이 훨씬 효율적이다. 

![enter image description here](https://www.programmersought.com/images/409/1c42be389219e95a5327a096c31c59a1.png)

루씬은 검색 요청을 받으면 다수의 작은 세그먼트 조각들이 각 검색 결과를 만들어내고 이를 통합해서 결과로 응답한다. 이러한 **검색 방식을 세그먼트 단위 검색(Per-Segment Search)** 라고 한다. (초록색 DB모형이 세그먼트) 세그먼트는 역색인 구조를 지닌 파일 자체를 의미하는데 세그먼트 내부에는 실제로 색인덴 데이터가 역색인 구조로 저장되어 있다.

루씬에는 세그먼트를 관리하기 위한 용도로 커밋 포인트(Commit Point)라는 자료구조를 제공한다. 커밋 포인트는 여러 세그먼트의 목록 정보를 가지고 있으며, 검색 요청시 이를 적극 활용 한다. 루씬의 IndexSearcher는 검색 요청시 커밋 포인트를 이용해 가장 오래된 세그먼트 부터 차례대로 검색한 후에 각 결과를 하나로 합친다. 

최초 색인 작업 요청이 루씬에 들어오면 IndexWriter로 색인 작업이 이루어지고 결과물로 하나의 세그먼트가 생성된다. 그 후 추가 색인 작업이 요청될때마다 새그러 세그먼트가 추가되고 커밋 포인트에 기록된다. 색인 작업이 일어날때 마다 이런식으로 세그먼트의 개수는 늘어난다. 

검색 작업 요청시 IndexSearcher가 커밋 포인트를 활용해 모든 세그먼트를 읽고 검색 결과를 제공한다. 이때 존재하는 모든 세그먼트를 검색하기 때문에 데이터의 누락은 문제가 없다. 

세그먼트의 갯수가 너무 많아지면 읽기의 성능 저하가 생길수 있기 때문에 이를 위해 루씬은 백그라운드에서 주기적으로 세그먼트 파일을 병합(Merge)하는 작업을 수행한다. 이를 통해 모든 세그먼트를 물리적으로 하나의 파일로 병합한다. 

정책에 따라 몇개의 세그먼트가 순차적으로 선택되어 합쳐지고, 일정 시간이 흘러 더 색인 작업이 없는 상태가 되면 하나의 큰 세그먼트만 남는다. 

![enter image description here](https://www.bloghome.com.cn/content/images/2019/05/segment-merging-bw-1.png)

루씬은 역색인 구조로 세그먼트를 만든다 기본적으로 한번 디스크에 저장된 세그먼트는 수정이 불가능하게 관리된다. 예외적으로 주기적인 병합 작업을 제외하고는 절대 수정을 허용하지 않는다. 이렇기 때문에 색인 작업이 수행될때마다 새로운 세그먼트가 생성될수 밖에 없는 구조이다. 

루씬에 요청이 들어왔을때 상황에 따라 동작하는 방식

 최초 색인 요청
 1. IndexWriter가 세그먼트를 생성
 2. IndexSearcher가 생성된 세그먼트를 읽어 검색 제공 

추가 색인 요청
 1. IndexWriter가 세그먼트를 추가 생성
 2. 세그먼트가 추가 생성되는 동안 기존 세그먼트만 읽어 검색 결과 제공
 3. 세그먼트 생성이 완료되면 생성된 세그먼트도 마저 읽어 결과 제공

주기적 세그먼트 병합 작업

 1. IndexWriter가 Merge 대상이 되는 세그먼트를 복제
 2.  IndexWriter가 복제한 세그먼트를 하나로 병합
 3. 복제 세그먼트들이 병합되는 동안 IndexSearcher는 원본 세그먼트를 읽어 검색 수행
 4. 복제본 세그먼트의 병합이 완료되면 원본 세그먼트와 교체하고 원본 세그먼트 삭제
 5. IndexSearcher는 새로운 세그먼트를 읽어 검색 결과 제공

## 세그먼트 불변성

세그먼트의 불변성은 루씬의 입장에서는 매우 중요한 특성이다. 주로 대용량 텍스트를 다루어야 하는 역색인 구조에서는 불변성이 제공하는 여러 장점이 있다. 

>동시성 문제 회피
>불변성이 보장되면 잠금(Lock)이 필요 없어진다. 다수의 쓰레드가 동작하는 다중 쓰레드 환경에서 동시성 문제를 불변성이 보장되면 간단히 피해갈 수 있다.

>시스템 캐시 적극적 활용 가능
>데이터가 OS 커널에서 제공하는 시스템 캐시에 생성되면 일정 시간동안은 그대로 유지된다. 불변성을 보장하지 않으면 데이터가 변경될때 마다 캐시를 수정해야 하는데, 이는 매우 큰 비용이므로 최대한 지양해야한다.

>높은 캐시 적중률(Hit ratio)
>시스템 캐시의 수명이 길어져 검색 시 데이터를 항상 메모리에서 읽어와 큰 성능향상을 꾀할 수 있다.

>리소스 절감
>역색인 구조를 만드는 과정에서 많은 시스템 리소스(Cpu, 메모리 I/O)가 사용된다. 수정을 허용하게 되면 일부가 변경되는 해당 역색인을 대상으로 수정 작업을 해야하기 때문에 리소스를 크게 잡아 먹는다.


읽기 연산이 대다수 작업인 검색 엔진의 특성상 캐시 성능을 최대한 활용하고 동시성 문제를 피할 수 있는 불변성은 최고의 효율을 보여주고 있는 것이 증명되었다.

물론 세그먼트 불변성도 단점은 있다. 가장 큰 문제는 일부 데이터가 변경되더라도 전체 역색인 구조가 다시 만들어져야 한다는 것이다. 또 다른 문제점은 실시간 반영이 상대적으로 어려워 진다. 변경사항을 반영 하려면 역색인을 새로 만들어야 하는데 변경이 매우 빠르게 자주 일어난다면 실시간 반영 자체가 불가능해진다.

이러한 단점을 극복하기 위해 루씬에서는 크기가 작은 다수의 세그먼트를 생성해서 제공하는 방식을 택했다. 즉 변경이 일어날때마다 세그먼트를 다시 만드는 것이 아니라 기존 세그먼트는 그대로 두고 추가로 세그먼트를 생성하는 것이다. 

세그먼트의 불변성은 확실히 단점보다는 장점이 많다. 읽기 연산 비중이 큰 루씬에서는 세그먼트가 불변성을 가짐으로써 읽기 연산의 성능을 대폭 끌어올릴 수 있었다. 

### 세그먼트 추가, 수정, 삭제

색인 작업의 상당수는 데이터가 추가되는 연산이다. 새로운 세그먼트를 가져가는 전략으로 불변성을 깨지 않으면서도 그리 나쁘지 않은 성능을 보장한다.

수정 연산의 경우, 세그먼트의 불변성 때문에 데이터를 삭제하고 다시 추가하는 방식으로 동작한다. 기존 데이터는 삭제 처리되어 검색 대상에서 제외되고 변경된 데이터는 새로운 세그먼트로 추가되어 검색대상에 포함된다.

삭제 연산의 경우, 단순히 데이터를 삭제하는 것이 아니다. 사실 모든 문서에는 삭제 여부를 표시하는 비트 배열이 내부적으로 존재한다. 삭제 요청이 들어오면 삭제될 대상 데이터의 비트 배열을 찾아 삭제 여부만 표시하고 끝낸다. 비트에 표시만 했기 때문에 여전히 세그먼트는 남아 았다. 하지만 검색시 비트배열에 설정된 삭제 여부를 항상 먼저 판단하기 때문에 불변성을 훼손하지 않고도 빠르게 검색대상에서 제외할 수 있다. 

루씬에 데이터 수정 작업이 요청되면 IndexWriter는 다음과 같이 동작한다. 

세그먼트에서 일부 데이터가 삭제될 경우
1. 루씬은 삭제될 데이터가 포함된 세그먼트의 삭제 여부 비트 배열을 확인한다.
2. 삭제 여부 비트 배열의 flag를 삭제로 표시한다.
3. 세그먼트에 직접적인 변경사항은 없으므로 세그먼트의 불변성을 해치지 않으며 캐시도 그대로 유지된다. 
4. IndexSearcher는 검색 작업시 삭제 여부 비트 배열을 항상 먼저 확인하고 체크된 데이터를 검색결과에서 제외한다.

세그먼트에서 일부 데이터가 수정될 경우

1. 앞의 작업(세그먼트에서 일부 데이터가 삭제될 경우)으로 삭제 처리를 먼저 수행한다.
2. 수정된 데이터를 새로운 세그먼트로 생성한다.
3. IndexSearcher는 모든 세그먼트를 읽어 검색결과를 제공한다.

그렇다면 삭제될 데이터가 물리적으로 실제 삭제되는 시점은 언제일까? 백그라운드에서 주기적으로 일어나는 Merge 작업이 수행될대 삭제가 된다. 루씬이 삭제 데이터를 바로 삭제하지 않고 병합 작업시 삭제를 하는 이유는 세그머트가 가지는 역색인 구조와 관련이 깊다. 

일반적인 역색인 구조는 색인 대상이 되는 문서를 최소단위인 텀 단우의 단어로 분리하고 역색인 구조에 따라 정렬한 뒤 저장한다. 문서 하나를 제거하려면 전체 역색인 구조를 찾아 관련된 모든 텀을 제거해야 하기 때문에 사실 세그먼트를 다시 생성하는 것과 별반 다를바가 없저진다. 그래서 즉시 삭제하는 것이 아니라 주기적으로 세그먼가 재 생성되는 작업에서 물리적인 삭제를 함께 한다. 

# 루씬을 위한  Flush, Commit, Merge

루씬은 효율적인 색인 작업을 위해 내부적으로 일정 크기의 버퍼를 가지고 있다. 이러한 버퍼를 인메모리 버퍼(In-memory buffer)라고 한다. 그리고 루씬에서 인메모리 버퍼 기반의 처리과정을  Flush라 부른다.

루씬에 색인 작업이 요청되면 전달된 데이터는 일단 인메모리 버퍼에 순서대로 쌓인다. 그리고 나서 정책에 따라 인메모리 버퍼에 순서대로 쌓인다. 그리고 나서 정책에 따라 내부 버퍼에 일정 크기 이상 데이터가 쌓이거나 일정 시간이 지나면 버퍼에 쌓인 데이터를 모아 한꺼번에 처리한다. 버퍼를 일종의 큐로 활용하는 것이다. 

![enter image description here](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTLuitG_woohDKnKKdYe90ayzNwf80eG2k_1ba9b1y_Qlg561tK&usqp=CAU)

버퍼에 모여 한꺼번에 처리된 데이터는 세그먼트 형태로 생성되고 즉시 디스크로 동기화 된다. 하지만 디스크에 물리적으로 동기화하는 일련의 과정은 운여에제 입장에서는 매우 비용이 큰 연산이기 때문에 세그먼트가 생성될때마다 물리적인 동기화를 할 경우 성능이 급격히 나빠질 수 있다. 

루씬은 이러한 문제를 해결하기 위해 무거운 fsync방식을 쓰는 대신에 상대적으로 가벼운 write방식으로 쓰기과정을 수행한다. 

write()
: 일반적으로 파일을 저장할 때 사용하는 함수다. 운영체제 내부 커널에는 시스템 캐시가 존재하는데 write함수를 이용하면 일단 시스템 캐시에만 기록된다. 이후 실제 데이터는 특정 주기로 물리 디스크에 기록된다. 물리적인 디스크 쓰기 작업을 하지 않기 때문에 빠르지만 시스템이 비정상 종료될 경우에는 데이터 유실이 발생할 수 있다.

fsync()
: 저수준의 파일 입출력 함수다. 내부 시스템 캐시의 데이터와 물리적인 디스크 데이터를 동기화하기 위한 목적으로 사용된다. 실제 물리적인 디스크로 쓰는 작업을 수행하기 때문에 상대적으로 많은 리소스가 사용된다.

ReOpen() -> openIfChanged()
: 루씬에서는 IndexSearcher가 일단 생성되고 나면 이후 변경된 사항들을 기본적으로 인지 못한다. 물론 기존 IndexSearcher를 닫고 다시 만들면 되겠지만 문서의 추가나 변경이 빈번히 일어날 경우 많은 리소스가 필요해지기 때문에 권장하지 않는다. 이때 사용할 수 있는것이  ReOpen()이다. 일정 주기마다 문서가 변경된다면 이 함수를 써서 더 효율적으로 리소스를 사용할 수 있다. 루씬 3.5부터는 deprecated되었으며 openIfChanged()를 쓰도록 하자.

데이터의 변경 사항을 일단 버퍼에 모아두고 일정 주기에 한번씩 새그먼트를 생성하고 상대적으로 적응 비용으로 디스크에 동기화까지 수행하는 것이다. 일단 Flush 처리에 의해 세그먼트가 생성되면 커널 시스템 캐시에 세그먼트가 캐시되어 읽기가 가능해진다. 커널 시스템 캐시에 캐시가 생성되면 루씬의 ReOpen()함수로 IndexSearcher에서도 읽을 수 있는 상태가 된다.

루씬에서는 물리적으로 실제 디스크에 기록을 하는 fsync함수를 호출하는 작업을 Commit이라고 한다. Flush라는 단계가 존재하기 때문에 매번 Commit을 수행할 필요가 없어 보이지만 일정 주기로 Commit 작업을 통해 물리적인 디스크로 기록 작업을 수행해야 한다는 사실을 잊으면 안된다. 


세그먼트는 불변성을 기반으로 설계되었고, 이러한 불변성이 지닌 이점은 충분하다. 하지만 불변성을 유지하기 위해 루씬의 동작 방식은 다소 복잡해졌다. 불변성 유지를 위해 세그먼트 단위 검색(Per-Segment Search)을 제공하지만 시간이 흐를 수록 세그먼트의 개수가 늘어날 수 밖에 없고 이를 지원하기 위한 커밋 포인트 부하도 증가한다. 그래서 다수의 세그먼트를 하나로 합치는 자업이 필요하다. 이 작업이 Merge 작업이다. 

병합 작업을 하면, 세그먼트의 수가 줄어들기 때문에 검색 횟수가 줄어들어 검색 성능이 좋아진다. 마찬가지로 수가 줄기 때문에 세그먼트가 차지하는 디스크 용량이 줄어든다. 삭제되는 문서의 경우 병합 작업 전에는 디스크에 물리적으로 남아 있다. 하지만 병합 작업으로 새로운 새그먼트를 생성하면 디스크에서 삭제가 되고 공간 절약이 가능해진다.

병합 정렬은 Commit작업을 반드시 동반해야 하는데, Commit작업은 매우 비용이 많이 든다. 따라서 정책적으로 적절한 주기를 설정하는 것이 매우 중요하다. 전체적인 성능 향상을 위해 루씬은 자동 주기로 세그먼트의 병합 작업을 수행한다. 작업 주기는 최적의 성능을 낼수있도록 설정되며 백그라운드로 수행된다. 

>루씬 Flush
>세그먼트가 생성된 후 검색이 가능해지도록 수행하는 작업
>write() 함수로 동기화가 수행됬기 때문에 커널 시스템 캐시에만 데이터가 생성된다. 이를 통해 유저 모드에서 파일을 열어서 사용하는 것이 가능해 진다.
>물리적으로 디스크에 쓰여진 상태는 아니다. 

>루씬 Commit
>커널 시스템 캐시의 내용을 물리적인 디스크에 쓰는 작업
>실제 물리적인 디스크에 기록되기 때문에 많은 리소스가 필요하다.

>루씬 Merge 
>다수의 세그먼트를 하나로 통합하는 작업
>Merge 과정을 통해 삭제 처리된 데이터가 실제 물리적 디스크에서도 삭제 된다.
>검색할 세그먼트의 개수가 줄어들기 때문에 검색 성능이 좋아진다.

# 엘라스틱서치를 위한 Refresh, Flush, Optimize API

엘라스틱서치 샤드는 사실상 루씬 인덱스의 확장이고 세그먼트 기반의 내부 동작을 그대로 검색에 활용한다. 엘라스틱서치는 다수의 샤드로 데이터가 분산 저장되어 있고 모든 샤드가 협력해 데이터 검색을 한다. 

엘라스틱서치는 사실 내부에 루씬 인덱스가 가지는 기능을 확장해서 API로 제공한다. 그렇게 때문에 루씬의 파라미터들을 튜닝하면 엘라스틱서치에서도 그에 사응하는 성능상의 이점을 얻을 수 있다. 대표적인 튜닝 포인트인 Flush, Commit, Merge 작업 또한 확장되어 API로 제공된다. 하지만 루씬의 작업을 엘라스틱서치에서는 전혀 다른 명칭으로 부르고 있기 때문에 주의해야 한다.

|루씬 |엘라스틱서치|
|--|--|
|Flush  |  Refresh|
|Commit  | Flush|
|Merge  |  Optimize API|

단일 검색 엔진을 표방하는 루씬과는 다르게 고가용성이 보장되어야 하는 분산 검색엔진인 엘라스틱 서치의 경우 루씬 보다 고려해야 할 사항이 훨씬 더 많다. 분산 시스템의 특성상



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTE2MDIwMjgyLC0xNDI2ODIzNDkwLDEyMj
E0NjI4NDMsMTcyMzA1NDA5LDE3ODc4NzExNzUsMTg2NjA1MzU4
Niw1MTA4NzI4NDAsLTc0MDEzODgzMywtMTkyMTc0OTg3OCwzOT
kyNDQwODEsLTEyMDMyNjY0NDYsODQ4MDMyOTkyLDQyNzE3ODE4
MSwtMTcyNTkxMjE3LC00MTM5ODE5MjgsLTE3OTU2MjMzNDcsLT
g3Nzk4ODU5Nyw3ODY1ODQyMDQsODgxNzM5MTgwLC02OTgxOTA4
NzddfQ==
-->