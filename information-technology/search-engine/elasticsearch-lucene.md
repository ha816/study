# Overview

엘라스틱서치는 내부적으로 루씬을 통해 검색기능을 수행한다. 루씬의 동작 과정은 고도로 추상화되어 제공되기 때문에 사용자들은 루씬의 존재를 눈치채지 못할 수도 있다. 하지만 루씬의 세부적인 동작 원리를 이해하고 나면 엘라스틱 서치를 이해하는데 큰 도움이 된다. 이번 장에서는 루씬 라이브러리에 대해 알아보자

# 클러스터 관점에서 구성요소 

엘라스틱서치는 기본적으로 클러스터란 단위로 데이터를 제공한다. 클러스터는 하나 이상의 물리적인 노드로 구성되며 각 노드는 모두 데이터 색인 및 검색 기능을 제공하는 일종의 물리적 서버이기도 하다. 즉 노드는 물리적 서버를 뜻하며 다수의 서버가 모여 하나의 클러스터를 구성한다. 

엘라스틱 서치의 최상위 개념인 클러스터로 부터 최하위 개념인 세그먼트까지 하향식으로 살펴보도록 하자.

## 클러스터 

클러스터는 노드(물리적 서버)들의 집합이다. 같은 클러스터 내부의 데이터민 서로 공유가 가능하기 때문에 연관된 노드들끼리 하나의 클러스터로 구성하는 것이 매우 중요하다. 

같은 클러스토로 묶일 노드들은 같은 반드시 같은 클러스터 이름을 가져야 한다. (엘라스틱서치는 이름으로 같은 클러스터인지 아닌지 판별한다)

같은 클러스터에 속한 노드들은 평소 데이터 색인이나 검색 작업을 함께 수행하게 되고 장애가 발생했을때도 데이터 복구를 위해 서로 협력해서 복구한다.

>Cross Cluster Search
>실무에서 업무를 하다보면 데이터 성격에 따라 다수의 클러스터를 운영하게 된다. 데이터가 커지고 복잡해지면 필연적으로 다수의 클러스터를 함께 검색해야하는 일도 빈번히 발생한다.
>엘라스틱서치에서는 이처럼 다양한 필요에의해서 다수의 클러스터를 한번에 검색할 수 있는 기능을 제공하는데 그것이 Cross Cluster search다. 

## 노드(Node)

실행 중인 엘라스틱 서치를 노드라고 부른다. 좀더 정확하게는 다수의 물리 서버에 엘라스틱 서치를 설치하고 실행된 엘라스틱서치 인스턴스를 노드라고 한다.

노드는 클러스터를 이루는 구성원이며 실제 데이터를 가지고 있는 단일 서버이기도 하다. 실행 시 노드는 클러스터에 의해  UUID(Universally Unique IDentifier)가 할당되고 클러스터 내에서는 할당된 UUID로 서로를 식별한다. 기본값으로 부여되는 UUID를 원치 않는다면 직접 이름도 설정할 수 있다. 같은 클러스터 내부에서 유일한 노드를 식별하는 것은 매우 중요하기 때문에 신중해질 필요가 있다. 

같은 클러스터 내부에 존재하는 모든 노드는 서로 다른 노드와 수시로 정보를 주고 받는다. 기본적으로 모든 노드는 마스터 노드와 데이터 노드의 역할을 동시에 수행하도록 설정되어 있는데, 실제 운영에서는 역할에 따라 노드를 구분하는 것이 좋다. 

특히 마스터 노드의 경우, 클러스터 전체를 제어하기 때문에 물리적으로 분리해서 독립적으로 운영하는 것이 좋다.

## 인덱스(Index)

인덱스는 유사한 특성을 가지고 있는 문서들을 모은 컬렉션이다. 클러스터 내부에 생성되는 모든 인덱스는 클러스터 내에서 유일한 인덱스명을 가져야 한다. 이 인덱스 이름을 통해서 데이터 생성, 수정, 삭제, 검색이 이루어지기 때문에 매우 중요하다. 참고로 인덱스 명은 반드시 소문자로 만들어야 한다. 엘라스틱 서치에서 강제하는 사항이므로 반드시 지켜야 한다.

## 문서(Document)

문서는 검색 대상이 되는 실제 물리적인 데이터를 말한다. 문서는 인덱스를 생성할 수 있는 기본적인 정보 단위이고 JSON 형식으로 표현된다. 인덱스에 원하는 만큼 많은 문서를 저장할 수 있고 실제로는 샤드 형태로 나누어져 다수의 노드로 분산 저장된다.

## 샤드(Shard)

인덱스에서는 엄청나게 많은 문서가 저장될 수 있다. 하나의 하드웨어에서 제공하는 리소스의 물리적인 한계를 넘기 위해 도입한 개념이 바로 샤드이다. 이를 이용하면 데이터를 분삭 저장할때 손쉽게 수평확장이 가능해진다. 

샤드는 인덱스 전체 문서 데이터의 부분 집합으로 이해하면된다. 부분집합이지만 갹 샤드는 자신이 가지고 있는 데이터만으로도 독립적으로 검색 서비스가 가능하다. 

실제로 인덱스에 쿼리를 요청하면 인덱스가 가지고 있는 모든 샤드로 검색 요청이 전달되고 각 샤드에서 1차적인 검색이 이뤄진 후 그 결과를 취합해서 최종 결과로 제공한다. 인덱스가 샤드로 분산되는 과정이나 검색 요청이 각 샤드에 분산되어 처리되는 복잡한 프로세스는 사용자에게 완벽하게 블랙박스이다. 

>샤딩이 중요한 이유
>지속적으로 증가하는 컨텐츠가 수평적으로 분할되어 하드웨어의 한계를 극복할 수 있다.
>여러 노드에서 샤드를 통해 분산 처리되므로 성능이나 처리량을 향상 시킬 수 있다.

## 레플리카

샤드의 복제본을 레플리카 (Replica)라고 한다. 엘라스틱 서치에서는 인덱스를 생성할때 기본적으로 1개의 레플리카 세트를 생성한다. 검색 시 레플리카가 적극적으로 활용되기 때문에 이를 이용하면 일기 분산이 유리해진다. 

수평적으로 분산된 시스템을 운영할때는 언제든 장애가 나타날 수 있다. 네트워크 특성상 특정 노드가 오프라인으로 변경될 경우 페일오버(Failover) 메커니즘을 적극적으로 활용하는 것이 좋은데 엘라스틱서치에서는 레플리카를 이용한 페일오버 메커니즘을 제공하고 있고 이를 이용해 안정적인 클러스터 운영을 보장한다. 

인덱스가 생성될 때 샤드 개수와 레플리카 개수를 자유롭게 설정할 수 있다.하지만 인덱스가 생성된 이후에는 샤드 개수를 변경하는 것이 불가능하기 때문에 이 점에 유의하자. 그에 반해 레플리카의 갯수는 인덱스를 생성한 이후에도 자유롭게 변경하는 것이 가능하다. 그렇게 때문에 운영 중 트래픽 증가에 대한 유연한 대응이 가능해진다. 이는 검색 엔진의 특성상 읽기 연산이 대부분이기 때문에 매우 유용한 기능이다.

>엘라스틱 서치의 고가용성
>엘라스틱서치에서는 샤드나 노드에 장애가 발생할 경우, 즉각적인 복구가 가능하기 때문에 안정적인 클러스터 운영이 가능해진다. 페일오버 메커니즘을 송공적으로 구현하기 위해 레플리카는 기본적으로 원본 샤드가 존재하지 노드에서 생성된다. 또한 검색 시 샤드와 레플리카에서 병렬로 실행될 수 있기 때문에 검색 성능이 좋아진다.

## 세그먼트

문서들은 빠른 검섹에 유리하도록 설계된 특수한 자료구조로 저장된다. 샤브 내부에 루씬을 

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTE0Nzc3NDQ2LC0xMjM0NTIyMjE5LDY1Mz
c0NTA0LC0xMzEwMjQzMjQsNzYzOTY3ODI5LC0xNDE4MTkwODQ3
LC0xOTM5NjA2NjYyLDE4NzQ3Njg1ODEsMTg1NzA0MjAyMywxOT
g4NzE0NDA3XX0=
-->