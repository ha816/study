# Overview

이번 장에서는 엘라스틱서치의 시스템적 측면을 공부해보자. 그리고 이를 통해 엘라스틱서치 클러스터가 안정적으로 동작하는데 필요한 시스템 구성을 함께 고민해보자. 

# 노드 실행환경과 JVM 옵션

엘라스틱서치와 루씬은 모두 자바 언어로 개발되었다. 하지만 독립적으로 실행 가능한 엘라스틱 서치와는 달리 루씬은 독립적으로 실행될 수 없는 라이브러리 형태로 제공된다. 루씬은 자바 애플리케이션에서 사용할 수 있도록 jar형태로 배포되고, 엘라스틱서치는 이러한 jar 라이브러리를 임포트하는 방식으로 활용한다. 엘라스틱서치가 실행되어 인스턴스가 만들어지면 엘라스틱서치와 루씬 둘 다 하나의 JVM에서 함께 동작한다. 이제 엘라스틱서치 인스턴스가 실행되는 실행환경에 대해 알아보자. 

## 엘라스틱서치 릴리즈 노트

2010년 즈음 오픈 소스로 개발되기 시작해서 2014년 1.0 버전이 공식 출시된 이후로 지금도 매우 빠르게 성장하고 있다. 

실무에서는 2.x ~ 5.x 버전이 아직 많이 사용되고 있다. 하지만 새롭게 엘라스틱 서치를 도입한다면 6.x 이상을 사용할 것을 권장한다. 최신 버전을 사용함으로써 자바와 루씬의 최신 기능을 모두 사용할 수 있기 때문이다. 

엘라스틱서치와 루씬은 매우 밀접한 관계가 있다. 엘라스틱서치는 루씬을 기반으로 동작하기 때문에 엘라스틱버전에 따라 내부에서 사용하는 루씬 버전도 함께 달라진다. 루씬 라이브러리의 기능이 추가되거나 버그가 수정되면 주기적으로 버전업하게 되는데, 엘라스틱서치에서도 새롭게 버전업된 루씬을 기반으로 새로운 버전의 엘라스틱서치를 릴리스해서 제공한다. 

엘라스틱서치와 루씬 모두 오픈소스이고 엘라스틱서치의 개발자가 동시에 루씬의 개발자이기도 하다. 그래서 루씬의 기능이 새로 추가 될때마다 엘라스틱서치도 그에 따라 새로운 기능으로 릴리스가 된다. 

## 실행시 자바 8 이상을 사용해야할 이유

최근 급견한 하드웨어 기술의 발달로 CPU나 메모리 자원이 매우 저렴해졌다. 한 서버에서 다수의 CPU나 코어를 탑재하고 메모리도 비교적 넉넉하다. 

### 다수의 CPU 사용

64비트 컴퓨터로 변경되면서 메모리 사용은 사실 프로그래밍 관점에서는 크게 변화가 없었다. 하지만 다수의 CPU를 사용하는 프로그래밍에서는 변화가 컸다. 기존 멀티쓰레드 기반 프로그래밍은 하나의 CPU를 효율적으로 사용하기 위한 방식이 대부분이었기 때문에 오히려 CPU가 많은 환경에서는 비효율적인 경우가 종종 발생했다.

다수의 CPU가 탑재된 경우 동시에 모든 CPU를 점유해서 동작하여 프로그래밍을 해야 했는데 이런 방식은 멀티 쓰레드 방식 방식과 비교했을때 상대적으로 매우 어려운 일이었다. 

자바는 8 버전 부터 큰 변화가 생겼다. 그 중 대표적으로는 함수형 프로그래밍의 도입이라고 할 수 있다. 함수형 프로그래밍 언어 지원을 위해 스트림과 람다 표현식이 지원되기 시작했다. 

스트림을 사용하면 언어차원에서 손쉽게 멀티 코어로 함수를 동작시킬수 있다. 이런 특수한 함수를 람다라고 부르는데 람다를 이용해 로직을 작성하고 스트림에 입력하면 다수의 CPU에서 동시에 데이터가 처리되고 모든 CPU에 처리가 끝날때 까지 결과를 기다리게 된다. 이후 모든 결과를 모아 돌려준다. 즉 일종의 맵 리듀스로 동작하게 되는것이다. 

이런 과정은 언어 차원에서는 블랙박스로 이루어진다. 멀티 코어에 대해 깊은 지식이 없더라도 개발자는 로직에만 집중하면 되는 것이다. 람다를 쓸수 있는 것만으로도 자바 8을 써야하는 이유는 분명하다. 

### 항상 최신 버전의 엘라스틱서치를 사용하기

일반적으로 버전업이 이뤄질 경우 최대한 하위 호환을 고려해서 개발이 이뤄지지만 하위 호완성을 100%유지한다는 것은 매우 어려운 일이다. 

엘라스틱서치는 자바, 루씬, 엘라스틱서치 자체의 기능을 모두 고려해서 하위 호완성을 만들어야 하는데 이는 굉장히 어렵다. 버전이 올라갈수록 기존에 제공하는 기능이 폐기 예정이거나 사용법이 바뀔수 있기 때문에 반드시 변경사항을 꼼꼼히 확인해야 한다.

>엘라스틱서치 메이저 업데이트와 마이너 업데이트
>실무에서는 이미 엘라스틱서치에 많은 데이터가 있을 것이므로 운영중에 엘라스틱서치를 버전업하는 것은 매우 리스크할 것이다. 이러한 이유로 대부분 릴리즈 업데이트가 있어도 버전업을 못한 것이다. 이러한 경우를 고려해서 엘라스틱서치는 최신 버전에서 메이저버전이 올라가더라도 과거 버전의 버그패치와 같은 간단한 마이너 패치는 일정 기간 제공하고 있다.

### 자바 8에서 제공하는 JVM 옵션

서버상에서 자바 애플리케이션을 실행하는 경우 JVM 위에서 동작하게 된다. JVM 기반의 애플리케이션은 개발자가 직접 메모리 관리를 하지 않아도 된다는 큰 장점이 있다. 메모리 관리 책임은 JVM이 맡고, GC가 가비지 컬렉션 메커니즘으로 일정주기로 사용하지 않는 메모리를 자동으로 회수한다. 

GC동작은 자동적으로 일어나지만 실행할때 JVM에 옵션으로 일부  GC동작을 제어할 수도 있다. 그럼 엘라스틱에 적용된 JVM옵션을 무엇인지 알아보도록 하자. 

**엘라스틱서치는 분산 시스템의 특성상 스케일 인/스케일 아웃(Scale In/Scale Out)이 빈번하게 발생할 수 있다. 또한 장애를 복구한다거나 ReIndex 작업에 의해 일어나는 데이터 리밸런싱에 의해 많은 메모리를 사용하기 때문에 전체적인 성능향상을 위해 다수의 JVM옵션을 반드시 튜닝해야 한다.** 

일반적인 경우는 엘라스틱서치에서 기본적으로 제공하는 옵션 그대로 실행하면 된다. 다시 한번 강조하지만 엘라스틱서치에서 기본적으로 설정한 JVM 옵션은 수정하지 않고 그대로 사용하길 권한다.

엘라스틱서치는 다수의 노드로 구성되며, 서로 유기적으로 동작하는 매우 복잡한 애플리케이션이다. **지금까지 버전업을 해오면서 많은 문제를 해결해왔기 때문에 기본 설정으로 제공하는 JVM옵션들이 각종 문제에 대한 경험을 바탕으로 최적화한 값이다.** 

각 환경에서 설정한 대부분의 JVM 옵션들은 서비스 운영 초기에는 매우 유용한 것으로 보일수도 있다. 하지만 데이터가 커지면 결국 불안정해질 가능성이 높다. 이런 경우 JVM 옵션을 다시 기본 설정으로 변경해보는 것도 좋은 해결책 중 하나다. 

하지만 세상에는 언제나 예외가 있다. jvm.option이라는 파일에는 기본적인 JVM 힙 크기가 1GB로 설정되어 있는데, **실제 운영환경에서는 이를 반드시 더 큰 크기로 만들어야 한다.** 힙 크기가 1GB인 이유는 엘라스틱서치를 실행할 수 있는 최소한의 힙의 크기가 1GB이기 때문이다. 이는 테스트 용도이므로 실제 운영환경에서는 힙크기는 반드시 이것보다 커야 한다. 서비스 운영을 위해 힙 크기를 변경하는 것외에는 기본 설정된 JVM 옵션을 그대로 사용하는것이 좋다. 

# 힙 크기를 32GB 이하로 유지하는 이유

엘라스틱서치는 메모리를 많이 잡아 먹는 애플리케이션이다. 우리는 시스템에서 제공되는 물리 메모리를 JVM 힙에 할당해서 엘라스틱서치가 사용하도록 설정할 수 있다. 일반적으로 힙 메모리가 클수록 그에 비례해서 성능도 올라간다

그렇다면 적당한 힙 크기는 얼마일까? 너무 작으면 OOM 오류가 발생하고 너무 크면 Full GC가 발생했을때 시스템 전체가 멈추는 STW가 발생할 수도 있다. 이번 이야기는 시스템에 탑재된 물리 메모리 크기에 따라 엘라스틱서치에서 힙 크기를 얼마로 설정하는게 좋을지 알아보자.

## 엘라스틱서치와 힙 크기

기본적으로 엘라스틱서치의 힙 크기는 1GB로 설정되어 있다. 이는 테스트 용도로 제공되는 값으로 최소사양을 가정해서 설정된 값임을 명심하자. 

엘라스틱서치는 기본적으로 메모리를 많이 활용하는 애플리케이션이기 때문에 처음부터 Xms와 Xmx 크기를 같게 많이 설정하는것이 여러모로 유리하다. (Xms: 최소 힙크기, Xmx: 최대힙크기)

그럼 적절한 힙 크기는 얼마가 좋을까? 이는 매우 어려운 문제다. 일반적으로는 힙 크기가 클수록 좋다. 하지만 무작정 큰 메모리를 할당하는것은 또 다른 문제를 야기할 수 있다. 만약 수십 GB의 물리 메모리를 가지는 대형 서버가 있고 엘라스틱서치를 위해 힙크키로 물리 메모리에 대부분을 할당하면 어떻게 될까? 아마도 엘라스틱서치의 성능에 큰 문제를 발생시킬 것이다. 좀 더 설명하겠지만 여러이유로 **엘라스틱서치에서는 할당할 힙의 크기의 최대값으로 32GB이하를 설정하는 것을 권장한다.** 

### 운영체제에 50%의 메모리 공간 보장하자

엘라스틱샤드는 내부에 루씬을 가지고 있으며 루씬은 새그먼트 생성 및 관리를 위해 커널 시스템 캐시를 최대한 많이 활용하고 잇따. 실시간 검색을 지원하기 위해서는 루씬이 최대한 많은 시스템 캐시를 확보하도록 지원해야 한다. 시스템 캐시는 운영체제가 가지고 있는 메모리 공간으로 커널 내부에 존재한다. 그러므로 물리적인 메모리 공간 50%는 운영체제가 자유롭게 사용하고 나머지는 엘라스틱서치에 할당하는 것이 적절하다. 

### 자바 8기반에서는 힙 크기를 32GB이상 사용하지 말자

엘라스틱서치에서는 가급적이면 힙의 크기를 크게 잡되 최대 32GB를 넘지는 말것을 권장한다. 그렇다고 32GB를 초과하는 힙 크기를 설정해도 마냥 문제가 되는 것은 아니다 어떤 이유로 32GB로 제한을 안내하는 것일까?

이 이유는 핫스폿(Hot-Spot) JVM의 Object Pointer 정책 때문이다. 사실 모든 자바 기반 애플리케이션에는 Object Pointer 정책이 모두 동일하게 적용되기 때문에 최대 힙 크기를 32GB로 제한하는 것은 모든 자바 기반 애플리케이션에게 동일하게 해당하는 내용이다. 
 
 Object Pointer는 간단히말해 객체의 메모리 번지를 표현하는 주소값이다. 힙에 생성된 모든 객체는 이런 주소값으로 접근하게 된다. 자바 JVM은 32비트와 64비트를 모두 제공하며 이런 사실을 미루어 짐작하면 32비트 JVM은 32비트, 64비트 JVM은 64 비트 주소값을 가질 것처럼 보인다. 하지만 예쌍과 다르게 모두 32비트 Object Pointer를 사용하고 있다. 

## Ordinary Object Pointer

자바에서는 모든 객체가 힙 영역에 생성된다. 그리고 이렇게 생성된 객체는 모두 포인터를 가지고 이를 통해 객체에 접근한다. JVM은 힙 영역에 생성된 객체에 접근하기 위해 포인터의 주소를 Ordinary Object Pointer(OOP)라고 하는 특수한 자료구조를 만들어서 관리하고 있으며, 이러한 OOP들은 CPU처리 단위에 따라 동작하는 방식이 약간 달라진다.

32비트 시스템은 하나의 포인터를 표현하기 위해 32비트가 필요하다. 32비트를 이용하면 최대 4GB의 메모리 주소밖에 가리킬 수 없다. 하지만 하드웨어 기술의 발달로 64비트 컴퓨터가 보급되었다. 

64비트 컴퓨터의 경우 메모리상의 주소를 가르키는 포인터 1개를 64비트로 표현하다보니 많은 메모리 공간의 낭비가 발생한다. 인식가능한 물리적 메로리 크기가 늘어나긴 했지만 그에 따라 활용 가능한 메모리의 물리적 공간 활용성은 상대적으로 떨어지게 되었다. 이 뿐만 아니라 CPU 내부에는 빠른 연산을 위해 다양한 캐시가 있다. 캐시 적중률을 높이기 휘새 주메모리와 캐시 사이에선 지속적으로 값의 이동이 발생한다. 그런데 이때 이동하는 값들도 64비트이기 때문에 32비트에 비해 상대적으로 더 큰 대역폭을 사용하게 된다. 

64비트가 되면서 물리적 한계는 극복했지만 상대적으로 메모리 공간 낭비나 연산 속도 저하등의 단점도 나타났다. 자바의 경우도 마찬가지다. 32비트가 되면서 OOP



# 엘라스틱서치와 가상 메모리

# 분산환경에서의 메모리 스와핑

# 시스템 튜닝 포인트




> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzOTEzODQyOTEsMTk0MjY3MDEyOCwyMD
AxOTMzODI4LDEyNDI4MjYzMiw4NTk4MDIyODgsMTMwMjY2NTE1
NiwxNzY3MTg5NDA4LC0xOTM2MDgwMjA0LC0xMzkzNzk0NTk0LC
0xNjYyMDUxNzExLDQ0MDUzMTA5NCwtMTk2MzkzMTUzM119
-->