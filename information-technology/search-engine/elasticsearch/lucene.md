# Overview

엘라스틱서치는 내부적으로 루씬을 통해 검색기능을 수행한다. 루씬의 동작 과정은 고도로 추상화되어 제공되기 때문에 사용자들은 루씬의 존재를 눈치채지 못할 수도 있다. 하지만 루씬의 세부적인 동작 원리를 이해하고 나면 엘라스틱서치를 이해하는데 큰 도움이 된다. 이번 장에서는 루씬 라이브러리에 대해 알아보도록 하자. 

# 엘라스틱서치 샤드 VS 루씬 인덱스

![enter image description here](https://cdn-images-1.medium.com/max/1600/1*3xcgM8oZUTSV5ZVEjCRnNA.png)

위 그림으로 개념을 정리해보자. 엘라스틱서치의 인덱스는 다수의 물리적 노드에 나누어진 샤드로 구성된다. 그리고 각 샤드는 하나의 루씬 인덱스(루씬 인스턴스)를 가지고 있다. 루씬 인덱스는 자기 자신이 가진 다수의 세그먼트를 대상으로 검색을 수행하는데, 세그먼트의 역색인 구조를 이용하여 빠른 검색이 가능하다.

루씬 인덱스(루씬 인스턴스)
: 루씬은 다수의 클래스로 구성되어 있는 검색 라이브러리이고, 가장 핵심 클래스는 바로 IndexWriter와 IndexSearcher이다. **IndexWriter는 데이터를 색인하는 클래스**이고, **IndexSearcher는 색인된 데이터를 검색**하는 클래스다. IndexWriter와 IndexSearcher를 활용하여 색인과 검색을 동시에 수행하는 **루씬 인스턴스를 루씬 인덱스**라고 한다. 

엘라스틱서치 샤드
: 엘라스틱서치는 독립적인 루씬 인덱스를 확장한 샤드를 제공한다. 샤드는 엘라스틱서치에서 제공하는 가장 작은 단위 검색엔진이다. 루씬 인덱스가 자기자신이 가지고 있는 세그먼트 내에서만 검색이 가능한 것과는 달리 샤드는 자기를 포함한 다른 샤드가 가지고 있는 세그먼트도 통합적으로 검색할 수 있다. 

**엘라스틱서치 샤드와 루씬 인덱스는 절대 같지 않다.** 샤드 엘라스틱서치에서 추가한 다양한 기능을 포함하고 있기 때문이다. 하지만 주요 기능은 루씬 인덱스에서 제공하는 기능이다. 

# Segment(세그먼트)

문서들은 빠른 검색에 유리하도록 설계된 특수한 자료구조인 세그먼트로 저장된다. 세그먼트는 루씬 내부에 존재하는 자료구조로, 역색인 구조로 생성되어 읽기에 최적화되어 있다. 세그먼트는 역색인 구조를 지닌 파일 자체를 의미하기도 한다.
 
루씬 인덱스의 경우 데이터를 저장할때 내부에 가지고 있는 세그먼트로만 처리가 가능했다. 엘라스틱서치 샤드는 이러한 한계를 넘어 데이터를 무한대로 확장할 수 있게 해준다. 

하나의 루씬 인덱스는 다수의 세그먼트를 가진다. 읽기 성능이 중요한 검색 엔진에선 하나의 세그먼트로 검색 요청을 처리하는 것 보다 다수의 세그먼트를 생성해 나누어 처리하는 것이 훨씬 효율적이다. 루씬은 검색 요청을 받으면 다수의 작은 세그먼트 조각들이 각 검색 결과를 만들어내고 이를 통합해서 결과로 응답한다. 이러한 검색 방식을 **세그먼트 단위 검색(Per-Segment Search)** 라고 한다. (초록색 DB모형이 세그먼트)

![enter image description here](https://www.programmersought.com/images/409/1c42be389219e95a5327a096c31c59a1.png)

루씬에는 세그먼트를 관리하기 위한 용도로 **커밋 포인트(Commit Point)**를 제공한다. 커밋 포인트에는 여러 세그먼트의 목록 정보를 가지고 있으며, 검색 요청시 이를 적극 활용한다. 자세히는 루씬의 IndexSearcher가 검색 요청시 커밋 포인트를 이용해 가장 오래된 세그먼트부터 차례대로 검색한 후에 각 결과를 하나로 합친다. 이때 존재하는 모든 세그먼트를 검색하기 때문에 사실상 데이터의 누락은 발생하지 않는다.

## 세그먼트 불변성(Segment Invariant)

기본적으로 루씬의 IndexWriter가 생성한 세그먼트는 한번 디스크에 저장된 이후 수정이 불가능하도록 관리된다. **예외적 상황인 주기적인 병합 작업을 제외하고는 수정을 허용하지 않는다.** 때문에 색인 작업이 수행될때마다 기존 세그먼트에 추가하는 방식이 아닌 새로운 세그먼트가 생성될수 밖에 없다.

세그먼트의 불변성은 루씬의 입장에서는 매우 중요한 특성이다. 주로 대용량 텍스트를 다루어야 하는 역색인 구조에서는 이 불변성의 특성에서 나오는 장점이 매우 유용하다. 불변성을 사용했을때 장점은 아래와 같다.

>동시성 문제 회피
>불변성이 보장되면 잠금(Lock)이 필요 없어진다. 다수의 쓰레드가 동작하는 다중 쓰레드 환경에서 동시성 문제를 불변성이 보장되면 간단히 피해갈 수 있다.

>시스템 캐시 적극적 활용 가능
>데이터가 OS 커널에서 제공하는 시스템 캐시에 생성되면 일정 시간동안은 그대로 유지된다. 불변성을 보장하지 않으면 데이터가 변경될때 마다 캐시를 수정해야 하는데, 이는 매우 큰 비용이므로 최대한 지양해야한다.

>높은 캐시 적중률(Hit ratio)
>시스템 캐시의 수명이 길어져 검색 시 데이터를 항상 메모리에서 읽어와 큰 성능향상을 꾀할 수 있다.

>리소스 절감
>역색인 구조를 만드는 과정에서 많은 시스템 리소스(CPU, 메모리 I/O)가 사용된다. 수정을 허용하게 되면 일부가 변경되는 해당 역색인을 대상으로 수정 작업을 해야하기 때문에 리소스를 크게 잡아 먹는다.

읽기 연산이 대다수 작업인 검색 엔진의 특성상 캐시 성능을 최대한 활용하고 동시성 문제를 피할 수 있는 불변성은 최고의 성능을 보인다.

물론 세그먼트 불변성도 단점은 있다. 가장 큰 문제는 일부 데이터가 변경 되더라도 전체 역색인 구조가 다시 만들어져야 한다는 것이다. 또 실시간 반영이 상대적으로 어려워 지는데 변경사항을 반영 하기위해 역색인을 새로 만들어야 하는데 변경이 매우 빠르게 자주 일어난다면 실시간 반영 자체가 불가능해진다.

이러한 단점을 극복하기 위해 루씬에서는 크기가 작은 다수의 세그먼트를 생성해서 제공하는 방식을 택했다. 즉 변경이 일어날때마다 세그먼트를 다시 만드는 것이 아니라 기존 세그먼트는 그대로 두고 추가로 세그먼트를 생성하는 것이다. 

**정리하자면, 세그먼트의 불변성은 단점보다는 확실한 장점이 많다. 읽기 연산 비중이 큰 루씬에서 세그먼트가 불변성을 가짐으로써 읽기 연산의 성능을 대폭 끌어올릴 수 있었다.** 

## 세그먼트 주요 작업

사실 대다수의 세그먼트 관련 작업은 세그먼트를 새로 추가하는 작업이다. **색인 작업 요청**이 루씬에 들어오면 IndexWriter가 색인 작업을 하고 결과물로 하나의 세그먼트가 생성된다. 그 후 추가 색인 작업이 요청될때마다 새로운 세그먼트가 추가되고 커밋 포인트에 기록된다. 색인 작업이 일어날때마다 세그먼트의 개수는 늘어난다. 

세그먼트의 개수가 너무 많아지면 읽기 성능 저하가 생길수 있다. 때문에 루씬은 백그라운드에서 **주기적으로 세그먼트 파일을 병합(Merge)** 하는 작업을 수행한다. 이를 통해 모든 세그먼트를 물리적으로 하나의 파일로 병합한다. 정책에 따라 일부 세그먼트가 선택되어 합쳐지고, 일정 시간이 흘러 더 이상 색인 작업이 없는 상태가 되면 하나의 큰 세그먼트만 남는다. 

![enter image description here](https://www.bloghome.com.cn/content/images/2019/05/segment-merging-bw-1.png)

요청과 현 상황에 따라 루씬의 동작방식을 정리하면 아래와 같다.

> 최초 색인 요청시
> 1. IndexWriter가 최초의 세그먼트를 생성
> 2. IndexSearcher가 생성된 세그먼트를 읽어 검색결과를 제공

> 추가 색인 요청
> 1. IndexWriter가 세그먼트를 추가 생성
> 2. 세그먼트가 추가 생성되는 동안 기존 세그먼트만 읽어 검색 결과 제공
> 3. 세그먼트 생성이 완료되면 생성된 세그먼트도 마저 읽어 결과 제공

>백그라운드 주기적 세그먼트 병합 작업
> 1. IndexWriter가 Merge 대상이 되는 세그먼트를 복제
> 2.  IndexWriter가 복제한 세그먼트를 하나로 병합
> 3. 복제 세그먼트들이 병합되는 동안 IndexSearcher는 원본 세그먼트를 읽어 검색수행
> 4. 복제본 세그먼트의 병합이 완료되면 원본 세그먼트와 교체하고 원본 세그먼트 삭제
> 5. IndexSearcher는 새로운 세그먼트를 읽어 검색 결과 제공

## 세그먼트 삭제 및 수정

세그먼트 삭제 연산의 경우, **요청즉시 세그먼트를 삭제하는 것이 아니다.** 모든 데이터에는 삭제 여부를 표시하는 비트 배열을 내부적으로 가진다. 삭제 요청이 들어오면 삭제될 대상 데이터의 비트 배열을 찾아 삭제 여부만 표시한다. 비트에 표시만 했기 때문에 여전히 해당 데이터는 남아있다. 검색시에는 비트배열에 삭제 여부를 항상 먼저 판단하기 때문에 불변성을 훼손하지 않고도 빠르게 검색대상에서 제외할 수 있다. 루씬 세그먼트 삭제 작업을 정리하면 아래와 같다. 
1. 루씬은 삭제될 데이터가 포함된 세그먼트의 삭제 여부 비트 배열을 확인한다.
2. 삭제 여부 비트 배열의 flag를 삭제로 표시한다.
3. 세그먼트에 직접적인 변경사항은 없으므로 세그먼트의 불변성을 해치지 않으며 캐시도 그대로 유지된다. 
4. IndexSearcher는 검색 작업시 삭제 여부 비트 배열을 항상 먼저 확인하고 체크된 데이터를 검색결과에서 제외한다.

세그먼트 수정 연산의 경우, 세그먼트의 불변성 때문에 데이터를 삭제하고 다시 추가하는 방식으로 동작한다. 기존 데이터는 삭제처리되어 검색 대상에서 제외되고 변경된 데이터는 새로운 세그먼트에 추가되어 검색대상에 포함된다. 수정 작업을 정리하면 아래와 같다.
1. 앞의 작업(세그먼트에서 일부 데이터가 삭제될 경우)으로 삭제 처리를 먼저 수행한다.
2. 수정된 데이터를 새로운 세그먼트로 생성한다.
3. IndexSearcher는 모든 세그먼트를 읽어 검색결과를 제공한다.

그렇다면 삭제될 데이터가 물리적으로 실제 삭제되는 시점은 언제일까? 백그라운드에서 주기적으로 일어나는 Merge 작업이 수행될때 삭제가 된다. 루씬이 삭제 데이터를 바로 삭제하지 않고 병합 작업시 삭제를 하는 이유는 세그머트가 가지는 역색인 구조와 관련이 깊다. 

일반적인 역색인 구조는 색인 대상이 되는 문서를 최소단위인 텀 단우의 단어로 분리하고 역색인 구조에 따라 정렬한 뒤 저장한다. 문서 하나를 제거하려면 전체 역색인 구조를 찾아 관련된 모든 텀을 제거해야 하기 때문에 사실 세그먼트를 다시 생성하는 것과 별반 다를바가 없저진다. 그래서 즉시 삭제하는 것이 아니라 주기적으로 세그먼가 재 생성되는 작업에서 물리적인 삭제를 함께 한다. 

# 루씬을 위한  Flush, Commit, Merge

루씬은 효율적인 색인 작업을 위해 내부적으로 일정 크기의 버퍼를 가지고 있다. 이러한 버퍼를 인메모리 버퍼(In-memory buffer)라고 한다. 그리고 루씬에서 인메모리 버퍼 기반의 처리과정을  Flush라 부른다.

루씬에 색인 작업이 요청되면 전달된 데이터는 일단 인메모리 버퍼에 순서대로 쌓인다. 그리고 나서 정책에 따라 인메모리 버퍼에 순서대로 쌓인다. 그리고 나서 정책에 따라 내부 버퍼에 일정 크기 이상 데이터가 쌓이거나 일정 시간이 지나면 버퍼에 쌓인 데이터를 모아 한꺼번에 처리한다. 버퍼를 일종의 큐로 활용하는 것이다. 

![enter image description here](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTLuitG_woohDKnKKdYe90ayzNwf80eG2k_1ba9b1y_Qlg561tK&usqp=CAU)

버퍼에 모여 한꺼번에 처리된 데이터는 세그먼트 형태로 생성되고 즉시 디스크로 동기화 된다. 하지만 디스크에 물리적으로 동기화하는 일련의 과정은 운여에제 입장에서는 매우 비용이 큰 연산이기 때문에 세그먼트가 생성될때마다 물리적인 동기화를 할 경우 성능이 급격히 나빠질 수 있다. 

루씬은 이러한 문제를 해결하기 위해 무거운 fsync방식을 쓰는 대신에 상대적으로 가벼운 write방식으로 쓰기과정을 수행한다. 

write()
: 일반적으로 파일을 저장할 때 사용하는 함수다. 운영체제 내부 커널에는 시스템 캐시가 존재하는데 write함수를 이용하면 일단 시스템 캐시에만 기록된다. 이후 실제 데이터는 특정 주기로 물리 디스크에 기록된다. 물리적인 디스크 쓰기 작업을 하지 않기 때문에 빠르지만 시스템이 비정상 종료될 경우에는 데이터 유실이 발생할 수 있다.

fsync()
: 저수준의 파일 입출력 함수다. 내부 시스템 캐시의 데이터와 물리적인 디스크 데이터를 동기화하기 위한 목적으로 사용된다. 실제 물리적인 디스크로 쓰는 작업을 수행하기 때문에 상대적으로 많은 리소스가 사용된다.

ReOpen() -> openIfChanged()
: 루씬에서는 IndexSearcher가 일단 생성되고 나면 이후 변경된 사항들을 기본적으로 인지 못한다. 물론 기존 IndexSearcher를 닫고 다시 만들면 되겠지만 문서의 추가나 변경이 빈번히 일어날 경우 많은 리소스가 필요해지기 때문에 권장하지 않는다. 이때 사용할 수 있는것이  ReOpen()이다. 일정 주기마다 문서가 변경된다면 이 함수를 써서 더 효율적으로 리소스를 사용할 수 있다. 루씬 3.5부터는 deprecated되었으며 openIfChanged()를 쓰도록 하자.

데이터의 변경 사항을 일단 버퍼에 모아두고 일정 주기에 한번씩 새그먼트를 생성하고 상대적으로 적응 비용으로 디스크에 동기화까지 수행하는 것이다. 일단 Flush 처리에 의해 세그먼트가 생성되면 커널 시스템 캐시에 세그먼트가 캐시되어 읽기가 가능해진다. 커널 시스템 캐시에 캐시가 생성되면 루씬의 ReOpen()함수로 IndexSearcher에서도 읽을 수 있는 상태가 된다.

루씬에서는 물리적으로 실제 디스크에 기록을 하는 fsync함수를 호출하는 작업을 Commit이라고 한다. Flush라는 단계가 존재하기 때문에 매번 Commit을 수행할 필요가 없어 보이지만 일정 주기로 Commit 작업을 통해 물리적인 디스크로 기록 작업을 수행해야 한다는 사실을 잊으면 안된다. 


세그먼트는 불변성을 기반으로 설계되었고, 이러한 불변성이 지닌 이점은 충분하다. 하지만 불변성을 유지하기 위해 루씬의 동작 방식은 다소 복잡해졌다. 불변성 유지를 위해 세그먼트 단위 검색(Per-Segment Search)을 제공하지만 시간이 흐를 수록 세그먼트의 개수가 늘어날 수 밖에 없고 이를 지원하기 위한 커밋 포인트 부하도 증가한다. 그래서 다수의 세그먼트를 하나로 합치는 자업이 필요하다. 이 작업이 Merge 작업이다. 

병합 작업을 하면, 세그먼트의 수가 줄어들기 때문에 검색 횟수가 줄어들어 검색 성능이 좋아진다. 마찬가지로 수가 줄기 때문에 세그먼트가 차지하는 디스크 용량이 줄어든다. 삭제되는 문서의 경우 병합 작업 전에는 디스크에 물리적으로 남아 있다. 하지만 병합 작업으로 새로운 새그먼트를 생성하면 디스크에서 삭제가 되고 공간 절약이 가능해진다.

병합 정렬은 Commit작업을 반드시 동반해야 하는데, Commit작업은 매우 비용이 많이 든다. 따라서 정책적으로 적절한 주기를 설정하는 것이 매우 중요하다. 전체적인 성능 향상을 위해 루씬은 자동 주기로 세그먼트의 병합 작업을 수행한다. 작업 주기는 최적의 성능을 낼수있도록 설정되며 백그라운드로 수행된다. 

>루씬 Flush
>세그먼트가 생성된 후 검색이 가능해지도록 수행하는 작업
>write() 함수로 동기화가 수행됬기 때문에 커널 시스템 캐시에만 데이터가 생성된다. 이를 통해 유저 모드에서 파일을 열어서 사용하는 것이 가능해 진다.
>물리적으로 디스크에 쓰여진 상태는 아니다. 

>루씬 Commit
>커널 시스템 캐시의 내용을 물리적인 디스크에 쓰는 작업
>실제 물리적인 디스크에 기록되기 때문에 많은 리소스가 필요하다.

>루씬 Merge 
>다수의 세그먼트를 하나로 통합하는 작업
>Merge 과정을 통해 삭제 처리된 데이터가 실제 물리적 디스크에서도 삭제 된다.
>검색할 세그먼트의 개수가 줄어들기 때문에 검색 성능이 좋아진다.

# 엘라스틱서치를 위한 Refresh, Flush, Optimize API

엘라스틱서치 샤드는 사실상 루씬 인덱스의 확장이고 세그먼트 기반의 내부 동작을 그대로 검색에 활용한다. 엘라스틱서치는 다수의 샤드로 데이터가 분산 저장되어 있고 모든 샤드가 협력해 데이터 검색을 한다. 

엘라스틱서치는 사실 내부에 루씬 인덱스가 가지는 기능을 확장해서 API로 제공한다. 그렇게 때문에 루씬의 파라미터들을 튜닝하면 엘라스틱서치에서도 그에 사응하는 성능상의 이점을 얻을 수 있다. 대표적인 튜닝 포인트인 Flush, Commit, Merge 작업 또한 확장되어 API로 제공된다. 하지만 루씬의 작업을 엘라스틱서치에서는 전혀 다른 명칭으로 부르고 있기 때문에 주의해야 한다.

|루씬 |엘라스틱서치|
|--|--|
|Flush  |  Refresh|
|Commit  | Flush|
|Merge  |  Optimize API|

단일 검색 엔진을 표방하는 루씬과는 다르게 고가용성이 보장되어야 하는 분산 검색엔진인 엘라스틱 서치의 경우 루씬 보다 고려해야 할 사항이 훨씬 더 많다. 분산 시스템의 특성상 장애가 더 빈번할 수도 있고 단일 샤드에 장애가 발생하더라도 전체 클러스터에 영향이 없어요 햔다. 또한 장애 복구를 위한 레플리카 세트를 운영해야 하는데 레플리카 샤드 또한 일반 샤드와 별반 다를것이 없기 때문에 레플리카 세트가 많아질 수록 색인 비용 또한 많아진다. 

이러한 이유로 **루씬의 작업을 그대로 사용하지 않고 고가용성에 적합하도록 개선 및 확장해서 제공한다.** 

## Refresh

엘라스틱서치는 대용량 데이터를 색인하고 근실시간 검색을 할 수 있게 설계되었다. 엘라스틱서치는 각 샤드가 가지고 있는 루씬을 제어할 수 있으며, 주기적으로 인메모리 버퍼에 대해 Flush작업을 한다. 이러한 **루씬의 Flush 작업을 엘라스틱서치에서는 Refresh라고 하면 클러스터에 존재하는 모든 샤드에서는 기본적으로 1초마다 한번씩 Refresh작업이 수행된다.**

루씬의 Flush를 Refresh라고 부르는 이유는 용어에 좀더 행위의 의미를 담은 측면이 크다. 인덱스를 새로고침한다는 의미인데, 새로 추가한 문서의 검색이 가능해지게 한다는 것이다. 

Refresh 주리를 수동으로 조절할 수 있는 API가 존재한다. 하지만 기본 설정된 주기를 변경하는 것은 별로 권장하지 않는다. Flush 작업이 Commit 작업보다는 가볍다고는 하나 여전히 비용이 발생하는 연산이고 전체 성능에 큰 영향을 주는 작업이기 때문이다.

>대량 색인이 필요하신 참고할 팁
>_settings API를 이요하면 Refresh주기를 변경할 수 있다. 만약 대량의 데이터를 한번에 색인 제작이 필요할 경우, Refresh작업을 잠시 비활성화 하고 색인 작업이 끝나면 다시 되돌리는 것이 가능하다. 

>```
>PUT movie/_settings 
>{"index" : { "refresh_interval": "-1" } --비활성화 

특별한 경우가 아니라면 Refresh주기를 임의로 변경하지 말고 엘라스틱서치에게 맡기자. 하지만 대량의 색인을 짧은 시간에 수행해야 한다면 잠깐만 주기를 길게 잡거나 비활성화해서 처리하는 편이 여러모로 유리하다.

## Flush

엘라스틱서치에서 **Flush는 루씬의 Commit 작업을 수행하고 새로운 Translog를 시작한다는 의미다.**  절대로 이 작업을 루씬의 Flush와 혼동해서는 안된다. 

Translog는 루씬에서는 존재하지 않는 엘라스틱서치에서만 존재하는 개념이다. **Translog는 샤드 장애 복구를 위해 제공되는 특수한 파일이다.** 엘라스틱서치 샤드는 자신에게 일어나는 모든 변경사항을 Translog에 먼저 기록한 후 내부에 존재하는 루씬을 호출한다. 시간이 흐를수록 Translog의 파일 크기는 늘어난다.

정책에 의해 루씬 Commit이 정상적으로 수행되면 변경사항이 디스크에 물리적으로 기록되고 Translog 파일에서 Commit이 정상적으로 일어난 시점까지의 내역이 삭제된다. 

정리하자면 엘라스틱서치에서 Flush는 루씬의 Commit을 수행하고 장애 복구를 위한 Translog를 정리하는 일련의 과정을 통칭한다. 기본적으로 5초에 하번 Flush 작업이 수행되며, Refresh와 마찬가지로 API로 Flush 주기를 조절할 수 있지만 임의 조정은 권장하지 않는다. 

## Optimize API

엘라스틱서치에서는 인덱스 최적화를 위해 Optimize API를 제공한다. 이를 forced merge API라고도 하는데, 말그대로 루씬의 병합 작업을 강제로 수행하는 기능이다. 이로 파편화된 다스의 세그먼트를 하나의 세그먼트로 통합하여 좀 더 빠른 성능을 제공할 목적으로 사용된다.

일반적으로 변경이 더 이상 일어나지 않는 오래된 인덱스의 경우에는 하나의 세그먼트로 강제로 병합하는 것이 성능상 유리하다. 

>오래된 세그먼트를 하나로 강제 병합하기
>엘라스틱서치에서 제공하는 max_num_segments 옵션을 이용하면 샤드의 세그먼트를 설정된 개수로 강제 병합할 수 있다. 
>```
>POST /moive/_forcemerge?max_num_segments=1


# 마치며 

lucene의 대해서 어느 정도 알게 되었다면, 엘라스틱서치에서 사용하는 analyzer에 대해 알아보자. 

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0ODU2NDk3NjUsLTIwMjcyMDk0ODQsLT
E3NDYzNzU4MDksMTE5MTQ0ODU1MSwxMTgwODIwNTUyLDQ3NzQ2
NTkxLC00OTU0MjY3MzcsMTE4MzEzMTAwNyw5ODAxNjEwNjksMT
U2NDY3MzY5MiwtNTgwOTMxMjgsMzU4Nzc0MjQwLC0yMTI2NTMy
NTMyLC02MjI3ODUzMDcsLTE4ODc4MjE0MTYsNzE3MDQ1Mzg4LD
IwMDk5NTg4MzQsMTQ0ODM2MzUzNywxNjA1MTM2Nzk1LDQzNjgz
MDkyM119
-->