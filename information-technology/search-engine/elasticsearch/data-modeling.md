# 데이터 모델링

엘라스틱서치에서 색인할 문서의 데이터 유형에 따라 필드에 적절한 데이터 타입을 지정해야 한다. 이 과정이 매핑이며, **매핑은 색인될 문서의 데이터 모델링**이라 할 수 있다. 

## 매핑 API 이해하기 

매핑은 색인시 데이터가 어디에 어떻게 저장될지 결정하는 설정이다. 데이터 베이스의 스키마에 대응하는 개념이라고도 할 수 있는데 인덱스에 추가되는 각 데이터 타입을 구체적으로 정의하는 일이다. 

문서에 존재하는 필드의 속성을 정의할때 각 필드 속성에는 데이터 타입과 메타데이터가 포함된다. 이를 통해 색인 과정에서 문서가 어떻게 역색인으로 변환되는지 상세하게 정의할 수 있다. 

데이터 베이스에서 테이블 컬럼의 정보를 정의하는 것이 중요하듯 엘라스틱 서치에서도 데이터 타입을 정의하는 것은 매우 중요하다. 엘라스틱서치는 기본적으로 스키마리스이기 때문에 명시적으로 필드를 정의하지 않아도 데이터 유형에 따라 필드 데이터 타입에 대한 매핑 정보가 자동으로 생성된다. 자동 매핑 방식은 언뜻 편리해보이지만 실수로 잘못 지정된 매핑 정보가 지정될 경우 수정할 방법이 없으므로 매우 주의해야 한다. 

이미 만들어진 매핑 정보를 확인하려면 _mapping API를 사용하면 된다. 
```
GET movie_search/_mapping -- 생성된 index movie_search 매핑 정보 가져오기
```

### 매핑 파라미터 
매핑 파라미터는 색인할 필드의 데이터를 어떻게 저장할지에 대한 다양한 옵션을 제공한다. 

#### analyzer
: 해당 필드의 데이터를 형태소 분석하겠다는 의미의 파라미터다. 색인과 검색 시 지정한 분석기로 형태소 분석을 수행한다. text 데이터 타입의 필드는 analyzer 매핑 파라미터를 기본적으로 사용해야 한다. 별도의 분석기를 지정하지 않으면 Standard Analyzer로 형태소 분석을 수행한다. 

#### normalizer
: normalizer 매핑 파라미터는 term query에 분석기를 사용하기 위해 사용된다. 예를 들어 keyword 데이터 타입의 경우 원문을 기준으로 문서가 색인되기 때문에 cafe, Cafe, Cafe'는 서로 다른 문서로 인식된다. 하지만 해당 유형을 normalizer를 통해 분석기에 asciifoldings같은 필터를 사용하면 같은 데이터로 인식되게 할 수 있다. 

#### ~~boost~~
: 필드에 가중치(weight)를 부여한다. 가중치에 따라 유사도 점수(_score)가 달라지기 때문에 boost 설정 시 검색 결과의 노출 순서에 영향을 준다. 만약 색인 시점에 boost 설정을 하게 된다면 재색인하지 않는 이상 가중치 변경을 할 수 없기 때문에 주의해서 사용해야 한다.
최신 엘라스틱 서치에서는 색인시 boost 설정을 사용할 수 없도록 바뀌었다. 

#### coerce
: 색인 시 자동 변환을 허용할지 여부를 말하는 파라미터다. 예를 들어 "10"과 같은 숫자 형태의 문자열이 integer 타입의 필드로 들어온다면 자동으로 형변환을 수행하여 정상적으로 처리한다. 하지만 coerce를 미사용으로 설정 해둔다면 색인에 실파한다. 

#### copy_to
: 매핑 파라미터를 추가한 필드 값을 지정한 필드로 복사한다. 예컨대 keyword 타입의 필드에 copy_to 매핑 파라미터를 사용해 다른 필드로 값을 복사하면 복사된 필드에서는 text 타입을 지정해 형태소 분석을 할 수도 있다.

#### fielddata
: 엘라스틱 서치가 힙 공간에 생성하는 메모리 캐시다. 과거에는 fielddata를 많이 사용했지만 메모리 부족현상과 잦은 GC로 현재는 거의 사용되지 않는다. 최신 버전의 엘라스틱 서치에서는 doc_values라는 새로운 형태의 캐시를 제공하고 있으며, text 타입 필드를 제외한 모든 필드는 기본적으로 doc_values 캐시를 사용한다. 
fielddata를 사용해야만 하는 경우도 있다. text 타입의 필드는 기본적으로 분석기에 의해 형태소 분석이 되기 때문에 집계나 정렬등의 기능을 수행할 수 없다. 하지만 부득이 하게 text 타입 필드에 대해서 집계나 정렬을 수행하는 경우도 있다. 이러한 경우에 fielddata를 사용할 수 있다. 하지만 fielddata는 메모리에 생성되는 캐시이기 때문에 최소한으로 사용하자. 기본적으로 fielddata는 비활성화 되어있다.

#### doc_values
: 엘라스틱 서치에서 사용하는 기본 캐시다. text 타입을 제외한 모든 타입에서 기본적으로 doc_values 캐시를 사용한다. doc_values는 루씬 기반의 캐시 방식인데 과거에는 캐시를 모두 메모리에 올려 사용했으나 현재는 힙 사용에 부담을 없애고 운영체제의 파일 시스템 캐시를 통해 디스크에 있는 데이터에 빠르게 접근할 수 있다. 이로 인해 GC 비용이 들지 않으면서도 메모리 연산과 비슷한 성능을 보인다. 
필드를 정렬, 집계할 필요가 없고 스크립트에서 필드 값에 엑세스할 필요가 없다면 디스크 공간 절약을 위해 doc_values를 비활성화 할수도 있다. 한 번 비활성화된 필드는 인덱스를 재색인 하지 않는한 변경이 불가능하다.

#### dynamic
: 매핑에 필드를 추가할 때 동적으로 생성할지, 생성하지 않을지를 결정한다. 동적 생성 필드의 처리 방법으로 세 가지 설정 중 하나를 선택할 수 있다. 
true: 새로 추가되는 필드를 매핑에 추가한다.
false: 새로 추가되는 필드를 무시한다. 
strict: 새로운 필드가 감지되면 예외가 발생하고 문서 자체가 색인되지 않는다. 

#### enabled
: 검색 결과에 포함하지만 색인은 하고 싶지 않은 경우도 있다. 메타 성격의 데이터가 그렇다. 예컨대 일반적인 게시판이라면 제목과 요약 글만 색인하고 날짜와 사용자 ID는 색인하지 않는 경우다. 색인을 원치 않는 날짜와 사용자 ID의 매핑 파라미터 중 enabled를 false로 설정하면 _source에서는 검색이 되지만 색인은 하지 않는다. 

#### format
: 엘라스틱 서치는 날짜/시간을 문자열로 표시한다. 이때 날짜/시간을 문자열로 변경할때 미리 구성한 포맷을 사용할 수 있다.
basic_date -> yyyyMMdd
basic_date_time -> yyyyMMdd'T'HHmmss.SSSZ

#### ignore_above
: 필드에 저장되는 문자열이 지정한 크기를 넘어서면 빈 값으로 색인한다. 

#### ignore_malformed
: 엘라스틱서치에서는 잘못된 데이터 타입을 색인할고 하면 예외가 발생하고 문서전체가 색인되지 않는다. 이 파라미터를 사용하면 해당 필드만 무시하고 문서는 색인할 수 있다.

#### index
: 특정 필드값을 색인할지를 결정한다. 기본값은 true이며 false이면 해당 필드를 색인하지 않는다.

#### fields
: 다중 필드(multi_field)를 설정할 수 있는 옵션이다. 필드안에 또다른 필드 정보를 추가할 수 있어 같은 string 값을 각각 다른 분석기로 처리할 수 있다. 

#### norms
: 문서의 _score 값 계산에 필요한 정규화 인수를 사용할지 여부를 설정한다. 기본값은 true이다. _score 계산이 필요없거나 단순 필터링 용도로 사용하는 필드는 비활성화해서 디스크 공간을 절약할 수 있다.

#### null_value
: 색인시 문서에 필드가 없거나 필드의 값이 null이면 색인 시 필드를 생성하지 않는다. 이 경우 null_value를 설정하면 문서의 값이 null이더라도 필드를 생성하고 그에 해당하는 값을 저장한다.

#### position_increment_gap
: 배열 형태의 데이터를 색인할때 검색의 정확도를 높이기 위해 제공하는 옵션이다. 단어와 단어 사이의 간격(gap)을 허용할지를 설정한다. 

#### properties
: 오브젝트 타입이나 중첩 타입의 스키마를 정의할때 사용하는 옵션으로 필드의 타입을 매핑한다. 오브젝트 필드 및 중첩 필드에는 properties 서브 필드가 있다. 이 properties는 object나 nested를 포함한 모든 데이터 타입이 될 수 있다. 

#### search_analyzer
: 일반적으로 색인과 검색시 같은 분석기를 사용한다. 만약 다른 분석기를 사용하고 싶으면 검색시 사용할 분석기를 별도로 지정할 수 있다. 

#### similarity
: 유사도 측정 알고리즘을 지정한다. 유사도 측정 방식의 기본 알고리즘인 BM25를 다른 알고리즘으로 변강할 수 있다.

| 알고리즘 | 설명|
|--|--|
|BM25  | Okapi BM25 알고리즘으로 엘라스틱 서치가 사용하는 기본 유사도 측정 알고리즘이다. |
|classic | TF/IDF 기반 알고리즘이다. 문서 내 용어의 갯수와 전체 용어의 갯수로 유사도를 계산한다.|
|boolean|복잡한 수학적 모델을 사용하지 않고 단순히 boolean연산으로 유사도를 측정한다. score는 검색어 일치 여부에 따라 결정되며, 일치 여부에 따라 쿼리의 가중치(boost)에 사용된 점수로만 유사도를 계산한다.|

#### store
필드의 값을 저장해 검색 결과에 값을 포함하기 위한 매핑 파라미터다. 기본적으로 _source에 색이된 문서가 저장된다. 

#### term_vector
루씬에서 분석된 용어의 정보를 포함할지 여부를 결정하는 매핑 파라미터이다. 

| 알고리즘 | 설명|
|--|--|
|no  | term vector를 저장하지 않는다.|
|yes | 필드와 용어만 저장한다.|
|with_positions|용어, 용어의 시작과 끝 위치를 저장한다.|
|with_offsets|용어, 문자 오프셋을 저장한다.|
|with_positions_offsets|용어, 용어의 시작과 끝 위치, 문자 오프셋을 모두 저장한다.|

### 메타 필드(Meta Fields)

메타 필드는 엘라스틱 서치에서 생성한 문서에 제공하는 특별한 필드이다. 이것은 메타데이터를 저장하는 특수 목적의 필드로서 이를 이용하면 검색 시 문서를 다양한 형태로 제어하는 것이 가능해진다. 

아래는 색인된 문서를 조회한 경우 반환되는 JSON 예이다. 
```
{
	"_index": "movie_search",
	"_type": "_doc",
	"_id": "8",
	"_score": "1",
	"_source": {
		"movieCd": "20178401",
		"movieNm": "검객",
		"typeNm": "장편",
		...
	}
}
```
여기서 제공되는 항목 중 실제 문서의 정보를 담고 있는 항목은 _source 항목이다. 그 밖에 _index, _type, _id, _score 함수는 엘라스틱 서치가 직접 생성한 메타 필드다. 이제 이 메타 필드를 한번 알아보도록 하자.

#### _index

_index 메타 필드는 해당 문서가 속한 인덱스의 이름을 담고 있다. 이를 이용해 검색된 문서의 인덱스를 알 수 있고, 해당 인덱스에 몇개의 문서가 있는지 확인할 수 있다. 

#### _type

해당 문서가 속한 매핑의 타입 정보를 담고 있다. 이로 인덱스 내부에서 타입별로 몇개의 문서가 있는지 확인할 수 있다. 

#### _id

문서를 식별하는 유일한 키 값이다. 한 인덱스에 색인된 문서마다 서로 다른 키 값을 가진다. 

#### _uid

이 필드는 특수한 목적의 식별키다. "#" 태그를 사용해 _type과 _id를 조합해 사용한다. 하지만 내부적으로만 사용되기 때문에 검색시 조회되는 값을 아니다. 

#### _source

문서의 원본 데이터를 제공한다. 내부에는 색인 시 전달된 원본 JSON 문서의 본문이 저장되어 있다. **일반적으로 원본JSON 문서를 검색 결과로 표시할때 사용한다.**

#### ~~_all~~

all 메타 필드는 색인에 사용된 모든 필드의 정보를 가진 메타 필드이다. 모든 필드의 내용이 하나의 텍스트로 합쳐져서 제공된다. 특정 필드가 아닌 문서 전체 필드에서 특정 키워드를 검색한다면 _all  필드를 사용하자 

하지만 _all 필드는 데이터 크기를 너무 많이 차지하는 문제가 있어 엘라스틱 서치 6.0 이상부터는 폐기(deprecated)되었다. 그래서 필드 복사가 필요한 경우 copy_to 파라미터를 사용해야 한다. copy_to를 사용하면 _all과 동일한 효과를 낼 수 있다.

#### _routing 
특정 문서를 특정 샤드에 하기 위해 사용자가 지정하는 메타 필드다. 기본적으로 색인을 하면 해당 문서는 다음 수식에 따라 문서 id를 이용해 문서가 색인될 샤드를 결정한다. 별도의 설정 없이 문서를 색인하면 문서는 샤드에 골고루 분산되어 저장된다.

```
Hash (document_id) % num_of_shards -- 해시로 분산
```

어떤 경우에는 특정 문서들을 하나의 샤드로 저장하고 싶을 수 있다. 이때 _routing 필드를 사용하면 가능한데 색인할때 해당 문서들을 동일한 라우팅 ID를 지정한다. 문서 ID를 사용하는 대신 파라미터로 입력한 _routing 값이 샤드를 결정하는데 사용된다.

```
Hash (_routing) % num_of_shards -- 해시로 분산
```

## 필드 데이터 타입

매핑 설정을 위해서는 엘라스틱서치에서 제공하는 데이터 타입 어떠한 종류가 있는지 아는 것이 중요하다. 필드에는 아래와 같은 데이터 타입이 있다.

* keyword, text 데이터 타입
* date, long, double, integer, boolean, ip 같은 일반적인 데이터 타입
* 객체 또는 중첩문과 같은 JSON 계층의 데이터 타입
* geo_point, geo_shape 같은 특수한 데이터 타입

### keyword  필드 타입

말 그대로 키워드 형태로 사용할 데이터에 적잡한 데이터 타입이다. **Keyword 타입을 사용할 경우 별도의 분석기를 거치지 않고 원문 그대로 색인하기 때문에 특정 코드나 키워드등 정형화된 컨텐츠에 주로 사용한다.** 엘라스틱서치의 일부 기능은 형태소 분석을 하지 않아야만 사용이 가능한데 이 경우에도 keyword를 사용한다.

일반적으로 keyword가 많이 사용되는 항목은 아래와 같다.
* 검색 시 필터링 되는 항목
* 정렬이 필요한 항목
* 집계해야하는 항목

위 세 가지 경우라면 반드시 keyword 타입을 사용해야 한다. 만약 'elastic search'라는 문자열이 keyword 타입이 되면 'elastic'이나 'search'로는 절대 검색되지 않는다. 정확하게 'elastic search'로 질의해야만 검색 된다. 

### Text 필드 타입

Text 타입은 색인 시 **지정된 분석기가 컬럼의 데이터를 문자열 데이터로 인식하고 이를 분석한다.** 기본적으로 Standard Analyzer를 사용하며 문장 형태의 데이터에 사용하기 적합한 데이터 타입이다. 

Text 타입은 전문 검색이 가능하다는 점이 가장 큰 특징이다.  데이터를 색인하면 전체 텍스트가 토큰화되어 생성되며 특정 단어를 검색하는 것이 가능해진다. 

Text 데이터 타입을 사용하는 경우 필드 검색뿐만 아니라 집계, 정렬 연산을 사용해야 할때가 있다. 이런 경우 Text와 Keyword를 모두 갖도록 멀티 필드로 설정할 수 있다. 

### Array

Array 타입은 문자여링나 숫자처럼 일반적인 값을 가질 수도 있지만 객체 형태로도 정의할 수 있다. 한 가지 주의할 점은 Array 타입에 저장되는 값은 모두 같은 타입으로만 구성해야 한다는 점이다. 

엘라스틱서치에서는 매핑 설정시 Array 타입을 명시적으로 정의하지 않는다. 모든 필드가 기본적으로 다수의 값을 가질 수 있기 때문이다. 정의된 인덱스 필드에 단순히 배열 값을 입력하면 자동으로 Array 형태로 저장된다. 

### Numeric

숫자 타입은 그 종류가 다양한데 그 이유는 데이터의 크기가 맞는 알맞은 타입을 제공함으로써 색인과 검색을 효율적으로 처리하기 위함이다. 

long, integer, short
double, float, halffloat, byte

### Date

Date 타입은 JSON 포맷에서 문자열로 처리된다. 날짜는 다양한 포맷으로 표현될 수 있기 때문에 날짜 문자열 형식을 명시적으로 설정해야 한다. 

### Range 

범위 데이터를 저장할때 사용한다. 다양한 범위를 나타낼 수 있다. 
integer_range, date_range, ip_range 등등

### Object

JSON 포맷 문서는 내부 객체를 계층적으로 포함 할 수 있다. 문서의 필드는 단순히 값을 자질 수도 있지만 다른 문서를 포함하는 것도 가능하다. 문서를 가지는 필드 타입을 Object 테이터 타입이라 한다. 이 타입은 그저 다른 문서의 JSON 구조를 집어넣으면 된다.

### Nested 

Object 객체 배열을 독립적으로 색인하고 질의하는 형태의 데이터 타입이다. 특정 필드 내에 Object형식으로 JSON 포맷을 표현할 수 있다. 그리고 필드에 객체가 배열 형태로 저장될 수 있다. Nested 타입을 사용하면 검색시 일치하는 문서만 정확하게 출력할 수 있다.

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1NTY1MzE3ODNdfQ==
-->