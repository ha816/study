# Overview

엘라스틱서치의 데이터에 대한 개념과 관계형 DB에서 개념을 비교한 차트가 기억날 것이다. 

| 엘라스틱서치| 관계형 데이터베이스|
|--|--|
|인덱스(Index)  |  데이터베이스(Database)|
|샤드(Shard)  |  파티션(Partition)|
|타입(Type)  |  테이블(Table)|
|문서(Document)|  행(Row)|
|필드(Field)| 열(Col)|
|매핑(Mapping)| 스키마(Schema)|
|Query DSL(Domain Specific Language)| SQL|

 이번 장에서는 엘라스틱서치를 구성하는 주요 개념이 무엇인지 자세히 알아보도록 하자. 더불어 엘라스틱서치를 구성하고 있는 요소(component)에는 무엇이 있는지도 알아보자. 

# Major Concept

## Index(색인)

인덱스(색인)는 RDMBS에서 database에 해당한다. 인덱스는 유사한 특성을 가지고 있는 문서들을 모은 컬렉션이다. 하나의 database에 비슷한 특성을 가진 데이터를 모아두는 것과 유사하게 색인은 비슷한 특성의 문서들의 집합으로 이해할 수 있다. 이를 테면 고객 데이터에 대한 색인, 제품 카탈로그에 대한 색인, 주문 데이터에 대한 색인 등을 생각해 볼 수 있다. 

인덱스의 이름은 반드시 모두 소문자여야 한다. 이는 엘라스틱 서치에서 강제하는 사항이다. 클러스터 내부에 생성되는 모든 인덱스는 클러스터 내에서 유일한 인덱스명을 가져야 한다.
 인덱스의 추가, 수정, 삭제, 검색은 RESTful API로 수행할 수 있다. 만약 인덱스가 없는 상태에서 데이터가 추가된다면 데이터를 이용해 인덱스가 자동 생성된다. 

RDMBS에서는 한 database는 다수의 릴레이션 테이블로 이루어져 있다. 하지만 엘라스틱 서치에서 인덱스는 하나의 타입(type)만 가질 수 있다. 엘라스틱서치에서는 타입(type)이 RDBMS의 테이블에 대응하는 것을 기억하자. 즉 엘라스틱서치에서는 한 database에 한 테이블만이 존재한다고 볼 수 있다.

그렇다면 그 방대한 릴레이션 테이블을 엘라스틱 서치에서는 어떻게 처리할까? 답은 간단하다. 하나의 인덱스는 하나의 타입만 가져야 하니, 다수의 인덱스를 만들어 이를 사용하면 된다. 엘라스틱서치에는 실제로 여러 인덱스를 동시에 검색하는 기능도 있다.

인덱스에 포함된 문서들은 다수의 노드에 나누어 저장된다. (노드란 엘라스틱 서치가 수행 중인 물리적인 서버를 말한다.) 운영에는 여러 인덱스가 존재하기 때문에 한 노드에서는 이 여러 인덱스의 일부 문서를 관리하게 된다.

>index vs indices 차이
>index: 색인 데이터
>indices: 매핑 정보를 저장하는 논리적인 데이터 공간

## Type(타입)

타입은 인덱스의 논리적 구조를 말한다. 타입은 RDBMS에서 테이블에 해당한다. 엘라스틱 서치 6.0이하 버전에서는 하나의 인덱스에 여러 타입을 설정이 가능했지만 **6.1버전부터는 인덱스당 하나의 타입만 사용할 수 있다.** 

## Document(문서)

문서(Document)는 엘라스틱서치에서 데이터가 저장되는 최소단위이다. 기본적으로 JSON 포맷으로 데이터가 저장된다. RDBMS에서는 테이블의 한 행을 의미한다. 
하나의 문서는 다수의 필드(컬럼)으로 구성되는데, 각 필드는 데이터 속성에 따라 용도에 맞는 데이터 타입(DataType)이 정의되어야 한다. 또한 문서는 중첩 구조를 지원하기 때문에 문서안에 또 다른 문서를 지정하는 것도 가능하다. 

## Field(필드)

필드(Field)는 문서를 구성하는 여러 속성이다. RDBMS 테이블의 컬럼에 대응하지만 컬럼이 정적인 데이터 타입인데 반해 필드는 좀 더 동적인 타입이다. 더 동적이라고 설명한 이유는 하나의 필드가 목적에 따라 다수의 데이터 타입을 가질 수 있기 때문이다. 영화 정보를 담아둔 문서에 제목 필드가 있다고 생각해보자. 영화 제목을 검색할때 매칭 검색을 하거나 초성을 이용한 검색이 모두 지원되도록 하려면 제목 필드는 2개의 데이터 타입을 가져야 한다. 

## mapping(매핑)

매핑은 문서의 필드와 필드 속성을 정의하고 그에 따른 색인 방법을 정의한다. 인덱스의 매핑 정보에는 여러 데이터 타입을 지정할 수 있지만 필드명을 중복해서 사용할 수는 없다.

# Component

## 클러스터(Cluster)

클러스터는 노드(물리적 서버)들의 집합이다. 같은 클러스터 내부의 데이터민 서로 공유가 가능하기 때문에 연관된 노드들끼리 하나의 클러스터로 구성하는 것이 매우 중요하다.  

아래 그림에서는 하나의 클러스터만 가정했지만, 여러 개의 클러스터를 구성할 수도 있으며, 이럴때는 클러스터의 이름으로 클러스터를 구분한다. 이 이름은 중요한데, 어떤 노드가 어느 클러스터에 포함되기 되는지를 이름으로 판별하기 때문이다. 

같은 클러스터에 속한 노드들은 평소 데이터 색인이나 검색 작업을 함께 수행하게 되고 장애가 발생했을때도 데이터 복구를 위해 서로 협력해서 복구한다.

>Cross Cluster Search
>실무에서 업무를 하다보면 데이터 성격에 따라 다수의 클러스터를 운영하게 된다. 데이터가 커지고 복잡해지면 필연적으로 다수의 클러스터를 함께 검색해야하는 일도 빈번히 발생한다.
>엘라스틱서치에서는 이처럼 다양한 필요에의해서 다수의 클러스터를 한번에 검색할 수 있는 기능을 제공하는데 그것이 Cross Cluster search다. 

![enter image description here](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https://t1.daumcdn.net/cfile/tistory/99AB08425C9F17D928)


## 노드(Node)

노드는 클러스터에 포함된 단일 서버로서 데이터를 저장하고 클러스터의 색인화 및 검색 기능에 참여한다. 노드를 좀 더 정확하게는 설명하자면, 다수의 물리 서버에 엘라스틱서치를 설치하고 실제 실행 중인 엘라스틱서치 인스턴스를 노드라고 한다.

노드는 클러스터처럼 이름으로 식별되는데, 기본 이름은 시작 시 노드에 지정되는 임의 UUID(Universally Unique IDentifier)이다. 원한다면 기본 이름 대신 어떤 노드 이름도 정의할 수 있다. 이 이름은 관리 목적으로 중요한데 어떤 서버가 클러스터의 어떤 노드에 해당하는지 식별해야 하기 때문이다.

같은 클러스터에 속한 모든 노드는 서로 다른 노드와 수시로 정보를 주고 받는다. 노드 별로 분산 처리를 위해선 다양한 형태의 노드를 조합해서 클러스터를 구성해야 한다. 기본적으로 마스터 노드가 노드 추가, 삭제와 같은 전체적인 클러스터를 관리하고 데이터 노드는 데이터 검색, 색인등을 수행한다. 설정에 따라 4가지 유형의 노드가 존재한다. 

마스터 노드의 경우, 클러스터 전체를 제어하기 때문에 물리적으로 분리해서 독립적으로 운영하는 것이 좋다.

### 마스터 노드(Master Node)

마스터 노드는 노드 추가와 제거 같은 클러스터 수준의 전반적인 작업을 대표해서 처리한다. 따라서 네트워크 속도가 빠르고 지연이 없는 노드를 마스터 노드로 선정해야 한다. 다수의 노드를 마스터 노드로 설정할 수 있지만 결과적으로 하나의 노드만이 마스터 노드로 선출되어 동작한다. 

### 데이터 노드(Data Node)

데이터 노드는 문서가 실제 저장되는 노드다. 데이터가 분산 저장되는 물리적 공간인 샤드가 배치되는 노드이기도 하다. 색인 작업은 CPU, 메모리, 스토리지 같은 컴퓨팅 리로스를 많이 소모하기 때문에 리소스 모니터링이 필요하다. 

데이터 노드는 가능한 한 마스터 노드와 분리해서 구성하는 게 좋다. 단 색인할 문서가 적으면 함께 구성해도 상관은 없다. 

### 인제스트 노드(Ingest Node)
색인에 앞서 데이터 전처리를 위한 노드다. 데이터의 포맷을 변경하기 위해 스크립트로 전처리 파이프라인을 구성하고 실행할 수 있다. 

### 코디네이팅 노드(Coordinating Node)

마스터 노드, 데이터 노드, 인제스트 노드의 역할을 하지 않고 단순히 들어온 요청을 라운드 로빈 방식으로 분산시켜주는 노드다. 

## Shard(샤드)

검색 시스템은 엄청난 양의 문서를 다루어야 하고, 개념상 이 문서의 개수는 무한대로 늘어날 수 있다. 이런 상황에서 하나의 하드웨어에서 제공하는 리소스의 물리적인 한계를 넘기 위해 도입한 개념이 바로 샤드이다. 샤드를 이용하면 문서를 분산 저장할때 손쉽게 수평확장이 가능해진다.

>Shard의 중요성
>지속적으로 증가하는 컨텐츠가 수평적으로 분할되어 하드웨어의 한계를 극복할 수 있다.
>여러 노드에서 샤드를 통해 분산 처리되므로 성능이나 처리량을 향상 시킬 수 있다.

인덱스로 색인된 문서들은 분산 저장을 위해 여러 파티션으로 나뉜다. 이 파티션을 바로 샤드(Shard)이라 부른다. 그렇기 때문에 샤드는 인덱스 전체 문서 데이터의 부분 집합으로 이해할 수도 있다. 엘라스틱서치는 다수의 샤드로 문서를 분산 저장하고 있어 데이터 손실 위험을 줄이고 갹 샤드는 자신이 가지고 있는 데이터만으로도 독립적인 검색 서비스가 가능하다. 

실제로 인덱스에 쿼리를 요청하면 인덱스가 가지고 있는 모든 샤드로 검색 요청이 전달되고 각 샤드에서 1차적인 검색이 이뤄진 후 그 결과를 취합해서 최종 결과로 제공한다. 인덱스가 샤드로 분산되는 과정이나 검색 요청이 각 샤드에 분산되어 처리되는 복잡한 프로세스는 사용자에게 완벽하게 블랙박스이다. 

샤드는 두 종류가 존재한다. 첫 번째는 실제 서비스가 일어나는 프라이머리 샤드이다. 두번째는 레플리카 샤드다. 기본적으로 장애 복구를 위해 존재한다. 하지만 프라이머리 샤드와 동일한 데이터를 가지고 있기 때문에 평상시에는 읽기 분산에도 활용된다. 


엘라스틱서치를 분산환경으로 구성하면 인덱스 생성시 기본적으로 5개의 프라이머리 샤드와 1개의 레플리카 샤드를 기본 세트로 생성한다. 각 샤드 수는 인덱스를 생성할때 옵션으로 변경할 수 있다. 

### Primary Shard



## Replica(레플리카)

샤드에는 두 종류가 존재한다. 첫번째는 실제 서비스가 일어나느 프라이머리 샤드이다. 두번째는 레플리카 샤드다. 기본적으로 장애 복구를 위해 존재한다. 하지만 프라이머리 샤드와 동일한 데이터를 가지고 있기 때문에 평상시에는 읽기 분산에도 활용된다. 

엘라스틱서치에서는 최초 인덱스를 생성할때 settings 속성을 이용해 샤드와 레플리카 개수를 각각 정의할 수 있다. 

number_of_shards
: 샤드의 개수(number_of_shards)는 전체 데이터를 몇개의 샤드로 나누어 보관할지를 의미한다. 이 값으로 프라이머리 샤드의 개수가 결정된다.

number_of_replicas

: 레플리카 개수(number_of_replicas)는 몇개의 복사본 세트를 만들것인지를 의미한다. 이 속성 값으로 레플리카 샤드 세트의 개수가 결정된다.

한 임의의 인덱스를 생성할때 만약 5개의 샤드와 1개의 레플리카 세트를 만든다고 했고 시간이 흘러 인덱스에 총 1억건의 데이터가 색인 됐다고 가정해보자. 5개의 프라이머리 샤드를 설정했기 때문에 각 샤드는 2천건의 데이터를 가져가게 될것이다. 


(프라이머리) 샤드의 복제본을 레플리카 (Replica)라고 한다. 엘라스틱서치에서는 인덱스를 생성할때 기본적으로 1개의 레플리카 세트를 생성한다. (1개의 레플리카를 만든다는게 아니다.) 검색 시 레플리카가 적극적으로 활용되기 때문에 이를 이용하면 읽기 분산 성능이 좋아진다.

수평적으로 분산된 시스템을 운영할때는 언제든 장애가 나타날 수 있다. 네트워크 특성상 특정 노드가 오프라인으로 변경될 경우 페일오버(Failover) 메커니즘을 적극적으로 활용하는 것이 좋은데 엘라스틱서치에서는 레플리카를 이용한 페일오버 메커니즘을 제공하고 있고 이를 이용해 안정적인 클러스터 운영을 보장한다. 

인덱스가 생성될 때 샤드 개수와 레플리카 개수를 자유롭게 설정할 수 있다.하지만 인덱스가 생성된 이후에는 샤드 개수를 변경하는 것이 불가능하기 때문에 이 점에 유의하자. 그에 반해 레플리카의 갯수는 인덱스를 생성한 이후에도 자유롭게 변경하는 것이 가능하다. 그렇게 때문에 운영 중 트래픽 증가에 대한 유연한 대응이 가능해진다. 이는 검색 엔진의 특성상 읽기 연산이 대부분이기 때문에 매우 유용한 기능이다.

>엘라스틱서치의 고가용성
>엘라스틱서치에서는 샤드나 노드에 장애가 발생할 경우, 즉각적인 복구가 가능하기 때문에 안정적인 클러스터 운영이 가능해진다. 페일오버 메커니즘을 송공적으로 구현하기 위해 레플리카는 기본적으로 원본 샤드가 존재하지 노드에서 생성된다. 또한 검색 시 샤드와 레플리카에서 병렬로 실행될 수 있기 때문에 검색 성능이 좋아진다.



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4MzcyOTEwLC0yMDY5NjgwNDUxXX0=
-->